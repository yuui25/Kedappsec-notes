## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - この技術で満たす/破れる点：ビジネスルール強制（重要操作の一回性）、取引整合性（原子性・一貫性）、再送/重複耐性（idempotency）、監査（重複試行と結果の追跡）、可用性（リトライ増殖の制御）
  - 支える前提：現実の分散システムは「少なくとも一回」届く／実行される。ネットワーク断・タイムアウト・クライアント再送・ジョブ再実行・Webhook再送が常に起きるため、“二重実行されても壊れない設計”がないと、課金・承認・権限・在庫・状態遷移の事故が起きる。
- WSTG：
  - 該当テスト観点：Business Logic Testing（重要操作の二重実行）、API Testing（再送/timeout/再試行、競合）、Authorization Testing（権限変更/承認の二重実行の影響）、Error Handling（タイムアウト時の挙動）
  - どの観測に対応するか：同一操作（POST/PUT/PATCH/mutation）を「再送」「並行」「順序入替」で観測し、(1)一回性（idempotent）、(2)競合制御（race）、(3)返却の一貫性（同じ結果を返す）、(4)監査（request_id/idempotency_key）、を低侵襲で確定する
- PTES：
  - 該当フェーズ：Information Gathering（重要操作/非同期/再送点の列挙、idempotency-key仕様把握）、Vulnerability Analysis（欠落：キー設計/原子性/ユニーク制約/アウトボックス）、Exploitation（最小差分で成立条件確定：副作用を最小化しつつ二重実行の影響を示す）
  - 前後フェーズとの繋がり（1行）：Webhook（04/05）とAsync Job（07）は再送・再実行の入口であり、AuthZの重要操作（03_authz_06）と状態遷移（03_authz_10）に直結する。06はそれらを壊さないための“境界の中核”として設計・観測・証跡化する
- MITRE ATT&CK：
  - 戦術：Impact / Defense Evasion
  - 目的：二重実行で二重課金・重複支払・重複権限付与などの業務破壊（Impact）、失敗/タイムアウトを利用して“実行済みを隠す/再試行を誘発”する形の悪用（Defense Evasion）。Idempotency欠如は“事故”にも“悪用”にもなる。

## タイトル
idempotency_レースと二重実行境界

## 目的（この技術で到達する状態）
- “二重実行が起きる現実”を前提に、API/ジョブ/Webhook/操作UIの全てで一回性を担保するための設計要素（idempotency key、原子性、ユニーク制約、アウトボックス、競合制御、監査）をモデル化し、ペネトレで低侵襲に欠落を確定できる
- 「POSTは非冪等」「GETは冪等」という教科書だけでは不十分な実務を、重要操作（送金/承認/権限/発行/削除）中心に整理して、設計・テスト・監査に落とせる
- 競合（race）と二重実行を同一テーマで扱い、“チェック→更新”のTOCTOUを潰す指針（原子更新、ロック、状態機械）まで踏み込む

## 前提（対象・範囲・想定）
- 対象：副作用を伴う操作全般（特に重要操作）
  - 例：決済・請求確定・送金・承認・権限付与/剥奪・在庫引当・注文確定・ポイント付与・メール送信・ファイル生成
- 二重実行が起きる経路（現実的な原因）
  - クライアント再送（通信断、リロード、モバイル回線、ブラウザ二重クリック）
  - タイムアウト後の再試行（サーバは処理中だったが応答が遅い）
  - ロードバランサ/ゲートウェイのリトライ
  - Webhook再送（at-least-once）
  - キュー/ワーカーの再実行（可視性タイムアウト、ワーカー落ち、DLQ再投入）
  - 管理運用の手動再実行（“もう一回押す”）
- ペネトレ上の安全配慮
  - 本番では“二重実行で実害が出る操作”を避け、テスト環境/テストテナントを前提にする
  - 本番でやるなら「副作用が可逆/軽微」「dry-run」「検証フラグ」等の経路に限定し、証跡は観測中心（返却の一貫性・監査）で取る

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
### 1) “冪等性”を3層に分解する（現実運用に必要）
冪等性は「同じリクエストを何度送っても同じ最終状態」だが、実務では層がある。
- 層A：副作用の一回性（核心）
  - 二度実行しても二重課金・二重付与・二重遷移が起きない
- 層B：レスポンスの一貫性（操作の観測可能性）
  - 二回目以降は「最初の結果」を返す（同じresource id、同じstatus等）
- 層C：監査と相関（調査可能性）
  - request_id/idempotency_key/event_id がログ/監査に残り、重複と結果が追える
観測ではAが最重要、B/Cは“安全運用”に不可欠。

### 2) どこで冪等性を担保するか（境界の強制点：PEP/PDP）
- 強制点の候補（現実的）
  - API Gateway / Edge（同一キーの重複抑止：限定的、分散性に弱い）
  - アプリ層（最も一般的：キー検証、DB記録）
  - DB層（ユニーク制約、トランザクション：最も確実だが設計が必要）
  - キュー/ワーカー層（ジョブ重複排除）
- 観測で確定したい点
  - どの層が“最終的な一回性”を保証しているか（表面のWAF/レートだけでは不十分）
  - “入口”ごとに保証が変わらないか（UI/REST/GraphQL/Webhook/Job）

### 3) idempotency-key設計：現実で使える最小要件（実装に踏み込む）
#### 3.1 キーの種類（代表）
- クライアント提供キー（Idempotency-Keyヘッダ等）
  - クライアントが再送時に同じキーを使う
- サーバ生成キー（操作の自然キー）
  - 例：order_id + action + version
- イベントID（Webhook/メッセージ）
  - providerのevent_idをキーにする（04と接続）
- 取引キー（payment_intent等）
  - 支払プロバイダ側の一意IDに束縛
#### 3.2 キー設計の必須条件
- スコープ（重要）：キーは必ず “テナント/主体/操作” に束縛される
  - 同じキー文字列でも、tenantが違えば別扱い（混線防止）
- TTL（保持期間）：再送が起き得る期間だけ保持（短すぎると事故る）
- 結果キャッシュ：キーに紐づく “最初の結果” を保存し、二回目は同じ結果を返す（層B）
- 失敗の扱い：中途失敗時にキーが“消えて再実行”にならないよう設計
  - “処理中”状態（in-progress）も記録し、競合を止める
#### 3.3 典型の失敗（現実頻出）
- キーが無い（そもそも未導入）
- キーがあっても “同じ結果を返さない”（二回目が別resourceを作る）
- キーがtenantに束縛されず、他tenantと衝突/悪用（03と直結）
- TTLが短く、遅延再送で二重実行
- “処理中”を表現できず、並行実行で二重に走る

### 4) 原子性（atomicity）：チェック→更新のTOCTOUを潰す
二重実行は「同じリクエストを2回」だけでなく「並行に同時に走る」ことで起きる。
- よくある壊れ方
  - if (not processed) then process → 2並行で両方not processedを読む
- 防御（実装の現実）
  - DBトランザクションで “存在しなければ挿入” を原子化（ユニーク制約）
  - 楽観ロック（version/etag）で競合を検知しリトライ
  - 悲観ロック（select for update）で直列化（スループット低下とトレードオフ）
  - 状態機械（state machine）として許容遷移だけを原子更新（10と接続）
- 観測で確定したい点
  - 競合時に “二重適用” にならず、どちらかが安全に拒否/同結果になるか
  - 競合のエラーが一貫しているか（04_api_09）

### 5) ユニーク制約（Uniq）と重複排除テーブル：DBで守るのが最も確実
- 実務で強いパターン
  - idempotency_keys テーブル（tenant_id, key, operation）にユニーク制約
  - 処理結果（resource_id, status, response_hash 等）を保存
  - 状態：in_progress / completed / failed を保持
- 重要：ユニーク制約は “仕様” をDBに刻む
  - アプリのバグがあっても二重挿入を止める
- 観測で確定したい点（ペネトレでは推測になることが多い）
  - 二回目のリクエストで “同一IDが返る” か（結果キャッシュの兆候）
  - 競合時の応答が “一貫して衝突” になるか（ユニーク制約の兆候）

### 6) アウトボックス（Outbox）/二相の副作用：外部送信・通知・Webhook発火を二重にしない
内部更新と外部送信（メール、Webhook、キュー投入）が分離されると二重実行が起きやすい。
- 典型事故
  - DB更新は成功、外部送信は失敗 → リトライで外部送信が二重
  - 外部送信が先に行われ、DB更新が失敗 → 整合崩壊
- 実務で採用される設計
  - Outboxテーブルにイベントを記録（DBトランザクション内）
  - 別プロセスがOutboxを読み、外部送信（重複排除つき）
- 観測で確定したい点
  - 重要操作が外部送信を伴う場合、送信が二重にならない設計か（ログ/監査で兆候を追う）

### 7) 返却の設計：二回目は“同じもの”を返す（操作の安定性）
- 実務で必要な振る舞い
  - 同じidempotency-keyなら同じresource_id/状態を返す
  - “処理中”の場合は 202 / 状態照会URL を返す（同期で待たない）
- 危険な振る舞い
  - 二回目が 500/タイムアウト → クライアントがさらに再送（増殖）
  - 二回目が別IDを返す（重複生成）
- 観測で確定したい点
  - 二回目以降の応答が安定するか（同一結果か、明確な拒否か）

### 8) レート制御は冪等性の代替ではない（補助輪）
- レート制御で防げるのは“連打”だけで、タイムアウト再送や分散再試行は残る
- 観測で確定したい点
  - 冪等性が無いのにレートだけで抑えていないか（事故は残る）

### 9) 観測のための“確認（confirmation）”を最大限詳しく：どうやって確定するか
ペネトレでは実装（DB）を見られないことが多い。よって、挙動と証跡で確定する。

#### 9.1 確認の原則（低侵襲で、かつ証跡が残る）
- 原則1：同一操作を「同じ入力で2回」だけ行い、差分を取る
- 原則2：副作用が重い操作は “テスト環境/テストテナント” で実施
- 原則3：可能なら “dry-run / preview / validate” を先に探す（副作用なしで境界を推定）
- 原則4：確認に使う相関キーを固定する（request_id / idempotency-key / event_id）
- 原則5：結果は (a)リソースID、(b)状態、(c)監査ログ、(d)外部副作用（通知/メール等）の4点で照合する

#### 9.2 確認ステップ（観測の粒度）
- ステップA：仕様の有無を確認（入力面）
  - idempotency-keyヘッダが仕様にあるか、レスポンスヘッダに反映されるか
  - Webhookならevent_idがあるか、ジョブならjob_idがあるか
- ステップB：二回送った時の“レスポンスの同一性”を確認（層B）
  - status code が同じか
  - bodyの resource_id が同じか
  - “既に処理済み”と明示するか（良い）
  - 二回目が別resourceを作る/別ID → 欠落の強い兆候
- ステップC：副作用の一回性を確認（層A）
  - オブジェクトの状態遷移が1回だけ起きているか（10）
  - 金額/在庫/権限などのカウンタが二重に増えないか
  - 外部通知が二重にならないか（Outboxの有無の兆候）
- ステップD：競合（race）耐性を確認（層A）
  - 同時に2回実行された場合でも二重適用にならないか
  - どちらかが衝突として扱われるか、同じ結果に収束するか
- ステップE：監査・相関を確認（層C）
  - 監査ログに idempotency-key / request_id が残るか
  - “重複として拒否/同結果返却”が記録されるか
  - trace_id でAPI→ジョブ→外部送信が追えるか
- ステップF：失敗パスを確認（最重要：現実は失敗する）
  - タイムアウト/一時障害時に、再送しても二重実行にならないか
  - “処理中”が表現されていて、クライアントが再送増殖しないか

#### 9.3 確認で使う“差分観測”の代表軸（実務で効く）
- 2回目の結果が：
  - 同一結果（理想）
  - 明確に拒否（409等）で、1回目の結果が参照可能（良い）
  - 500/タイムアウト（悪い：再送増殖）
  - 別の結果（最悪：重複生成）
- 2回目の処理時間が：
  - 速い（結果キャッシュ/重複判定がある兆候）
  - 同程度に遅い（毎回処理している兆候）
- 監査が：
  - 追える（良い：抑止と調査が可能）
  - 追えない（悪い：事故が隠れる）

#### 9.4 “確認できた”と言うための最低限の証跡セット
- HTTP（またはジョブ）証跡
  - 1回目と2回目のリクエスト（同一入力、同一キー）
  - 1回目と2回目のレスポンス（resource_id、status、エラー形状）
- 状態証跡
  - 実行前後のオブジェクト状態（GET等で確認）
- 監査証跡（あれば最強）
  - idempotency-key / request_id / event_id を含むログ行（もしくは監査画面の記録）

### 10) idempotency_race_doubleexec_boundary_key（正規化キー：後続へ渡す）
- 推奨キー：idempotency_race_doubleexec_boundary_key
  - idempotency_race_doubleexec_boundary_key =
    <idempotency_support>(header_key|natural_key|event_id|none|unknown)
    + <key_scope_binding>(tenant+actor+operation|partial|weak|unknown)
    + <result_replay>(same_response|conflict_with_reference|unstable|unknown)
    + <in_progress_handling>(yes/no/unknown)
    + <atomicity>(db_unique|tx_lock|optimistic|none|unknown)
    + <race_behavior>(safe_converge|double_apply|unknown)
    + <outbox_pattern>(yes/no/unknown)
    + <retry_behavior>(safe_stop|unsafe_retry|unknown)
    + <audit_strength>(strong|partial|weak|unknown)
    + <confidence>
- 記録の最小フィールド（推奨）
  - 対象操作（endpoint/operationName）
  - idempotency-key仕様（ヘッダ/イベントID/自然キー）
  - 2回実行の差分（resource_id、status、処理時間）
  - 競合時の挙動（安全に収束するか）
  - 監査（キー/trace_idが残るか）
  - evidence（HAR、状態before/after、ログ断片）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定できる）：
  - 重要操作が二重実行に耐える設計か（少数差分で“同結果/拒否/重複生成”を確定）
  - idempotency-keyが仕様として存在し、スコープ束縛・結果再生ができているか
  - 競合（race）時に安全に収束するか（double_applyが起きないか）
  - 失敗パス（タイムアウト/再送）で事故が増殖しない設計か
  - 監査で重複試行と結果を追跡できるか
- 推定（根拠付きで言える）：
  - 結果が不安定/別ID生成なら、DB/原子性の境界が弱い可能性が高い
  - 500多発や処理中表現無しは、再送増殖による事故リスクが高い
- 言えない（この段階では断定しない）：
  - どの実装（ユニーク制約/ロック/アウトボックス）で守っているか。だが、挙動から必要な是正を提案できる。

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- 優先度（P0/P1/P2）
  - P0：
    - 二回目で別リソース生成、または二重課金/二重付与/二重遷移が起きる
    - 競合でdouble_applyが起きる（原子性欠如）
    - 失敗時にunsafe retryが増殖し、操作が繰り返し走る
  - P1：
    - idempotency-keyがあるがスコープ束縛が弱い（tenant混線の可能性）
    - 二回目が500/タイムアウトで再送を誘発
    - 監査が弱く、事故の追跡が困難
  - P2：
    - 設計は堅牢だが運用（キー保持期間/回帰テスト）が弱い
- “成立条件”としての整理（技術者が直すべき対象）
  - 重要操作は必ずidempotencyを要求（キー必須化）
  - キーは tenant+actor+operation に束縛し、結果を保存して再生する
  - 原子性はDB（ユニーク制約＋トランザクション）で担保し、アプリif文だけに頼らない
  - “処理中”を表現し、タイムアウト後の再送でも事故が増殖しないようにする
  - 外部送信はOutbox等で二重送信を防ぐ
  - 監査に相関キーを必須化する

## 次に試すこと（仮説A/Bの分岐と検証：低侵襲で確定）
- 仮説A：idempotencyが未実装
  - 次の検証（差分）：
    - 同一入力を2回送って、resource_idが変わる/副作用が二重になるかを観測
  - 判断：
    - 変わる/二重：P0
- 仮説B：race耐性が弱い（原子性欠如）
  - 次の検証：
    - 同時実行に近い形で2回発火し、double_applyが起きないかを観測（テスト環境推奨）
  - 判断：
    - double_apply：P0
- 仮説C：失敗パスで増殖する
  - 次の検証：
    - タイムアウト/一時失敗時の再送で結果が安定するか（処理中表現/同結果返却）を観測
  - 判断：
    - 不安定/500：P1〜P0
- 仮説D：キー束縛が弱い
  - 次の検証：
    - テナント/ユーザが異なる状況でキーが干渉しないか（衝突/参照）を観測（可能なら）
  - 判断：
    - 干渉：P0（越境の一種）

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - `04_labs/02_web/04_api/06_idempotency_race_doubleexec_boundary/`
    - 構成案（現実運用の再現）
      - 重要操作：approve（状態遷移）、charge（課金）、grant_role（権限付与）を用意
      - 経路：UI→API、Webhook→API、Async Job→処理 を用意
      - 防御切替：
        - idempotency-key必須/任意/無し
        - キー束縛（tenant+actor+op）有/無
        - DBユニーク制約ON/OFF
        - in_progress状態ON/OFF
        - Outbox ON/OFF
      - 監査：request_id/idempotency_key/event_id/trace_id を必須出力
      - テスト：再送（2回）、競合（擬似同時）、タイムアウト（遅延挿入）を再現
- 取得する証跡（深掘り向け：HTTP＋周辺ログ）
  - HTTP：1回目/2回目のリクエスト＆レスポンス（同一キー）
  - 状態：before/after（状態遷移、カウンタ）
  - ログ：重複判定、ユニーク衝突、in_progress、trace_id相関
  - 外部副作用：通知/送信が二重にならない根拠（Outboxログ）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
~~~~
# idempotency-key 付き重要操作（擬似）
POST /api/payments
Headers:
  Idempotency-Key: K-abc123
Body:
  { "order_id": "O1001", "amount": 5000 }

# 2回目（同一キー・同一入力）
POST /api/payments
Headers:
  Idempotency-Key: K-abc123
Body:
  { "order_id": "O1001", "amount": 5000 }

# 観測すること（擬似）
- 2回とも同じ payment_id が返るか
- 2回目が速いか（重複判定/結果再生の兆候）
- 監査に K-abc123 が残り、重複として記録されるか
- 失敗/タイムアウト時に “処理中/再照会” を返せるか
~~~~
- この例で観測していること：
  - 二重実行が“同結果に収束”し、事故が増殖しない境界になっているか
- 出力のどこを見るか（注目点）：
  - idempotency_support、result_replay、atomicity、race_behavior、in_progress_handling、retry_behavior、audit_strength
- この例が使えないケース（前提が崩れるケース）：
  - idempotency-keyが仕様に無い場合：自然キー（order_id+action）やevent_idのユニーク化、ユニーク制約で担保すべき、という是正に寄せる

## 参考（必要最小限）
- OWASP ASVS（ビジネスルール、取引整合性、監査）
- OWASP WSTG（Business Logic / API：二重実行・競合）
- PTES（低侵襲差分で成立条件を確定）
- MITRE ATT&CK（Impact：二重実行による業務破壊）

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/04_api_04_webhook_受信側の信頼境界（署名_再送）.md`
- `01_topics/02_web/04_api_07_async_job_権限伝播（キュー_ワーカー）.md`
- `01_topics/02_web/03_authz_10_object_state_状態遷移と権限（draft_approved）.md`

## 次（04_api_07 以降）に進む前に確認したいこと（必要なら回答）
- 04_api_07（async job）では、idempotencyを“ジョブ境界”に拡張し、権限伝播（誰の権限で走るか）・再実行・可視性タイムアウト・DLQ・監査相関を、実装レベル（C指定）で最大限深掘りする
