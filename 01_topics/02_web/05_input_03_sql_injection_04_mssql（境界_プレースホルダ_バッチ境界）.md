## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）

- ASVS
  - 満たす/破れる点
    - パラメータ化（値のバインド）で「入力→SQL」を遮断できているか（ただし識別子/構文/断片は別）
    - 動的SQL（EXEC / sp_executesql）に入力が混ざる境界を設計で閉じているか（allowlist/QUOTENAME/固定テンプレ）
    - エラー処理の統一（変換エラー・構文エラー・タイムアウトが“差分＝オラクル”にならない）
    - DB権限最小化（アプリ接続ユーザの権限、EXEC権限、危険な拡張機能の無効化）
    - 監査（失敗頻度、遅延、例外種別、同一入力点の反復）を相関し、ブラインド/低ノイズ探索を検知
- WSTG
  - SQLiテスト：入力点ごとに sink（値/識別子/断片/動的SQL）を確定し、MSSQLの“バッチ境界”を成立根拠として扱う
  - エラーハンドリング：変換エラー（CONVERT/CAST系）や例外モデルが差分として漏れるかを観測
  - 認可/マルチテナント：SQL改変で tenant 条件付与が崩れる前提で、越境混入の観測設計を持つ
- PTES
  - Vulnerability Analysis：MSSQL特有の差分（バッチ/複文/変換/待ち）で成立根拠を最小差分で確定
  - Exploitation：影響実証は必要最小限（読み取り範囲/越境混入の確認に留め、破壊的操作は避ける）
  - Reporting：根本原因を「バッチ境界（複文可否）」「動的SQL」「ORM/raw」「識別子allowlist欠落」「権限/設定境界」に分解して提示
- MITRE ATT&CK
  - TA0001 Initial Access（公開アプリ入口）/ TA0009 Collection / TA0006 Credential Access（DB内に資格情報がある場合）/ TA0005 Defense Evasion（エラー統一下でブラインド化）
  - 代表：T1190 Exploit Public-Facing Application（SQLiは典型）

## タイトル
sql_injection_04_mssql（境界_プレースホルダ_バッチ境界）

## 目的（この技術で到達する状態）
- MSSQL（SQL Server / T-SQL）でのSQLiを「値のバインドがあっても成立する境界」として説明できる
- 特に、MSSQLで影響度を跳ね上げる **バッチ境界（複文の成立条件）** を、脆弱性の有無（構文化）と切り離して整理し、
  - 何が成立根拠（oracle）なのか
  - 何が“設定/実装の別軸”で影響を増幅するのか
  を、最小の差分観測で確定できる
- 開発側へ「直し方」を、(1)値はバインド、(2)動的SQLを禁止/限定、(3)識別子はallowlist+QUOTENAME、(4)例外モデル統一、(5)最小権限と危険機能無効化、の設計課題として返せる

## 前提（対象・範囲・想定）
- 対象
  - SQL Server（オンプレ/クラウド問わず）をバックエンドに持つWeb/API
  - 検索/一覧/ソート/ページング/レポート/エクスポート/管理UI（入力自由度が高いほど危険）
- 想定実装
  - ドライバ：ADO.NET / JDBC / ODBC / Node(mssql) / Python(pyodbc) 等
  - ORM/Query Builder：EF Core / Dapper / Hibernate / Prisma 等
  - ただし、MSSQLは「ストアド/動的SQL/複文」に逃げ道が残りやすく、ORMでも境界が破れる
- 本ファイルの焦点
  - MSSQL方言の差分（oracle）と、バッチ境界（複文の成立条件）を軸に、成立確定→原因特定→修正設計へ繋ぐ
- 実務配慮
  - 影響が大きい検証（長時間待ち、外部到達、危険機能）を避け、差分観測は最小回数・短時間で行う
  - “できる/できない”の断定を、契約範囲・環境差（設定/権限）を分離して報告する

## MSSQLのコア概念：境界を2段で見る（脆弱性 と 影響増幅）
### A. 脆弱性（構文化）の境界
- 入力がSQLの **値（data）** ではなく **構文（code）** として解釈される状態
- これは「文字列結合」「動的SQL」「識別子の動的組立」「raw断片」などで発生する

### B. 影響増幅（バッチ境界）の別軸
- MSSQLは“複数文（stacked queries）”が成立すると影響が増幅しやすいが、
  - それは **脆弱性そのものではなく**、実装/ドライバ/設定/権限で左右される別軸
- したがって報告は常に分離する
  - 1) 構文化が成立（SQLi）＝脆弱性
  - 2) バッチ境界を越えて複文が成立（影響増幅）＝条件付きの追加リスク

## 観測ポイント（入力→組立→実行→反応）

### 1) sink（注入文脈）を最初に分類する
- 値（data）
  - WHERE/INSERT/UPDATEの値（本来はバインド可能）
- 識別子（identifier）
  - ORDER BY列、SELECT列、テーブル名、スキーマ名（原則バインド不可）
- 断片（fragment）
  - 条件式の一部、演算子、関数呼び出し、JOIN断片など
- 動的SQL（dynamic SQL）
  - EXEC / sp_executesql / 文字列からのSQL生成（MSSQLで最重要）
- 判断（次の一手）
  - 値で差分：バインド漏れ/結合箇所を疑い、プレースホルダ境界へ
  - 識別子/断片で差分：allowlist欠落（設計問題）として確定へ
  - 動的SQLで差分：EXEC境界（入力の混入）を最優先で特定（修正が“設計変更”になる）

### 2) MSSQL方言の「差分＝成立根拠（oracle）」の整理（最小差分で確定するため）
MSSQLは“語彙”よりも **変換・例外・待ち・複文条件**が差分になりやすい。

#### 2.1 Error oracle（変換/構文/名前解決）
- MSSQLは変換（CAST/CONVERT/TRY_系）に絡む差分が出やすい
  - 入力の形を変えると「変換不可」「演算子不一致」「列名/オブジェクト未解決」等の差分が安定しやすい
- 意味
  - “DB実行まで到達している”兆候であり、同時に「入力が数値/日付/UUID等として扱われている」推定器になる
- 注意
  - 本来は抑制されるべき情報（例外モデルの漏えい）なので、観測できたら脆弱性の証拠になる一方、以後は Boolean/Time に寄せて低侵襲にする

#### 2.2 Boolean oracle（推奨：件数/長さ/表示要素の差分）
- エラーが統一されていても成立する、最も実務的な確定根拠
- 差分指標（固定して使う）
  - 件数、レスポンス長、ページ数、特定フィールドの有無、ステータス（ただし認可と混ざる場合は慎重）

#### 2.3 Time oracle（短時間・少回数で）
- MSSQLは「待ち（wait）」が差分になりやすいが、時間差はノイズが大きい
- 実務では次を固定して使う
  - 遅延は短く（長時間待ちは避ける）
  - 試行回数を最小に（多試行はDoSに近づく）
  - タイムアウト・リトライ・キュー詰まりが差分に混ざる前提で、他指標（長さ/件数）と組み合わせる

#### 2.4 “バッチ境界（複文可否）”は oracle ではなく「影響条件」
- MSSQLの複文は、アプリ側が「1クエリとして送る」か「複文を許容する」かに左右される
- 重要な現実
  - `GO` は多くの場合 **クライアントツールの区切り**であり、Webアプリの実行境界では使えない（＝成立根拠にはしない）
  - `;`（ステートメント区切り）が実際に効くかは、実装・ORM・ドライバ・サニタイズの影響を受ける
- 結論
  - 脆弱性（構文化）があるか、影響増幅（複文）が可能かは、別々に検証・別々に報告する

### 3) プレースホルダ（パラメータ）境界：MSSQLでも守れない領域を明確化する
- バインドで守れる：値（data）
- バインドで守れない：識別子（列名/テーブル名/方向）、構文断片（条件式/演算子/関数名）
- MSSQLで特に問題化しやすい箇所
  - ORDER BY / SELECT列（列名を入力で受ける設計）
  - TOP / OFFSET / FETCH（ページングや上限指定を動的にする設計）
  - INリスト（CSV連結、可変条件で断片化）
  - 動的検索DSL（where=… を式文字列として受ける）
- 修正の基本形
  - 値は必ずパラメータ化
  - 識別子は allowlist + サーバ側マッピング（必要なら QUOTENAME を併用）
  - 条件式は“文字列”で受けない（安全なDSL→サーバ側で式生成）

### 4) 動的SQL（EXEC / sp_executesql）境界：MSSQLの本命
- 動的SQLは「正しく使えば安全」だが、「入力混入で即崩れる」
- 実務での根本原因の分解
  - 安全側：sp_executesql を使い、値はパラメータとして渡している（値の混入が起きにくい）
  - 危険側：入力をSQL文字列に連結して EXEC している（構文化の中心）
- 観測で確定したい点（黒箱でも可能）
  - 特定入力だけが“SQL由来の差分”を出す（実装が分岐している兆候：通常はORM、例外パスだけ動的SQL等）
  - sort/fields/filter など“構文側”の入力で差分が出る（allowlist欠落を示唆）
  - レポート/エクスポート/検索保存（second-order）で差分が出る（動的SQL再利用の兆候）

### 5) MSSQL特有の表現差分（方言当ては目的ではなく、検証設計の補助）
- 識別子のクォート
  - MSSQLは `[]` 文化が強い（ただしSQL標準の `""` もあり得る）
  - これがエラー表面や生成SQL断片に出るなら、識別子動的組立の疑いが強まる
- 文字列（Unicode）
  - `N'...'` のようなUnicodeリテラルが絡む実装もある
  - 差分の意味：入力の正規化/エンコードが絡み、同じ入力でも挙動が変わる（観測を固定する必要がある）

## 結果の意味（何が言える/言えない）
- 言える（確定できる）
  - 入力がどのsink（値/識別子/断片/動的SQL）に入っている可能性が高いか
  - 成立根拠（oracle）が何か（boolean/error/time/second-order）と再現性
  - “複文（バッチ境界）”が影響増幅条件として疑わしいか（ただし断定は根拠が必要）
- 断定しない（追加根拠が必要）
  - DB内部権限（sysadmin等）の断定
  - 危険機能（拡張手続き等）の可否断定（環境差が大きい）
  - 大量データ抽出の可否断定（契約範囲・権限・設計に依存）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
※本章は手順の提供ではなく、ペンテストでの優先度付け・仮説分岐を明文化する。

### 1) 優先度が上がる入口（MSSQLで“動的SQL”が入りやすい箇所）
- 検索/フィルタ/ソート/ページング（sort/fields/limit/offset）
- レポート・集計・エクスポート（列/条件/並べ替えの自由度が増える）
- 保存検索・テンプレ・条件の再利用（second-order）
- 管理UI（運用都合で“便利な動的SQL”が残りやすい）

### 2) MSSQLでの“成立根拠”の作り方（低侵襲優先）
- まず Boolean oracle（件数/長さ）で確定する（推奨）
- エラーが見えるなら、変換/名前解決差分を「コンテキスト推定」の補助に使う
- 時間差分は最後（短時間・少回数で、他指標と組み合わせる）
- “複文ができるか”は、脆弱性確定後に、契約範囲と影響を踏まえて慎重に扱う

### 3) “バッチ境界”をどう報告へ落とすか（誤解を避ける）
- 事実として書く（例）
  - SQLi（構文化）は成立（差分＝Xで再現）
  - 複文（影響増幅）については、条件（実装/設定/権限）次第で変化しうるため、現状観測できた範囲でのみ記載
- 書かない（推測で盛らない）
  - 「OSコマンド実行が可能」等の断定（危険機能/権限/設定の三重条件が必要で、黒箱だけでは断定できない）

## 次に試すこと（仮説A/B/C：最小差分で確定）

### 仮説A：値（data）のバインド漏れ/文字列結合がある
- 兆候
  - 入力の形を変えると変換/構文系の差分が安定する
- 次の一手
  - Boolean oracle（件数/長さ）で確定し、バインド漏れ箇所を“入力点の局所性”として横展開調査する
  - “特定条件だけraw/動的SQL”の分岐を疑う（例：特定検索モード、特定ソート条件）

### 仮説B：識別子（identifier）や断片（fragment）が動的組立されている
- 兆候
  - sort/fields/filter の自由度が高い、または不正値の扱いが一貫しない（落ちる/通るが混在）
- 次の一手
  - allowlist欠落として根本原因を固定（入力フィルタではなく、選択肢化・マッピングが必要）
  - ORDER BY / SELECT列 / TOP/OFFSET の設計をレビュー対象として明示する

### 仮説C：動的SQL（EXEC/sp_executesql）に入力が混ざっている
- 兆候
  - 特定入力でのみ“SQL由来の差分”が顕著（実装が動的SQLへ分岐）
  - second-order で差分が出る（保存値をSQL文字列に組み込んでいる可能性）
- 次の一手
  - 保存点と実行点を分離し、実行点側で差分（oracle）を確定する（爆発半径が大きいので優先）
  - 修正方針を「sp_executesql + パラメータ化（値）」へ寄せ、識別子は allowlist + QUOTENAME を併用する方向で提示

## 手を動かす検証（Labs連動：境界の再現）
- 目的：MSSQLで「バインド安全」「識別子動的」「動的SQL混入」「複文境界（条件付き）」を比較できる最小アプリを用意する
- 検証環境の設計案
  - エンドポイントを少数に絞り、差分が“どの境界”由来かを明確にする
    - (1) WHERE値：完全バインド（安全）
    - (2) WHERE値：一部連結（脆弱）
    - (3) ORDER BY：allowlistなし（脆弱）/ allowlistあり（安全）
    - (4) 動的SQL：sp_executesql（安全）/ EXEC連結（脆弱）
    - (5) 保存検索→管理実行（second-order）
  - 例外モデル：verbose / uniform を切替（error oracle の抑制有無を比較）
- 取る証跡（最小）
  - HAR：baseline / true / false（差分が見える最小3点）
  - サーバログ：trace_id、例外分類（変換/構文/タイムアウト）、実行時間
  - DBログ（Labsのみ）：実行SQLがパラメータ化か、動的SQLか

## 例（最小限：設計の違いを理解するための形）
~~~~
# 危険：識別子（列名/方向）を入力で組立（プレースホルダ化できない）
ORDER BY {user_sort} {user_dir}

# 安全：入力は選択肢、サーバ側で列名にマップ
sort=createdAt|name|price のように受け、
createdAt -> created_at
name     -> name
price    -> price
に変換して ORDER BY を生成（入力値を列名として使わない）
~~~~

~~~~
# 危険：INリストをCSV連結（可変条件で断片化）
WHERE id IN ({csv_ids})

# 安全：要素数分をパラメータ化（または安全な配列/TVP等の機構へ）
WHERE id IN (@p1, @p2, @p3, ...)
~~~~

~~~~
# 危険：動的SQLで入力を連結（構文化の中心）
EXEC( '... ' + {user_input} + ' ...' )

# 安全：動的SQLが必要でも、値はパラメータとして渡す（設計として）
sp_executesql '... WHERE col = @x ...', N'@x <type>', @x = {value}
~~~~

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `01_topics/02_web/04_api_08_file_export_エクスポート境界（CSV_PDF）.md`

## 次（作成候補順）
- `01_topics/02_web/05_input_04_nosql_injection_01_mongodb_01_operator（$ne_$gt_$regex）.md`
