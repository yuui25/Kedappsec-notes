## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 満たす/破れる点（この技術で満たす/破れる管理策）
    - 破れる：HTTPメッセージ境界（request boundary）がフロント（CDN/WAF/LB/Reverse Proxy）とバックエンドで不一致になり、「フロントが見ていないリクエスト」がバックで処理され得る。認可・ルーティング・監査の前提が崩れ、フロント依存の制御（WAF/ACL/認証前処理）を迂回する“設計上の抜け道”になる。
    - 満たす：曖昧な長さ決定（TE+CL、異常なTE、重複CL等）を最前段で拒否し、hop-by-hopヘッダを正規化する。H1/H2変換境界を含め、フロント/バックのパーサ前提を揃える。異常時はコネクションを破棄し、プールへ戻さない。
- WSTG
  - 該当テスト観点（どの観測・検証に対応するか）
    - Request Smugglingは「入力検証」ではなく「中継点（proxy）を跨いだ解釈差」の検証。CL.TEでは、フロントがContent-Lengthで区切り、バックがTransfer-Encoding: chunkedで区切る差により、“追加リクエスト（バックだけが認識）”が成立するかを、レスポンス対応関係・タイミング・ログ相関で確定する。
- PTES
  - 位置づけ
    - 脆弱性分析：対象スタック（CDN/WAF/LB/Reverse Proxy/アプリ）を分解し、どの層がCL/TEをどう扱うかの仮説を立てる。
    - 侵害評価：成立の芯は「バックが追加リクエストを処理した」ことの観測。次に、その追加リクエストが“高価値分岐”（認可・ルーティング・キャッシュ・監査）に届くかを詰める。
- MITRE ATT&CK
  - 位置づけ（攻撃者の目的）
    - Initial Access：T1190（公開アプリの脆弱性悪用）
    - Defense Evasion：フロント制御（WAF/ACL/認証ゲート）を“見えないリクエスト”として迂回する設計悪用
    - Collection / Credential Access：レスポンス混線、意図しないレスポンス取得、セッション関連の副作用が成立する構成では収集に接続
    - Impact：バックコネクション汚染・キュー滞留などのサービス劣化に接続（条件付き）

---

## タイトル
HTTP Request Smuggling（CL.TE）：フロントはCLで終端、バックはTE(chunked)で終端 → “フロントが見ない追加リクエスト”がバックで処理される

---

## 目的（このファイルで到達する状態）
- CL.TE（フロント：Content-Length優先 × バック：Transfer-Encoding(chunked)優先）の成立条件を、観測に基づく根拠として説明できる。
  1) どの構成で起きるか（どの層がCL/TEを信じるか）
  2) 何が起きるか（バックで追加リクエストが処理され、フロント制御を迂回し得る）
  3) どう観測して確定するか（response対応/タイミング/ログ相関）
  4) 実害を“分岐点”として評価できる（認可・ルーティング・キャッシュ・監査）
  5) 修正を“設計要件”として提示できる（拒否・正規化・パーサ統一・コネクション管理）

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：HTTP/1.1 Request Smuggling の CL.TE パターン（proxy desync）
  - フロントがContent-Lengthで“ここまでがボディ”と決め、バックがTransfer-Encoding: chunkedで“ここまでがボディ”と決める不一致
  - 結果として、バック側で“追加リクエスト”が成立する（フロントが監視/検査していない）
- 扱わない（ただし接続する）
  - TE.CL：`05_input_18_http_request_smuggling_01_te_cl（proxy_desync）.md`
  - HTTP/2フロント起因：`05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
  - 観測シグナル集約：`05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`

---

## 前提（CL.TEが成立しやすい“構成条件”）
### 1) 中継点が存在し、前段と後段でHTTPパーサが異なる
- クライアント→（CDN/WAF/LB/Reverse Proxy）→アプリ
- 前段は「受信して解釈→再送」するため、前段の解釈が境界の一次決定になる。

### 2) フロント→バックがHTTP/1.1 keep-alive / connection pool
- 追加リクエストが“同一バックコネクション上”で成立すると、
  - バックだけが先に処理してしまう
  - そのコネクションがプールに戻り、別の正規リクエストと混線する
という形で影響半径が拡大する（＝現実の“攻撃価値”が上がる）。

### 3) TEとCLの併記、またはTE解釈の揺れを許している
- CL.TEは典型的に「TE: chunked と CL が同時にある」曖昧なリクエストで発火する。
- フロントがCLを採用して“固定長で読み”、バックがTEを採用して“chunked終端で読み切り”すると差が出る。

---

## 境界モデル（request boundary＝“どこまでが1リクエストか”）
### 正常系（境界一致）
- フロントもバックも、同一の規則でメッセージ長を決定
- request↔responseの対応が崩れない
- フロントの検査（WAF/ACL/認証前処理）とバック処理が同じリクエストに対して行われる

### CL.TE（境界不一致）
- フロント：Content-Length を信じて固定長でボディを読み、残りは“次のリクエスト”として扱う
- バック：Transfer-Encoding: chunked を信じてチャンク終端までをボディとして扱い、直後のデータを“次のリクエスト”として扱う
- 重要：フロントが“ボディの一部”として送った（あるいは同一リクエスト内に含めた）データが、バックでは“次のリクエスト”になる可能性がある。
  - これが「フロントが見ていない追加リクエストがバックで処理される」核心。

---

## CL.TEの“成立根拠”を取る観測設計（薄くしない：ここが所見の芯）
Request Smugglingは「成功/失敗」がUIだけでは判断しづらい。成立根拠は“状態”として観測する。

### 観測A：バックで“想定外の追加リクエスト”が処理される兆候
- フロントログ上は 1リクエストなのに、バックログ上は 2リクエスト（または別パス）が出る
- バックログで、想定外のリクエスト行（path/method）やHostが現れる
- request_id（またはtrace id）がズレる／件数が合わない

### 観測B：request↔response対応の崩れ（Desync）
- 同一コネクション上で、送った順序と返るレスポンスの対応が乱れる
- “片方が先に返る/片方が無視される/後続が詰まる”などの不連続が出る

### 観測C：エラー層の変化（400/502/504等）とタイミング
- フロントが弾けばフロント由来の4xx
- バックでパース失敗や待ち状態になると、フロントが502/504を返す形になりやすい（製品依存）
- 入力の微差でエラー層・遅延が揺れるのは“境界解釈が揺れている”シグナル

### 観測D：コネクション汚染の兆候（現実寄り）
- ある試行の後、通常リクエストが不安定になる／一部だけタイムアウトする
- これは “不整合状態のコネクションがプールに戻った” 可能性を示す
- 重大性評価の根拠になり得る（再現は少数回で止める）

---

## 攻撃者視点での利用（現実寄せ：何を狙うか＝分岐点）
CL.TEの価値は「バックで追加リクエストが処理される」ことで、次の分岐点に届くと実害化する。

### 1) フロント依存の制御（WAF/ACL/認証ゲート）迂回
- フロントが path-based ACL を持つ（例：/admin はブロック）一方、バックは追加リクエストを処理してしまう構成
- “フロントが検査していないリクエスト”がバックへ届くこと自体が危険（統制破綻）

### 2) ルーティング/Host境界の破壊（マルチサービスで影響大）
- 同一フロント配下に複数アプリ（Host/pathルーティング）がある構成では、
  - 追加リクエストが別サービスへ到達し得る（境界の横断）
- ここは「資産境界」「信頼境界」に直結する（ASM/Reconの資産マップが効く）

### 3) キャッシュ/監査境界の破壊（検知・追跡性の破綻）
- 監査ログがフロント基準だと、“バックで処理された追加リクエスト”が追跡しづらい
- 事故時の原因究明不能は、運用上の重大リスク（修正要件に織り込む価値が高い）

### 4) 影響（DoS/劣化）としての利用
- 追加リクエスト/待ち状態により、バックコネクションが詰まる（ワーカ枯渇ではなく“コネクション枯渇”で出ることが多い）
- 少数リクエストでも発生し得るため、現実の攻撃（低ノイズ妨害）に繋がる

---

## 検証設計（安全第一：最小差分で“成立状態”を確定する）
> ここでは“再現のための詳細ペイロード”ではなく、検証を成立させるための要件と観測手順を記す。

### ステップ0：スタック仮説（CL/TEを誰がどう扱うか）
- 入口の層：CDN/WAF/LB/Reverse Proxy の有無
- フロント→バック：HTTP/1.1 keep-alive/pool の有無
- バック：chunked を解釈するHTTPサーバ/フレームワークか（多くは解釈する）
- 可能なら：フロント/バックのプロダクト名・バージョン・設定（実害評価が精密になる）

### ステップ1：同一コネクションで複数リクエストを扱える観測面を用意
- Request Smugglingは「同一コネクション上の境界」が核心
- 要件：
  - 同一接続上で連続送信できること
  - リクエストとレスポンスの対応を観測できること
  - タイムアウトや切断のタイミングを記録できること（pcap/ログ）

### ステップ2：曖昧な長さ決定を“拒否するか/通すか”の確認
- TEとCLが併記された入力を、最前段が拒否するならそこで終了（設計として強い）
- 通る場合、次へ進む（ただし少数回で止め、影響を出さない）

### ステップ3：成立根拠の確定（レスポンス対応＋ログ相関）
- UIの見え方ではなく、
  - フロントログ：何リクエストとして記録されたか
  - バックログ：何リクエスト処理したか
  - 相関キー：request_id/trace id/connection id
で確定する。
- “推測で所見化しない”が重要。ログ相関が取れない場合は、観測シグナル（時間差/エラー層/対応崩れ）を複数積み上げて状態として書く。

### ステップ4：実害の分岐へ（ただし契約/安全条件を満たすまで拡大しない）
- 目的を固定する：
  - 認可/ルーティング境界に届くか（最優先）
  - キャッシュ/監査破壊か（組織影響が大きい）
  - 劣化（DoS）か
- 他ユーザ影響が出る可能性があるため、隔離環境または明確な許可のある範囲でのみ深化する。

---

## 形（概念例：ペイロード列挙ではなく“何が曖昧か”だけを示す）
~~~~
# CL.TE の核は「長さ決定ルールの不一致」。
# - フロント：Content-Lengthを採用（固定長）
# - バック：Transfer-Encoding: chunkedを採用（チャンク終端）
# その結果、フロントが“ボディ扱い”した後続データが、
# バックでは“次のリクエスト”として解釈され得る。

# 観測したい状態：
# - バックログに“追加のリクエスト”が出る
# - request↔response対応が崩れる
# - エラー層/遅延が不連続に変化する
~~~~

---

## 結果の意味（状態で整理：診断所見へ直結）
### 状態S1：最前段で曖昧入力を拒否（健全）
- TE+CL 等をフロントが一貫して拒否
- 次の一手：H2→H1変換など別境界でも同じポリシーが適用されているか確認（別ファイルへ接続）

### 状態S2：境界揺れの兆候（desync疑い）
- 502/504、遅延の不連続、レスポンス対応の乱れが観測される
- 次の一手：
  - ログ相関が取れるなら最優先で確定（front=1, back=2 の形を証拠化）
  - 取れない場合は、観測シグナルを複数（A〜D）積み上げて“状態”として提示

### 状態S3：バックで追加リクエスト処理が確定（重大）
- “フロントが見ていないリクエスト”がバックで処理される
- 次の一手：高価値分岐（認可/ルーティング/監査/キャッシュ）へ接続し、影響半径を確定して修正要件へ落とす

---

## 防御（設計要件として：最短で事故を止める順）
### 1) 曖昧な長さ決定を排除（TE+CL等を拒否）
- 最前段（できればCDN/WAF/LB）で、TEとCLの併記や異常形式を拒否する
- “どの層で拒否するか”を責務分界として固定する（運用変更で揺れないように）

### 2) フロント/バックのHTTPパーサ前提を揃える
- TE/CLの優先順位、重複CL、chunkedの厳格性を統一
- プロダクト/バージョン差や設定差が原因になりやすいので、構成管理として扱う

### 3) コネクション管理（異常時にプールへ戻さない）
- パース異常・タイムアウト・上流切断のときは、そのバックコネクションを破棄
- keep-alive/poolは性能に必要だが、“安全に壊せる”設計が必須

### 4) 監査・相関（検知と再発防止）
- フロント/バックで request_id を受け渡し、件数不一致・順序崩れを検知可能にする
- フロントのログだけを真実にしない（境界破壊の前提を置く）

---

## 次に試すこと（仮説A/B：現実寄せの分岐）
### 仮説A：フロント依存の制御があり、追加リクエストが“高価値パス”へ届き得る
- 次の一手
  - 03_authz（認可）と接続し、フロントで守っていた境界（path/host/role）を特定
  - バックが処理した追加リクエストの到達先（サービス/パス/権限）をログで確定
  - 監査ログの不一致（frontとbackの処理差）を根拠として重大性を定義

### 仮説B：追加リクエストは確定できないが、desync兆候と劣化が出る
- 次の一手
  - 影響を「DoS（ワーカ）」ではなく「バックコネクション詰まり（pool枯渇）」としてモデル化
  - `05_input_18_http_request_smuggling_04_observable_signals` の枠で、遅延/切断/エラー層の相関を整理し、修正（拒否/コネクション破棄/タイムアウト）へ落とす

---

## 04_labs（手を動かす：CL.TEを“観測で理解”する設計）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/18_http_request_smuggling_cl_te_proxy_desync/`
- Lab設計要件（手順書ではなく設計）
  - 構成：
    - フロント：CL優先の扱いをする中継（等価挙動）
    - バック：TE(chunked)を解釈するHTTPサーバ
    - keep-alive/pool を有効化して、同一コネクション境界のズレを再現
  - 観測点：
    - pcap（クライアント→フロント、フロント→バック）
    - フロントログ（request_id、upstream_response_time、status）
    - バックログ（request line、parsed bytes、chunk decode、timeout）
  - 成功条件（学習目的）：
    - “バックで追加リクエストが成立する/しない”をログ相関で判定し、成立条件（設定差）を説明できる

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# CL.TE の検証で最重要なのは「同一コネクション」「レスポンス対応」「ログ相関」。
# - 送信：同一接続で連続リクエストを扱える手段
# - 観測：response対応の乱れ、遅延の不連続、エラー層、front/backログの件数不一致
# - 判断：どの層のパーサ前提がズレているか（拒否点・正規化点・プール破棄有無）
~~~~

---

## 深掘りリンク（最大8）
- `05_input_18_http_request_smuggling_01_te_cl（proxy_desync）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
