## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 満たす/破れる点（この技術で何が起きるか）
    - 破れる：入力により正規表現の評価コストが非線形（指数/多項式）に増大し、CPU/スレッド/ワーカが枯渇して可用性が崩れる（DoS）。さらに、レート制限やタイムアウトが「正規表現の前」にないと、少数リクエストで劣化が成立する。
    - 満たす：線形時間の正規表現（RE2系）への置換、バックトラッキング回避（パターン設計・原子化/所有欲量指定等）、入力長・回数制限、評価タイムアウト、プリコンパイル、危険パターンの静的検出、重要経路からの正規表現排除。
- WSTG
  - 該当テスト観点（どの観測・検証に対応するか）
    - 「入力検証」だけではなく、正規表現を使う箇所（検索、フィルタ、ルーティング、WAF的検査、ログ整形、テンプレ/マークアップ変換）で、入力長を増やしたときの応答時間の増加を観測し、コスト境界を確定する。
- PTES
  - 位置づけ
    - 脆弱性分析：入力→正規表現評価→資源枯渇の境界モデル化（どの入力がどのregexへ到達するか）。
    - 侵害評価：少数リクエストで再現できるか（ワーカ枯渇、キュー滞留、タイムアウト連鎖）を観測で固める。
- MITRE ATT&CK
  - 目的（攻撃者視点）
    - Impact：サービス妨害（DoS）。公開アプリ（T1190）から、少数のリクエストで劣化させる“低ノイズ型”の運用妨害に接続する。

---

## タイトル
ReDoS（Regex DoS）：正規表現を「検証」ではなく「コスト境界」として扱い、少数リクエストでの劣化成立を詰める

---

## 目的（このファイルで到達する状態）
- 次を、観測に基づく“成立根拠”として説明できる。
  1) どの入力がどの正規表現に到達しているか（入口・経路）
  2) その正規表現が「線形」か「バックトラッキングで非線形」か（エンジン差も含む）
  3) 入力長に対して応答時間（またはCPU）がどのように増えるか（コスト境界）
  4) 実害（ワーカ枯渇、タイムアウト連鎖、キュー滞留、監視アラート）としてどう現れるか
  5) 修正を「パターン修正」「エンジン置換」「ガード（制限/タイムアウト）」に分けて提案できる

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：ReDoS（正規表現の評価コストに起因するDoS）
  - バックトラッキング爆発（catastrophic backtracking）
  - 入力長・構造による多項式/指数的な探索増大
  - 正規表現の前後にあるガード（入力制限、タイムアウト、レート制限、キュー制御）
- 扱わない（ただし接続は書く）
  - “巨大レスポンス生成”や“DBの重い検索”など、正規表現以外の性能劣化
  - WAF回避や特定のペイロード列挙（本プロジェクトは境界モデルと成立根拠を優先）

---

## 境界モデル（ReDoSは「入力→評価→資源枯渇」の一本線）
### 最小データフロー
入力（query/body/path/header）  
→ 正規表現評価（match/search/replace/split）  
→ CPU時間・GC・ヒープ・スレッド占有  
→ ワーカ枯渇 / リクエスト遅延 / タイムアウト / 連鎖障害（リトライ増）  
→ 影響（可用性低下、SLO逸脱、監視アラート、フェイルオーバ）

### 境界として重要な3点
- どこで評価されるか：入口（ログイン/検索/フィルタ/ルーティング/サニタイズ）と到達条件
- どのエンジンか：バックトラッキング型か、線形時間エンジンか
- ガードがどこにあるか：正規表現評価の前に抑えられているか（ここが実害の差になる）

---

## 正規表現エンジンの差分（成立根拠の中心）
ReDoSは「正規表現」一般ではなく、主に **バックトラッキング型エンジン**で問題化する。
- バックトラッキング型（代表）
  - 多くの言語の標準regex（例：Java/.NET/Python/JS/PHP PCRE系）は、機能が強い一方で、特定パターンで探索が爆発し得る。
- 線形時間（代表）
  - RE2系のように、危険な構文（後方参照等）をサポートしない代わりに、評価を線形に抑える思想の実装がある。

診断観点では「このサービスの実装がどちらに近いか」を推定し、成立可否の判断に使う。

---

## 危険パターンの構造（“なぜ爆発するか”を形で覚える）
> ここはペイロード列挙ではなく、設計レビューと検証のための“型”の理解。

### 1) 入れ子の量指定（nested quantifiers）
- 構造：`(…+)+` / `(…*)+` / `(…+)*` のように、量指定が階層になる
- なぜ危険か
  - 1文字をどの繰り返しで消費するかの割当が多数存在し、失敗時に探索が爆発する（特に末尾で不一致になると顕在化）

### 2) オーバーラップする選択肢（overlapping alternation）
- 構造：`(a|aa)+` のように、同じ接頭辞を持つ選択肢が並ぶ
- なぜ危険か
  - どちらの分岐で進んだかの組合せが増え、失敗時に戻り探索が増える

### 3) アンカー不在＋貪欲（unanchored + greedy）
- 構造：`.*` や `.+` を含むパターンが、行頭/行末に固定されず検索として動く
- なぜ危険か
  - “どこから一致を開始するか”が増える（検索コスト）＋貪欲が戻る（バックトラック）

### 4) lookaround / backreference が絡む（機能が強いほど危険幅が広い）
- lookahead/lookbehind は、組合せ探索を増やしやすい
- backreference は理論上NFA/DFAの安全枠を外し、評価コストが跳ねやすい
- 結論：機能が強いregexほど、レビューとガードが必須

---

## ReDoSが起きやすい“実務の入口”（発見を速くする地図）
優先度が高いのは「外部入力 × 高頻度 × 同期処理 × 共有ワーカ」の組み合わせ。

### A. ログイン/登録/パスワードリセット周り（バリデーション）
- email/電話番号/ユーザ名の検証に複雑regexが入る
- 成立すると、レート制限があっても“正規表現評価が先”なら無意味になることがある

### B. 検索/フィルタ/正規表現検索機能
- “regex検索”を許している場合は当然高リスク
- 許していなくても、内部で“入力をregex化”して曖昧一致しているケースがある（部分一致/ハイライト/サジェスト）

### C. ルーティング/リバースプロキシ/ルールエンジン
- パスのマッチ、rewrite、ACL判定などがregexで行われる
- ここが遅いと全エンドポイントに影響が波及する（影響半径が大きい）

### D. サニタイズ/正規化（replace/split）
- HTML/Markdown/テンプレ系の前処理
- 1リクエスト内で複数回regexが走ると、わずかな非線形が累積して致命的になる

---

## 観測ポイント（薄くしない：ReDoSは“時間”が証拠）
### 1) 応答時間のスケーリング（最重要）
- 入力長を段階的に増やしたとき、応答時間がどう増えるか
  - 線形：概ね比例（許容範囲）
  - 非線形：途中から急増（境界がある）
- 重要：ネットワーク揺らぎを吸収するため、同条件で複数回測り中央値を見る

### 2) サーバ側の兆候（可能なら依頼して取る）
~~~~
request_id
endpoint / code path
regex_name（どの検証/検索/ルールか）
engine/runtime（言語、ランタイム、ライブラリ）
input_length / normalized_length
regex_eval_time（可能なら）
worker_id / thread_id
queue_wait_time
timeout_type（app/proxy/lb）
cpu_usage / load（同時刻）
~~~~

### 3) タイムアウトの位置
- どこで落ちるか（アプリ、プロキシ、LB、クライアント）
- 位置がわかると、「どの層でガードすべきか」が決まる

---

## 検証設計（安全に“成立根拠”を固める手順）
> 破壊的に落とすのではなく、最小の増分で非線形を観測する。

### ステップ1：対象regexの到達点を特定する
- 入口：入力項目（email/検索語/path/ヘッダ）
- 出口：エラーメッセージや結果（バリデーション失敗/成功、検索結果）
- “どのregexが走ったか”が不明でも、少なくとも「この入力で正規表現が評価されている」状態を作る

### ステップ2：入力長の段階試験（指数探索を避ける）
- いきなり長文を投げない
- 短い入力から、一定の倍率で長さを増やして応答時間を記録
- 急増が見えた時点で止め、そこを中心に微調整して境界を確定する

### ステップ3：失敗側で観測する（成功側より見えやすい）
- バックトラッキング爆発は「最後に不一致」になると顕在化しやすい
- したがって、バリデーションなら“失敗する入力”で時間が伸びるかを観測する方が根拠を作りやすい

### ステップ4：同時実行は最小限（実害化させない）
- 単発で非線形が見えたら、並列試験で落とす方向には進まない
- 実務上は「少数リクエストで遅延が発生する根拠」＋「ガード欠如」で十分に重大所見になり得る

---

## 結果の意味（診断としての言語化：ここが薄いと報告が弱い）
### 状態S1：線形に近い（問題なし、または低リスク）
- 入力長に対して応答が概ね比例、明確な閾値で拒否（サイズ制限）もある
- 次の一手：レビューで危険構文（入れ子量指定、オーバーラップ選択）を避けているかだけ確認

### 状態S2：非線形の兆候（高リスク：修正対象）
- ある長さを超えると応答が急増、タイムアウトに近づく
- 次の一手：
  - そのregexが“高頻度経路”か（ログイン/検索/ルーティング）を確定
  - ガード（入力長、タイムアウト、レート制限）がregex評価の前にあるかを確認
  - 修正方針（パターン改善/エンジン置換/ガード追加）を選ぶ

### 状態S3：単発でタイムアウト（極めて高リスク）
- 少数リクエストでプロキシ/アプリのタイムアウトに到達
- 次の一手：
  - 影響半径（同一ワーカ共有、全APIに波及、キュー滞留）を観測で示す
  - “再現の最小条件”で止め、修正提案へ直行する（追加負荷試験は不要）

---

## 攻撃者視点での利用（現実寄り）
- 目的は「完全停止」より「SLO逸脱」「一部機能の常時劣化」「運用妨害」が多い
- 少数リクエストで遅延が起きると、
  - オートスケール誘発 → コスト増
  - リトライ増 → 二次的な負荷増
  - 監視ノイズ増 → 対応リソース枯渇
という現実的な被害に繋がる

---

## 防御（実装を変える順序：最短で効くものから）
### 1) ガードを“正規表現の前”に置く（即効性）
- 入力長上限（項目ごとに妥当値）
- 早期拒否（明らかに不要な文字種/長さは弾く）
- 評価タイムアウト（言語/フレームワークで可能なら必須）
- レート制限（ただしregexより前に評価されることが条件）

### 2) パターンを“線形に寄せる”（根治）
- 入れ子量指定を避ける（構造の単純化）
- アンカーで検索範囲を固定する（必要な場合のみ）
- オーバーラップする選択肢を解消する（共通部分を外に出す、順序を見直す）
- 可能なら、正規表現ではなくパーサ/状態機械に置換する（特に複雑な形式）

### 3) エンジンを変える（設計レベル）
- 線形時間エンジンの採用（機能制約とのトレードオフを明示）
- “ユーザ入力をregexとして受ける”機能は、原則として隔離（別ワーカ/別制限）する

### 4) 観測と防止を運用へ組み込む
- regex評価時間の計測（可能なら）
- 入力長分布の監視
- タイムアウトの原因分類（regex起因かを切り分けられるログ）

---

## 次に試すこと（仮説A/B：分岐）
### 仮説A：バリデーションregexが原因
- 次の一手
  - その項目の最大長・許容文字種・正規化（trim/Unicode正規化）を設計として固定
  - “失敗側”で遅延が出るなら、失敗を早期に返せる構造へ置換（regexの順序・分割）

### 仮説B：検索/フィルタ/ルーティングのregexが原因
- 次の一手
  - 影響半径が大きいので優先度最大（ルーティングは全体波及）
  - 対象regexの適用範囲を狭める（先頭一致、固定接頭辞、前処理で候補削減）
  - 同期経路から外す（キュー/非同期）か、隔離ワーカへ（ただしUXとの調整が必要）

### 仮説C：原因がregexか不明（遅いが確定できない）
- 次の一手
  - サーバログで「どの検証/処理に時間がかかったか」を取りに行く
  - 入口を変えても遅いか（regex以外の可能性）を切り分ける
  - 依存ライブラリ（URL/HTML/Markdown/テンプレ）にregexが内在する可能性を検討し、呼び出し点を特定する

---

## 04_labs での再現（理解用：設計として書く）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/15_regex_dos_cost_boundary/`
- Lab設計要件
  - 同一入力に対し、(1) バックトラッキング型、(2) 線形型、(3) ガードあり/なし、を比較して
    - 応答時間のスケーリング
    - タイムアウト位置
    - ワーカ枯渇の兆候（軽い範囲で）
    を観測できる構成にする
  - 手順書ではなく、観測点（ログ/メトリクス/閾値）を明示する

---

## コマンド/例（例示は最小限：概念のみ）
~~~~
# ReDoSは「入力長を増やしたときの時間増加」を見る。
# - 短い入力 → 少し長い入力 → 境界が見えたらそこで停止
# - 同一条件で複数回測って中央値を見る
# - タイムアウト位置（アプリ/プロキシ/LB）を必ず記録する
~~~~

---

## 深掘りリンク（最大8）
- `05_input_14_prototype_pollution_01_sources（merge_parse）.md`
- `05_input_14_prototype_pollution_02_sinks（authz_template_rce）.md`
- `05_input_06_xss_01_反射_境界モデル.md`
- `05_input_06_xss_03_DOM_境界モデル.md`
- `04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
