## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - この技術で満たす/破れる点：
    - アップロードは「入力→保存」ではなく、**入力→（分類）→（解釈）→（処理）→保存**の連鎖で事故る。検査（validation）は、その連鎖の“入口での受理可否”を決める最重要コントロール。
    - 破れる典型は「クライアント申告（Content-Type/拡張子/ファイル名）を信じる」「検査の層が1つだけ」「検査と実処理の“解釈器”が違う（differential parsing）」。
    - 強い設計は、(1) allowlist（業務要件に基づく許可集合）+(2) サーバ側の内容検査（magic/構文）+(3) 正規化（再エンコード/再レンダリング）+(4) 例外時の安全な失敗（拒否・隔離・監査ログ）をセットにする。
- WSTG
  - 該当テスト観点：
    - 「想定外ファイルタイプのアップロード」および「悪性ファイルのアップロード」を対象に、許可/拒否の挙動、処理パス、例外時の安全性を観測する（Business Logic Testing の該当項）。  
    - 重要なのは “アップロードできた/できない” ではなく、**どの検査が働いているか（差分）** と **受理後に何が起きるか（処理連鎖）** の切り分け。
- PTES
  - 位置づけ：
    - Information Gathering：アップロード機能の棚卸し（画面/内部API/バッチ/連携/Webhook添付/インポート/モバイル）と、受理後の処理（サムネ/AV/変換/OCR/プレビュー/ワークフロー）を列挙。
    - Vulnerability Analysis：検査ロジックを「申告値」「拡張子」「マジック」「構文パース」「再生成」のどれでやっているかモデル化。
    - Exploitation：ゴールは“RCE”固定ではない。まず **受理条件の突破（mime/magic/polyglot）** を確定し、次に **実行連鎖（別ファイルで扱う）** に接続する。
    - Reporting：対策は「受理可否（本ファイル）」「保存先と到達性」「実行連鎖」の3点セットで提案する。
- MITRE ATT&CK
  - 初期侵入：T1190（公開アプリの脆弱性悪用）
  - 実行/永続化/収集への接続（成立条件つき）：
    - Upload経路で“危険ファイルが受理される”と、後段の処理器（画像/Office/PDF/アーカイブ/テンプレ等）で別の脆弱性を踏める。つまり検査突破は **後段攻撃面へのゲート突破**。
    - 収集（Collection）：アップロード領域が配信される/共有されると、利用者端末側（XSS/CSRF/マクロ等）に飛び火する。

---

## タイトル
file_upload_検査：MIME・マジックバイト・ポリグロットで「受理の境界」を崩す差分を確定する

---

## 目的（このファイルで到達する状態）
- アップロード検査を「拡張子を見ている」程度で終わらせず、次を説明できる状態になる：
  1) **誰が何を“型”と判断しているか**（ブラウザ/プロキシ/WAF/アプリ/ライブラリ/AV/ストレージ/CDN）
  2) **判定手段の層**（申告MIME・拡張子・magic・構文パース・再生成）
  3) **差分＝成立根拠**（入力を少し変えたら通る/落ちる → どの層が効いているか）
- 報告として次を言い切れる：
  - “クライアント申告を信じているため回避可能”
  - “magicチェックだけで、ポリグロット/解釈差分に弱い”
  - “再生成（decode→encode）しているため、この系統の回避は困難”
  - “検査は強いが、実行連鎖（別ファイル）で危険が残る” など、原因を境界で分解して提示できる。

---

## 扱う範囲と分割（このファイルの守備範囲）
- 本ファイル：**受理可否（validation）** に集中
  - MIME/Content-Type、拡張子、マジックバイト、ファイル構文の検証、ポリグロット、メタデータ、サイズ/寸法、AV/サニタイズの位置づけ
- 別ファイルへ接続（本ファイルでは“入口”まで）：
  - `05_input_12_file_upload_02_storage_path（bucket_acl_traversal）.md`：保存先・到達性・ACL・パス設計
  - `05_input_12_file_upload_03_execution_chain（preview_processor_rce）.md`：プレビュー/変換/外部連携が作る実行連鎖
  - `05_input_11_path_traversal_03_archive（zip_slip）.md`：アーカイブ展開（受理後の処理）でのFS逸脱

---

## 境界モデル（どこで“型”が決まるか：現実のデータフロー）
### 1) 入力の実体（multipartの二重構造）
- HTTPヘッダ：`Content-Type: multipart/form-data; boundary=...`
- パートごと：
  - `Content-Disposition: form-data; name="file"; filename="..."`（ファイル名は“申告”）
  - `Content-Type: image/jpeg`（パートのMIMEも“申告”）
  - ボディ：バイト列（ここだけが“実体”）

結論：**申告（ヘッダ）と実体（バイト列）を分離して考える**。申告を信じる設計は最短で崩れる。

### 2) “型判定者”が複数いる（differential parsingの温床）
- ブラウザ：表示時にMIME sniffingが起き得る（レスポンス側だが、アップロード後の配信で再燃）
- プロキシ/WAF：MIMEや拡張子で遮断することがある（ただし回避も起きる）
- アプリ：自前判定（拡張子、Content-Type、magic、ライブラリで判定）
- ストレージ/CDN：Content-Typeの付与・再付与、拡張子推定
- 後段処理器：画像変換、PDFレンダラ、Office変換、AV、OCR

攻撃者は「最も弱い判定者」を探し、そこを通して「最も危険な処理器」に届かせる。

---

## 検査の層（強度は“多層 + 一貫性”で決まる）
> OWASPは「Content-Typeヘッダを信頼するな」「許可拡張子のallowlist」などを明確に推奨している。  
（＝クライアント申告と拡張子単体は弱い、という前提）

### 層0：クライアント申告（最弱）
- 例：パートの `Content-Type` をそのまま信用
- 結果：申告は任意に操作できるため、ここだけの検査は“検査していない”に等しい。

### 層1：拡張子（弱い／ただし業務要件の表現としては有用）
- allowlist（例：jpg/png/pdf）自体は正しい方向
- ただし、拡張子は “解釈器（サーバ/アプリ/ライブラリ）” によって意味が変わるため、単体だと回避が残る。
- 本質：拡張子は「許可集合のUI」にはなるが、「実体保証」にはならない。

### 層2：マジックバイト（中程度）
- ファイル先頭のシグネチャ（magic bytes）で判定する方式
- 強み：申告ヘッダよりはるかに強い
- しかし、**ポリグロット（複数形式として成立）** や **構文としては壊れているが先頭だけ偽装** に弱い。
- 重要：magicは “入口フィルタ” であり、最終保証にはならない。

### 層3：構文パース（強い）
- 画像ならデコーダで読み込めるか（デコード成功が最低条件）
- PDF/Officeならパーサで妥当性検証・危険要素の排除
- 注意：パーサ自体が攻撃面（後段RCE）になり得るため、**検査に使うライブラリの脆弱性管理**も含めて設計する。

### 層4：再生成（最強クラス：実体を作り直す）
- 画像：decode → encode（メタデータ除去、ピクセルデータ再生成）
- ドキュメント：サニタイズ/再レンダリング（CDR的アプローチ）
- 目的：入力の“余剰構造”を落として、攻撃者が仕込んだ二重解釈を壊す

---

## ポリグロット（polyglot）の位置づけ：なぜmagic/パースを抜けるのか
- ポリグロットは「複数の形式として同時に成立し得る」ファイルで、型ベースの防御を混乱させる。
- 典型的には「検査器Aは画像として合格、処理器Bは別形式として解釈」などが起きる。
- 重要：ここで言う“成立”は「アプリの判定がOKを出す」ではなく、「後段の解釈器が意味を与える」こと。

本ファイルの観点では、ポリグロットは **検査突破の根拠（差分）** として扱う：
- magicが合格するのに、別解釈が成立する → 層2の限界
- decode/encodeで再生成すると成立しない → 層4が効いている根拠

---

## 受理判断（allowlist設計）：業務要件を“最小集合”に落とす
- 「全部許可」は運用が楽に見えるが、攻撃面の爆発そのもの。
- まず決める：
  - 何のためのアップロードか（本人確認、プロフィール、添付、エクスポート取り込み、テンプレ導入…）
  - 誰がアップロードできるか（一般/管理者/内部バッチ）
  - どこで利用されるか（公開配信、メール添付、社内共有、変換処理）

ここから、許可タイプを“必要最小限”にする。
- 例：画像アップロードなら “画像のみ”、ドキュメント提出なら “PDFのみ” など。
- 許可集合を狭めることが、最も強い防御（検査の難易度を下げる）。

---

## 観測ポイント（薄い診断にならないためのログ・挙動）
### 1) 入口の観測（リクエスト）
- multipartの各パートで：
  - filename（申告）
  - パートContent-Type（申告）
  - 実体サイズ
- アプリ側が取得している値：
  - “拡張子はどこから取っているか”（filename由来か、別フィールドか）
  - “MIMEはどこから取っているか”（ヘッダか、判定結果か）

### 2) 判定の観測（サーバ側）
最低限、次がログで追えると「差分＝成立根拠」が固まる：
- allowed_extensions 判定結果（hit/miss）
- declared_mime（申告）
- detected_mime（magic/ライブラリ判定）
- parser_result（decode成功/失敗）
- sanitize_result（再生成の有無）
- reject_reason（rule_id）

~~~~
# ログ最小フィールド（再現性の核）
request_id
user_id / role
upload_purpose
original_filename
declared_part_mime
detected_mime
extension_decision
magic_decision
parse_decision
sanitize_decision
final_decision (accept|reject|quarantine)
reject_reason (rule_id)
~~~~

---

## 検証設計（意味→判断→次の一手：差分セットで特定する）
> 重要：大量の“トリック集”より、少数の差分で「どの層が効いているか」を確定する。

### 差分セットA：申告MIMEの信頼有無（層0の切り分け）
- 変えるのは **パートContent-Typeだけ**
- 結果が変わるなら：
  - 層0依存（申告信頼） or WAF/ミドルの粗い判定の可能性
- 次の一手：
  - 層2（magic）や層3（パース）が存在するか、追加差分で確認

### 差分セットB：拡張子判定の強度（層1の切り分け）
- 変えるのは **filename（拡張子表現）だけ**
- 結果が変わるなら：
  - 拡張子依存の可能性が高い（層1中心）
- 次の一手：
  - 受理後の保存方式（別ファイル）で“到達性”が残っていないかに接続

### 差分セットC：magic判定の有無（層2の切り分け）
- 変えるのは **先頭バイト列（シグネチャ相当）**
- 結果が変わるなら：
  - magicベースの検査がある根拠
- 次の一手：
  - ポリグロットや構文パース（層3/4）があるかを差分で見る

### 差分セットD：構文パース/再生成（層3/4）の有無
- 画像なら：
  - “デコードできるが余剰構造を持つ”ケースで、再生成されるか／拒否されるかを観測
- 結果で判断：
  - decode/encodeしている（層4）なら、ポリグロットの多くが潰れる可能性が高い
  - デコード確認だけ（層3）なら、二重解釈（ポリグロット/後段処理差）に余地が残る

---

## 現実の攻撃導線（攻撃寄り：ただし条件分解で評価する）
アップロード検査突破が意味を持つのは、次の“どれか”が成立するとき。

1) 公開配信される（ユーザ/管理者がブラウザで見る）
- MIME sniffingや誤ったContent-Typeで、クライアント側攻撃（XSS等）に波及し得る
- 対策：配信のContent-Type整合、`nosniff` 等（これは配信側設計だが、検査とセットで考える）

2) サーバ側で処理される（変換・プレビュー・解析）
- 検査が弱いと、危険形式が処理器に到達して攻撃面が増える（後段は `execution_chain` で深掘り）

3) 共有・転送される（メール添付・外部連携・SaaS保存）
- “受理できた”だけで第三者へ拡散し、端末側リスクになるケースがある（業務影響が大きい）

結論：検査は「RCE防止」だけでなく、**処理連鎖に危険形式を入れないゲート**として評価する。

---

## 防御（設計としての優先順位：validationの責務）
### 1) 許可集合（allowlist）を業務要件で最小化
- 何でも許す設計をやめる（検査が難しくなるだけ）
- “できればPDFだけ”のように、形式を絞るほど検査は強くなる

### 2) 申告値（Content-Type/filename）を“参考情報”に落とす
- 申告はログ・UX（エラーメッセージ）には使えるが、受理可否の根拠にしない

### 3) サーバ側判定は「magic→構文パース→再生成」を段階化
- magic：粗い入口フィルタ
- 構文パース：妥当性の最低保証
- 再生成：余剰構造を落とす最強手
- ただし再生成はコストがあるため、対象（画像/特定doc）を絞って適用する

### 4) 例外時の安全な失敗（拒否・隔離・監査）
- “拒否できない業務”があるなら、隔離（quarantine）と監査ログが最低ライン
- WSTGの観点でも、悪性/想定外ファイルの扱いが安全かを確認することが強調される

---

## 次に試すこと（仮説A/Bで分岐）
### 仮説A：検査が多層で、再生成までしている（突破は困難）
- 観測：
  - declared_mimeを変えても結果が変わらない
  - 拡張子の揺れでも結果が変わらない
  - detected_mime / parser_result / sanitize_result がログに残っている
- 次の一手：
  - 保存先/到達性（`storage_path`）へ移り、公開配信・ACL・署名URLの境界を評価
  - 後段処理（`execution_chain`）で、処理器の攻撃面（変換・AV・OCR）を評価

### 仮説B：検査が単層（申告 or 拡張子 or magicのみ）で、差分で回避できる
- 観測：
  - パートContent-Typeやfilename変更だけで受理結果が変わる
  - magicは見ていない、または先頭だけ見ている
  - 再生成がない（sanitize_resultが無い/常にfalse）
- 次の一手：
  - 受理できた形式が “どの処理器に流れるか” を棚卸しし、最短で影響の出る連鎖に接続
  - 「公開配信されるか」「変換されるか」「共有されるか」を優先順位付けして、現実の被害に近い評価へ寄せる

---

## 手を動かす検証（Labs：手順ではなく設計）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/12_file_upload_validation_mime_magic_polyglot/`
- 設計要件（観測→解釈→利用）
  - 実装パターンを4つ作り、差分で“どの層が効くか”を体感できること：
    1) 申告MIME信頼（弱い）
    2) 拡張子allowlistのみ（弱い）
    3) magic判定（中）
    4) decode/encode再生成（強い）
  - ログに `declared_mime / detected_mime / parse / sanitize / decision / rule_id` を残す
  - 受理後に「配信」「変換」を別々のルートで用意し、validationの役割と限界を観測できるようにする

---

## 深掘りリンク（最大8）
- `05_input_12_file_upload_02_storage_path（bucket_acl_traversal）.md`
- `05_input_12_file_upload_03_execution_chain（preview_processor_rce）.md`
- `05_input_11_path_traversal_02_join_root（allowlist_basedir）.md`
- `05_input_11_path_traversal_03_archive（zip_slip）.md`
- `05_input_16_csv_formula_injection（export境界）.md`
- `06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
- `04_api_08_file_export_エクスポート境界（CSV_PDF）.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`

---

## 参考（一次情報：短く）
- OWASP Cheat Sheet Series: File Upload Cheat Sheet
- PortSwigger Web Security Academy: File uploads
- OWASP WSTG: Test Upload of Unexpected File Types / Test Upload of Malicious Files
- CWE-434: Unrestricted Upload of File with Dangerous Type
