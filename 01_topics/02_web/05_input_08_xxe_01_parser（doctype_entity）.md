## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 満たす/破れる点：XML入力を扱う境界で「DTD/外部実体/実体展開/外部参照（URI解決）」を無効化し、サーバが “XMLの仕様機能” を通じて外部資源（FS/HTTP等）へ到達しないことを保証する。単に入力バリデーションではなく「パーサ設定＝実行境界の制御」として扱う。
- WSTG
  - XXEは Input Validation Testing の一部として扱い、(1) XMLパース地点の発見、(2) DOCTYPE/ENTITY が受理されるか、(3) 外部実体の解決・展開が起きるか、(4) 例外/応答差分/外向き通信などの観測で成立根拠を確定する。
- PTES
  - Vulnerability Analysis：XMLを扱う経路（API/ファイル/サードパーティ処理）を列挙し、パーサの種類・設定・実体解決器（resolver）の到達性を境界としてモデル化。
  - Exploitation：成立根拠は「DOCTYPE/ENTITY を解釈する」「外部実体を解決する」「展開によりデータが混入する」など、パーサ挙動の差分で証拠化（次ファイルで OOB/Blind に拡張）。
  - Reporting：アプリ不備ではなく“安全でない既定値＋設定漏れ”として是正案（設定と設計）に落とす。
- MITRE ATT&CK
  - 位置づけ：外部実体の解決は、攻撃者にとって内部資源探索（Discovery）や内部サービス到達（SSRF連鎖）を可能にする前段になり得る。技術ユニットとしては「入力→パーサ→外部参照」の実行境界を閉じる前提。

---

## タイトル
XXE（Parser / DOCTYPE / Entity）境界モデル：XMLの“仕様機能”が実行境界になる瞬間

## 目的（この技術で到達する状態）
- XXEを「XMLに悪い文字が入る」ではなく、**パーサが持つ仕様機能（DTD/ENTITY/外部参照/展開）が“実行”として働く境界**だと説明できる。
- 実務判断として、次を即断できる
  - どの入力経路が XML パースに到達しているか（API/ファイル/埋め込みフォーマット）
  - そこで使われるパーサが「DOCTYPEを許す／外部実体を解決する／実体を展開する」状態か
  - “外部実体の解決”が内部到達性（SSRF/ファイル参照/DoS）に繋がる根拠を、観測で確定できる
- 次ファイル（Blind/OOB、to SSRF）へ地続きで繋げるために、まず **Parserの成立条件（doctype/entity）** を固定する。

---

## 前提（XXEを“入力バグ”ではなく“実行境界”として扱う）
- XXEは、アプリがXMLを解析する際に、DTD/外部実体参照（External Entity）を“機能として”有効にしていると成立する。
- 重要な切り分け
  - 「DOCTYPE/DTD を解釈する」＝ 文法宣言を受理する
  - 「外部実体を解決（resolve）する」＝ URI/ファイル等へアクセスして内容を取りに行く
  - 「実体を展開（expand）する」＝ 取り込んだ内容を文書ツリーに混入させる／評価する
- 実務で事故りやすいのは「外部実体は無効にしたつもり」でも、
  - DTDが生きている（DoSや内部参照が残る）
  - 一部のパーサ／経路だけ設定が漏れている（例：アップロード処理・変換処理の別ライブラリ）
  - “外部参照をする別機能”（XInclude、テンプレ変換、SVG等）で別ルートが残る、など。

---

## 境界モデル（どこからが危険な“実行”か）
### 1) 入力境界：XMLが入ってくる“現実の経路”
- API
  - `Content-Type: application/xml` / `text/xml` の明示
  - SOAP / XML-RPC / 古い連携API（今も残りやすい）
- ファイル
  - 直球：`.xml`
  - 埋め込み：`.svg`（XML）、Office（docx/xlsx/pptxの中身はXML）、一部のePub、設定ファイル、RSS/Atom など
- 生成・変換
  - “受け取りはJSON”でも、バックエンドでXML変換（テンプレ/マッピング）しているケースがある

=> ここでは「XMLっぽい場所」ではなく、**“XMLパースが発生する場所”を資産境界として特定**する。

### 2) パーサ境界：DOCTYPE/DTD を受理するか
- DOCTYPE（DTD）を受理できる状態は、入力の中に「文法宣言（＝実体宣言）」を持ち込める状態。
- DTDが有効だと、以下が開く
  - ENTITY宣言（一般実体/パラメータ実体）
  - 実体展開（DoSの入口）
  - 外部参照（外部サブセット、SYSTEM識別子等）の入口

### 3) 実体境界：外部実体の「解決」と「展開」を分離して考える
- 解決（resolve）
  - OSファイル、HTTP(S)、その他URIスキーム（ライブラリ依存）へアクセスし得る
  - ここが「到達性（SSRF/FS）」の境界
- 展開（expand）
  - 解決した内容が文書として混入する／ログやレスポンスに出る／後段処理に渡る
  - ここが「データ流出」「二次解釈（テンプレ等）」の境界
- 重要：**“解決できるが展開しない”** でも、Blind/OOB で成立し得る（次ファイルで扱う）。

### 4) リソース境界：実体展開DoS（Billion Laughs等）
- DTD/ENTITY を許すだけで、外部参照が無くても“展開爆発”でCPU/メモリを消費し得る。
- つまり「外部実体だけ無効」では DoS 経路が残る可能性がある（パーサ設定の粒度が重要）。

---

## 結果の意味（状態としての判定）
### 状態A：安全側（推奨）
- DOCTYPE/DTD が拒否される（＝文法宣言を持ち込めない）
- 外部一般実体/外部パラメータ実体が無効
- XInclude等の外部取り込み機能も無効、または到達先が厳格に制限
- 変換/検証/プレビュー等の別経路でも同じ設定が適用されている（“一箇所だけ対策”ではない）

### 状態B：XXE成立の前提が揃う（危険）
- DOCTYPEが受理される、かつ
  - 外部実体が解決される、または
  - 実体展開DoSが成立する、または
  - 一部経路で設定が漏れている（アップロード→変換で別パーサ）
- この状態は “入力→実行境界” が開いている、と評価する。

### 状態C：一見安全に見えるが、境界が部分的に残る（実務で多い）
- 外部一般実体だけ無効で、DTD自体は有効（DoSが残る）
- メインAPIは安全だが、バッチ/管理UI/ファイル処理で別ライブラリが使われ設定漏れ
- 例外処理/ログ出力により、内部情報が“差分”として観測できてしまう（成立根拠の補助になる）

---

## 攻撃者視点での利用（現実寄り：まず何を探すか）
- “XMLを受け取る面”を探す（表のUIではなく、連携・アップロード・変換・プレビューに寄る）
- 成立根拠としてまず狙うのは「DOCTYPEを受理するか」
  - 受理される＝攻撃面として優先度が上がる（外部参照/OOB/DoSへ伸びる）
- 次に「外部参照を解決するか」は、環境依存が大きいので観測（DNS/HTTP egress）で確定する（次ファイルで深掘り）

---

## 観測ポイント（最小差分セット）
### 1) “XMLパースしている”証拠を取る
- レスポンスヘッダ/ボディ、エラーメッセージ、ログ（可能なら）で、XMLパーサ由来の例外が出るか
- 同一入力で
  - XMLが壊れている場合のエラー
  - XMLが通る場合の挙動
  の差分を作り、パース地点を確定する

### 2) DOCTYPEの受理可否（このファイルの主題）
- DOCTYPEを含む入力を与え、次を観測する
  - 明示的に拒否するエラー（“DOCTYPE禁止/DTD無効”系）
  - 何も言わず通る（= DTDが生きている可能性）
- “通った”だけでは外部実体解決まで確定しないが、**危険側の前提が揃った**と判断できる。

### 3) 実体展開（DoS方向）の兆候
- 解析時間・レスポンス遅延・CPU高騰（ラボで再現しやすい）
- ここは本番で過負荷を与えないように、必ず“影響を制御した検証”に落とす（labs連動）

### 4) 例外パスの探索（設定漏れを見つける）
- 同じXMLでも経路が違うとパーサが違う
  - 直接API送信
  - ファイルアップロード→サムネイル/プレビュー→変換
  - インポート/エクスポート
- “一箇所で安全”を証明しても、全体の安全にはならない（境界は経路ごとに存在する）

---

## 次に試すこと（仮説A/B：条件で次の手が変わる）
### 仮説A：DOCTYPEが拒否される（安全側に見える）
- 次の一手
  1) 同一アプリ内で別経路（アップロード/変換/管理機能）を探索し、そこでも同様に拒否されるか確認
  2) XMLでなく “XML内包フォーマット”（SVG/Office等）が処理される経路がないか（次の入力経路探索）
  3) 例外処理で情報露出（パーサ/ライブラリ/設定）が出ていないかを確認（攻撃面の推定に使える）
- 期待する状態：どの経路でも一貫して DTD/外部参照を無効化できている

### 仮説B：DOCTYPEが受理される（危険側の前提が揃う）
- 次の一手
  1) 外部実体“解決”が起きるか（DNS/HTTP egress）を観測して確定（次ファイル：Blind/OOB）
  2) 外部参照が無くても成立する DoS（展開爆発）が残っていないかをラボで検証
  3) どのパーサ/ライブラリが使われているかを特定し、無効化設定の適用箇所（全経路）を洗い出す
- 期待する状態：修正は「入力フィルタ」ではなく「パーサ設定」で閉じる

---

## 防御設計（“パーサ設定＝実行境界の制御”）
- 第一原則：DTDを無効化（DOCTYPEを拒否）
  - “外部実体だけ無効”よりも確実性が高い
- 第二原則：外部参照を伴う機能も無効化/制限
  - 外部一般実体、外部パラメータ実体、外部サブセット
  - XInclude 等（使用している場合）
- 第三原則：経路ごとではなく “共通ライブラリ/共通設定” で一括適用
  - API、アップロード、変換、プレビュー、バッチ、管理UI、ジョブ
- 第四原則：観測可能な防御（ログ/メトリクス）
  - 外向きDNS/HTTPの監視、異常なXML展開負荷の監視（ラボで観測設計を固める）

---

## 手を動かす検証（Labs連動：観測→解釈→利用）
- 追加候補Lab
  - `04_labs/02_web/05_input/08_xxe_parser_doctype_entity_boundary/`
- 検証設計（手順書ではなく設計）
  - ターゲット：代表的パーサを複数用意（Java / .NET / libxml2系 / Node等）
  - 切替軸：DOCTYPE許可/禁止、外部実体解決の可否、展開の可否、XIncludeの可否
  - 観測点
    - アプリログ（パーサ例外の種類、拒否理由）
    - 外向き通信ログ（DNS/HTTP）
    - リソース（CPU/メモリ、応答時間）
  - 巻き戻し：スナップショット/コンテナ再起動で再現性を担保

---

## コマンド/リクエスト例（例示は最小限：観測の形だけ）
~~~~
# 目的：DOCTYPEが受理されるか（DTDが生きているか）を“差分”で確認する
# - 成功/失敗ではなく、エラー種別・応答差分・ログ差分を証拠化する

# 例：XML入力を送れる箇所に対し、DOCTYPEを含むXMLを与えて挙動を見る（ラボ推奨）
# <!DOCTYPE r [ <!ENTITY x "test"> ]>
# <r>&x;</r>
~~~~

---

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`（“実行境界”の総論：パーサは実行）
- `01_topics/02_web/05_input_09_ssrf_01_reachability（internal_localhost_metadata）.md`（次段：外部実体解決が到達性に繋がる）
- `01_topics/02_web/04_api_00_権限伝播・入力・バックエンド連携.md`（入力がバックエンドへ伝播する経路の整理）

---

## 次（作成候補順）
- `01_topics/02_web/05_input_08_xxe_02_blind（oob）.md`
