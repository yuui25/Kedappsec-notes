## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）

- ASVS
  - 入力→実行境界：ユーザ入力が “値” ではなく **Cypherクエリ（構文）** の一部として解釈されない設計か（パラメータ化必須）
  - 認可境界：グラフ探索は「関係（edge）」を辿るため、IDOR/BOLAと違う形で越境する（ノード/リレーションのスコープ強制が必要）
  - データ公開：返却フィールド（properties）とパス（path）を縮退しないと、探索で横断収集しやすい
  - エラーモデル：構文エラーがスタックやクエリ断片を返すとoracleになる（実装露出）
  - 可用性：可変長パス、広いマッチ、正規表現等が高コストになり得る（制限設計が必要）
- WSTG
  - Injection：SQLiと同じ枠で「入力→クエリ生成点→差分観測」で成立根拠を取る
  - Authorization：Graph特有の “横断探索” がテナント境界を越えないかを検証観点に入れる
- PTES
  - Vulnerability Analysis：Cypher生成点（文字列連結/テンプレ/OGM）と入口（検索/推薦/関係表示）を特定
  - Exploitation：影響実証は最小限（越境混入・情報露出の成立まで）。高負荷探索は避ける
  - Reporting：原因を「パラメータ化不足」「OGM/テンプレ誤用」「スコープ制約不在」「返却縮退不足」「制限不備」に分解して提示
- MITRE ATT&CK
  - TA0009 Collection（グラフは横断収集と相性が良い）/ TA0001 Initial Access（公開API入口）
  - 代表：T1190（公開アプリのExploit）、探索により関係性情報を収集

---

## タイトル
NoSQL Injection（Neo4j）：Cypher Injection（入力→グラフクエリ構文境界）

## 目的（この技術で到達する状態）
- Neo4j（Cypher）を使うWeb/APIで、入力が「検索語」ではなく **Cypher構文** として解釈される境界破壊を、
  1) 入口（どの機能がCypherへ到達するか）  
  2) 生成点（文字列連結/テンプレ/OGM）  
  3) 成立根拠（差分＝oracle）  
  4) 影響（認可越境・情報露出・可用性）  
  に分解して評価できるようになる。

## 前提（対象・範囲・想定）
- 対象
  - グラフ検索（人物/組織/関係検索）、推薦（recommendation）、関連ノード表示、タグ/カテゴリの関係表示、権限グラフ（RBACの関係管理）
  - “関係の可視化” “つながり” “おすすめ” “共通点” のような機能はCypher到達の可能性が高い
- 想定構成
  - アプリ→Neo4j（Bolt/HTTP）
  - OGM（Object Graph Mapper）やクエリビルダの利用有無でリスクが変わる
- 本ファイルの焦点
  - Cypher Injection（クエリ構文境界）＝ **文字列連結でCypherを生成** している場合の問題
- 非スコープ（別ファイル）
  - APOC（拡張プロシージャ）由来のリスクは次ファイルで扱う
  - 認可（グラフスコープ）設計は後続の authz ファイルとも接続する

## 背景：Cypherは“関係を辿る言語”で、越境の形がSQLと異なる
- SQLiは「行/テーブル」の境界を崩す
- Cypherは「ノード/リレーション/パス」を辿り、**一度スコープが崩れると横断収集が容易**
- 実務上の落とし穴
  - “検索機能”として実装したつもりが、実際には “探索機能” をユーザに渡してしまう
  - 返却縮退（properties制御）が弱いと、情報露出が大きくなる

## 境界モデル（入力→Cypher生成→実行→返却）

### 1) 入口（input surface）：Cypher到達点を洗う
- 典型入口（優先度高）
  - 検索：名前/キーワード/タグ/カテゴリ
  - 関連表示：関連ノード、共通の友人、共通の属性
  - 推薦：おすすめ、類似ユーザ、関連コンテンツ
  - 管理：関係の追加/編集（edge作成）
- 観測の取り方（黒箱）
  - 検索語に記号を混ぜたときに、エラー形状・結果の面積が揺れるか
  - 返却に “path” “nodes” “relationships” のような構造が含まれるか（含まれるほど探索性が高い）

### 2) 生成点（sink）：安全/危険の分岐
- 安全側（望ましい）
  - パラメータ化（`$param`）で値だけ渡す
  - クエリは固定テンプレ、入力はパラメータに閉じる
- 危険側（脆弱になりやすい）
  - 文字列連結で `... WHERE n.name = ' + user + ' ...'` のように作る
  - “柔軟な検索”のつもりで、入力が条件式の断片として混ざる
- 典型の実装理由（原因化しやすい）
  - 動的にWHEREを組み立てたい、ソートや条件を自由化したい、という要求
  - OGM/クエリビルダの使い方が分からず、最短で文字列連結に逃げる

### 3) oracle（成立根拠）：エラーよりBoolean差分を主証拠に
- Boolean oracle（主）
  - 件数、レスポンス長、返却ノード数/関係数、特定カテゴリの出現
- Error oracle（補助）
  - Cypher構文エラーが返る場合は、クエリが入力に影響されている補助証拠
  - ただし詳細エラーは情報露出（error model不備）として同時に指摘できる
- Time oracle（補助、DoS配慮）
  - 可変長パス等で遅延が出ることはあるが、負荷検証は避け、制約欠如として扱う

## 典型的な攻撃面（何が起きるか：影響を分解）

### 影響1：検索条件の改変（検索面積が広がる）
- 本来：特定ノードだけが返る
- 境界破壊：条件が変わり、検索範囲が広がる
- 実務の評価
  - “検索機能として許される範囲”を越えるか（仕様との切り分け）
  - 返却が縮退されていない場合、情報露出が拡大する

### 影響2：グラフ横断（関係の探索で越境混入）
- 典型
  - 同一tenant内での関係探索は仕様でも、tenant境界を越えた探索が混入するのが問題
- 重要
  - グラフでは “id 1個” の越境より、**パス探索で段階的に越境** しやすい
- 評価の着眼点
  - “どのノードラベル/リレーション種別”が返るか（スコープ制御の有無）

### 影響3：情報露出（返却プロパティと構造）
- グラフは “関係性” が機微になりやすい
  - 例：同一企業内の組織構造、権限関係、共有関係、取引関係など
- 返却縮退が弱いと
  - properties の過剰返却
  - path 全体（nodes+relationships）返却
  が横断収集の起点になる

### 影響4：可用性（高コスト探索）
- 可変長パス、広いMATCH、正規表現等で高コスト化し得る
- 実務の扱い
  - 実際に高負荷をかけるより、「探索上限・深さ制限・タイムアウト・レート制限」の欠如として評価する

## 根本原因の分類（報告にそのまま使える形）

### 原因A：Cypherのパラメータ化不足（文字列連結）
- 症状
  - 入力の記号で構文エラー/結果差分が揺れる
- 修正
  - 値は必ずパラメータ（`$param`）で渡す
  - “条件/フィールド/ソート”の自由化は、選択式（allowlist）でサーバがクエリを生成する

### 原因B：動的WHERE/ソート/ラベル指定を入力で受けている（語彙の委譲）
- 症状
  - 入力が“値”ではなく“語彙（field/label/order）”として扱われる
- 修正
  - ラベル/プロパティ/ソートキーはサーバ側マッピング（UI選択肢→内部語彙）で固定

### 原因C：スコープ制約（tenant/org/owner）がクエリ構造で揺れる
- 症状
  - tenant条件が入力と同レイヤで合成され、分岐で消える/弱まる
- 修正
  - スコープ制約は常に強制（最外周で固定）し、入力に依存させない

### 原因D：返却縮退（プロパティ制御・パス返却制御）が弱い
- 症状
  - 必要以上のproperties/pathが返る
- 修正
  - 返却フィールドは最小化（DTO/view model）
  - pathを返す場合も深さ・ノード種別・プロパティを制限

## 次に試すこと（仮説A/B：最小差分で確定）
※具体の悪用payloadは示さず、観測設計として書く。

### 仮説A：入力がCypher構文に混ざっている（Injection）
- 条件（観測）
  - 入力の形で結果（件数/返却ノード数/長さ）が安定して揺れる、または構文エラーが揺れる
- 次の一手
  - 入口を確定（どのパラメータがCypher生成に影響するか）
  - 同一入口で再現性を取り、WAFやエラーモデルの影響を除外して“成立根拠”を固める

### 仮説B：入力はパラメータだが、スコープ制約や返却縮退が弱い（設計不備）
- 条件（観測）
  - 構文注入らしい差分はないが、検索面積が過剰・返却が過剰・tenant境界の変化が不自然
- 次の一手
  - 認可（スコープ）と返却縮退を中心に、BOLA/BFLAの観点で評価を組み立てる（Cypher injectionとは別軸で報告）

## 防御設計（実装・運用）

### 1) パラメータ化（最優先）
- クエリ本文に入力を連結しない
- 値は `$param` で渡す
- 動的条件は “サーバ側で構造生成” し、入力は選択肢に限定する

### 2) allowlist（語彙の固定）
- 許可する
  - プロパティ（検索対象フィールド）
  - ラベル/リレーション種別
  - ソートキー
  をサーバ側で固定（マッピング）
- 入力に “語彙” を渡さない（値だけ渡す）

### 3) スコープ制約（tenant/org/owner）の強制
- 常に最外周で固定し、入力に依存させない
- グラフ探索（可変長）を許可する場合
  - 深さ上限（max depth）
  - 許可ラベル/関係の制限
  - tenant境界を跨ぐエッジをそもそも作らない（データモデル側の設計）
  をセットで持つ

### 4) 返却縮退（DTO/view model）
- 必要なプロパティだけ返す
- pathを返す場合も
  - 深さ、ノード種別、関係種別、プロパティ を制限
- “探索API” と “参照API” を分離し、探索側は権限と監査を強くする

### 5) 可用性（制限）
- タイムアウト、結果上限、レート制限
- 可変長パスや正規表現の利用を制限（必要なら管理者専用など）

### 6) エラーモデル統一
- 外部：統一エラー + trace_id
- 内部：Cypherの構文/実行エラーを分類し、原因追跡できるログ（ただし入力はマスク）

## 手を動かす検証（Labs連動：Cypher境界の再現）
- 目的：文字列連結 vs パラメータ化、スコープ強制の有無を比較し、差分観測で成立根拠を取る
- 最小構成（推奨）
  - (1) 安全：クエリ固定 + paramsのみ + tenant強制 + 返却縮退
  - (2) 危険：文字列連結でWHEREを生成（悪い例）
  - (3) スコープ不備：tenant条件が分岐で消える悪い例
  - (4) 返却過剰：path/propertiesを返し過ぎる悪い例
- 証跡
  - HAR：baseline / 差分（件数・構造） / 差分（エラー）
  - サーバログ：trace_id、利用したクエリテンプレID、paramsの型、実行時間
  - DB側（Labsのみ）：クエリログ、計画、タイムアウト

## 例（最小限：設計の違いを固定する）
~~~~
# 安全：paramsで値だけ渡す（概念例）
MATCH (n:User)
WHERE n.email = $email AND n.tenant_id = $tenant
RETURN n.id, n.name
~~~~
- 観測していること：
  - 入力が構文に混ざらず、スコープ（tenant）が固定で強制される
- 注意：
  - ソートやフィールド選択を動的にしたい場合も、語彙はallowlist化してサーバがクエリを生成する

~~~~
# 危険（概念）：文字列連結でWHERE等を組み立てる設計はInjection境界が開くため禁止
# ※具体の悪用payloadは提示しない
~~~~

## 参考（必要最小限）
- Neo4j Docs：Cypher manual（パラメータ、クエリ構造）  
  - https://neo4j.com/docs/cypher-manual/current/
- Neo4j Docs：Drivers and parameterized queries（パラメータ化の基本）  
  - https://neo4j.com/docs/
  （※ドライバ/言語別ページは環境により異なるため、実装言語に合わせて参照）
- Neo4j Docs：Security（運用・権限）  
  - https://neo4j.com/docs/operations-manual/current/security/

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 次（作成候補順）
- `01_topics/02_web/05_input_04_nosql_injection_03_neo4j_cypher_02_apoc（procedure_security）.md`
