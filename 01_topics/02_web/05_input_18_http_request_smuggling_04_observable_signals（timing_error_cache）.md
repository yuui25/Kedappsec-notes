## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：request boundary が壊れると、認可・ルーティング・キャッシュ・監査の前提が崩れる。特に“フロントで見た1リクエスト”と“バックで処理した実リクエスト”が一致しないと、制御も監査も成立しない。
  - 満たす：曖昧リクエスト（TE+CL、重複CL、異常chunk等）を最前段で拒否し、異常時はコネクションを破棄してプール汚染を防ぐ。front/backで request_id を相関し、件数不一致・順序崩れを検知できる監視を備える。
- WSTG
  - 中心は「観測」。SmugglingはUI上の成功/失敗が見えにくい。よって、タイミング、エラー層（4xx/5xx/502/504）、レスポンス対応関係、ログ相関、キャッシュの異常（stored response）等を“体系化”して、成立根拠を作る。
- PTES
  - 脆弱性分析：攻撃の可否ではなく「境界が揺れている兆候→確定証拠→実害分岐」の順に進める。
  - 侵害評価：他者影響（キャッシュ汚染、混線）を含む可能性があるため、安全設計（少数回、隔離、許可範囲）と証跡取得（pcap/log）を必須にする。
- MITRE ATT&CK
  - T1190（公開アプリの脆弱性悪用）に繋がるが、観測学の目的は「成立根拠」。
  - Defense Evasion（フロント検査迂回）や Impact（劣化）へ繋がる兆候を、観測で区別する。

---

## タイトル
Request Smuggling 観測学：成功ペイロードではなく、タイミング・エラー層・ログ・キャッシュで“境界が壊れた”を証明する

---

## 目的（このファイルで到達する状態）
- Smuggling（TE.CL / CL.TE / H2→H1）の検証で、次を“観測の型”として実行できる。
  1) 兆候（signals）を分類し、何を見ればよいか迷わない
  2) 兆候→確定（proof）に上げるための追加観測（ログ相関/pcap）を設計できる
  3) “実害”と“単なる不安定”を切り分け、報告が薄くならない
  4) 安全に実施する（少数回、キャッシュ/他者影響の抑制、再現性より証跡優先）
  5) 修正要求を「観測で見えた設計欠陥」に結び付けて書ける（拒否・正規化・破棄・相関）

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：Request Smuggling / Proxy Desync の観測シグナル体系
  - timing（遅延/不連続）
  - error layers（4xx/5xx/502/504、RST/FIN）
  - response mapping（対応関係の崩れ）
  - cache artifacts（stored response、キーの揺れ）
  - logging correlation（front/backの件数・順序・相関キー）
- 扱わない：個別のペイロード詳細は各ファイルへ
  - TE.CL：`05_input_18_http_request_smuggling_01_te_cl（proxy_desync）.md`
  - CL.TE：`05_input_18_http_request_smuggling_02_cl_te（proxy_desync）.md`
  - H2フロント：`05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`

---

## 最初に固定する原則（これを守ると“薄い/危険”を避けられる）
### 原則1：成功/失敗ではなく「状態」を観測する
- Smugglingは“正解ペイロード”を当てるゲームではない。
- 観測すべき状態は次の3段階。
  - S1：曖昧入力が最前段で拒否される（健全）
  - S2：境界揺れの兆候がある（desync疑い）
  - S3：境界崩壊が確定（request↔response対応崩れ or front/backログ不一致）

### 原則2：少数回で止める（他者影響を避ける）
- キャッシュ汚染・混線・劣化は第三者影響を生みやすい。
- 反復より、証跡（pcap/ログ/時系列）を優先する。

### 原則3：相関（correlation）が取れるなら最優先で取る
- “タイミングが変”は兆候に過ぎない。
- front/backログの件数不一致、同一request_idでの矛盾など、確定証拠に近い。

---

## 観測シグナル体系（Signals → Proof へ上げる）
以下は「何が見えたら次に何を見るか」を固定するための一覧。

---

## 1) Timing Signals（遅延・不連続）
### 1-1) 典型シグナル
- 一部のリクエストだけ応答が極端に遅れる（急に数秒〜タイムアウト）
- 入力の“微差”（ヘッダ順、長さ、改行等）で応答が不連続に変わる
- ある試行の後、通常リクエストがしばらく不安定になる（回復に時間がかかる）

### 1-2) 何を意味し得るか（解釈の候補）
- バックが「まだボディを待っている」状態（境界不一致で待ち）
- プロキシが upstream を切り替えられず待ち（上流待ち）
- コネクションプールが汚染され、後続が詰まる（特にkeep-alive/pool構成）

### 1-3) Proofへ上げるための追加観測
- フロントログ：upstream_response_time / upstream_connect_time の急増（層の切り分け）
- バックログ：timeout、read bytes、request parse error の発生
- pcap：FIN/RST のタイミング、再送、同一コネクション上の送受信順序
- 結論の書き方
  - “遅い”ではなく「frontは受理したがbackが待っている兆候」「異常後にpool汚染の兆候」など状態で書く

---

## 2) Error-Layer Signals（エラー層：4xx/5xx/502/504）
### 2-1) 典型シグナル
- 同じ系統の入力で、4xxと502/504が揺れる
- 400が返るが、たまに通る/たまに502になる（不安定）
- 502/504が特定条件で出る（長さ/ヘッダ微差でトリガ）

### 2-2) 何を意味し得るか（層別の読み）
- フロント由来の4xx
  - フロントが曖昧性を検知し拒否している可能性（健全寄り）
- 502/504（Bad Gateway / Gateway Timeout）
  - バックのパース失敗、上流切断、待ち状態、あるいはプール汚染が疑われる
- 重要：同じ入力でも層が揺れる＝境界解釈が一意ではない（差分の強いシグナル）

### 2-3) Proofへ上げるための追加観測
- フロントログ：status + upstream_status の組み合わせ
  - front=502 / upstream=400 等の差分は、どこが壊れているかの手がかり
- バックログ：400系のパースエラー、リクエスト行崩壊
- 結論の書き方
  - 「エラーが出た」ではなく「frontは上流へ転送したが upstream がパース失敗」「frontが一貫して拒否できていない」等

---

## 3) Response-Mapping Signals（対応関係の崩れ）
### 3-1) 典型シグナル（最重要：境界崩壊の本体）
- 2リクエスト送ったのに、レスポンスが1つしか返らない
- 2つ返るが、順序が逆／内容が入れ替わるように見える
- “無関係なレスポンス”（別ページ、別エラー）が返る

### 3-2) 何を意味し得るか
- 同一コネクション上で request boundary が崩れた可能性
- バックで追加リクエストが処理され、レスポンスが別のリクエストに紐づいた可能性
- ただし、並列実行（H2の多重化）やリトライでも似た現象が起き得るため、次の観測で確定する

### 3-3) Proofへ上げるための追加観測
- H1：pcapで同一TCPストリームのHTTPを再構成（送信順と応答順）
- H2：stream_idごとにresponseを追跡（どのstreamが崩れたか）
- front/backログ相関：同一時刻に処理されたrequestの件数・順序・path
- 結論の書き方
  - 「レスポンスが入れ替わった」ではなく「同一接続におけるrequest↔response対応が崩れている兆候」「並列性では説明できない不一致」など、代替原因を潰した形で書く

---

## 4) Connection & Pool Signals（汚染・混線・枯渇）
### 4-1) 典型シグナル
- 異常試行の後、通常アクセスが断続的に遅い/失敗する
- 同一クライアントの後続が不安定（特定時間だけ）
- upstream側でコネクションが増え続ける、または特定数で詰まる兆候（運用ログが取れるなら）

### 4-2) 何を意味し得るか
- 異常状態のバックコネクションがプールへ戻り、後続に影響
- keep-alive/poolが攻撃面になっている（少数でも影響が出る可能性）

### 4-3) Proofへ上げるための追加観測
- フロント/バックの接続ログ：connection reuse の有無、該当接続の破棄有無
- エラー時に connection: close が付くか（フロントが破棄しているかの観測）
- 結論の書き方
  - “DoSっぽい”ではなく「異常時にコネクション破棄されず再利用される兆候」「pool汚染により後続が不安定化」等、設計欠陥として書く

---

## 5) Cache Signals（timing_error_cache の“cache”側：観測と注意）
> キャッシュに触れる検証は第三者影響が出やすい。ここは“観測学”として条件と証跡を厳格にする。

### 5-1) 典型シグナル（観測として）
- 同じURLなのに、突然内容が変わる／古い内容が返る
- ヘッダやパラメータの微差で、キャッシュヒット率や応答速度が急変する
- “別のレスポンスが混ざった”ような挙動がある（ただし強い証拠が必要）

### 5-2) 何を意味し得るか（慎重に）
- request boundary の崩れが、キャッシュ格納・キー生成・再利用に影響した可能性
- ただし、通常のキャッシュ設定（Vary、Cookie、認証）でも揺れるため、Smuggling由来と断定しない

### 5-3) Proofへ上げるための追加観測（安全に）
- キャッシュ層のヘッダ観測（Age、X-Cache、Via等：出る範囲のみ）
- 同一クライアントでの再現と、比較対象（通常入力）での差分
- 可能なら：キャッシュ層ログ（ヒット/ミス、キー）とアプリログ（生成したレスポンス）を突合
- 結論の書き方（重要）
  - “キャッシュ汚染できる”と断定せず、まず「キャッシュ応答が通常と異なる挙動を示す」→「ログ/ヘッダでキャッシュ関与を確認」→「境界崩壊と同時に発生」の順で根拠を積む

---

## 6) Logging Correlation Signals（最強の根拠：front/back不一致）
### 6-1) 典型シグナル
- frontログ：1リクエストなのに backログ：2リクエスト
- request_idが一致しない、順序が崩れる
- frontでのpath/hostと、backで処理されたpath/hostが一致しない（特にH2→H1）

### 6-2) Proofとして強い理由
- Smugglingは「中継点を跨いだ解釈差」が本体
- したがって、層を跨いだログ不一致は、そのまま成立根拠になる

### 6-3) 取りに行くための設計（診断時の要求）
- 可能なら request_id / traceparent を front→back に伝播（運用要件）
- 取れない場合でも、最低限
  - timestamp（ミリ秒）
  - client tuple（IP/UA/セッション）
  - upstream connection id（可能なら）
で相関を作る

---

## 7) “兆候→確定”の判定チャート（運用できる形）
### 7-1) まず分岐
- 4xxで一貫して拒否 → S1（健全寄り）
- 502/504、遅延不連続、対応崩れ → S2（疑い）
- front/backログ不一致、対応崩れが再現性あり → S3（確定）

### 7-2) S2（疑い）からS3（確定）へ上げる最短手
- 1) ログ相関（front/back）を取る（最短で強い）
- 2) pcapで同一コネクション上の送受信を確定
- 3) H2ならstream_idでresponseを紐づけ、並列性を排除

### 7-3) S3（確定）後にやること（実害評価）
- 追加リクエストが
  - 認可境界（/admin、重要操作）
  - ルーティング境界（別Host/別サービス）
  - キャッシュ/監査境界
へ届くかを、最小回数で評価する（他者影響に注意）

---

## 報告（所見）を“最大限深く”する書き方の骨格
### 1) 観測した状態（S1/S2/S3）
- 例：S2（境界揺れの兆候）／S3（境界崩壊確定）

### 2) 観測シグナル（少なくとも3種類を組み合わせる）
- timing：◯◯
- error layer：◯◯
- response mapping：◯◯
- logging correlation：◯◯（取れれば最優先）
- cache signals：◯◯（慎重に）

### 3) 代替説明の排除（説得力を作る）
- 例：単なる高負荷ではなく、入力の微差で不連続が出る
- 例：H2の並列性ではなく、stream_idで追跡しても対応が崩れる
- 例：キャッシュ設定の揺れではなく、同時にboundary兆候が発生している

### 4) 影響半径（条件付きで）
- 認可/ルーティング/監査/劣化のどれに接続できるか
- できない場合は「現時点では境界崩壊まで、実害分岐は未確認」と正直に切り分ける（推測しない）

### 5) 修正要求（観測結果→設計要件へ）
- 曖昧入力拒否
- 変換規則の固定（H2→H1）
- 異常時のコネクション破棄
- front/back相関ログ

---

## 防御（観測で見えた欠陥に対応するチェックリスト）
- 最前段で TE+CL、重複CL、異常chunk 等を拒否しているか
- 例外時にバックコネクションを破棄しているか（pool汚染を起こさないか）
- front/backで request_id を相関できるか（件数不一致を検知できるか）
- H2→H1変換で “危険なH1” を生成しない規則があるか
- 監査ログが “フロント視点のみ” になっていないか（真実性の担保）

---

## 04_labs（観測学の訓練：ペイロードではなく“観測”を鍛える）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/18_request_smuggling_observable_signals/`
- Lab設計要件
  - 3構成を用意（TE.CL / CL.TE / H2→H1）
  - それぞれで “S1/S2/S3” を意図的に作り分け（設定で拒否/許可/汚染）
  - 証跡は必ず3点セット：
    - pcap（ストリーム）
    - frontログ（upstream_*）
    - backログ（request line / bytes / parse error）
  - 目標：ペイロード暗記ではなく、「観測→状態判定→次の一手」を反射で回せるようにする

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# 観測学の要点：
# - “成功したか”ではなく、S1/S2/S3のどれかを判定できる証拠を集める
# - タイミング、エラー層、response対応、ログ相関、キャッシュの5軸で見る
# - 他者影響が出る可能性があるので、少数回で証拠重視
~~~~

---

## 深掘りリンク（最大8）
- `05_input_18_http_request_smuggling_01_te_cl（proxy_desync）.md`
- `05_input_18_http_request_smuggling_02_cl_te（proxy_desync）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
