## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 破れる点：不正入力がデータストアに永続化され、別ユーザ/別権限の表示コンテキストで“実行”に変わる（入力→保存→表示の信頼境界破壊）。対策は入力フィルタではなく、コンテキスト別出力エンコーディング＋適切なサニタイズ＋テンプレ運用（raw/unsafe例外の統制）＋CSP
- WSTG：
  - Testing for Stored Cross Site Scripting（格納XSS）に対応（ユーザ入力が保存され、後で取り出されて表示されることが本質） :contentReference[oaicite:0]{index=0}
- PTES：
  - Vulnerability Analysis：格納点（DB/検索Index/キャッシュ/ログ/オブジェクトストレージ）と再表示点（画面/API/export/通知）を結び、被害者（一般/管理/運用）を定義
  - Exploitation：成立根拠（実行コンテキスト確定）＋影響（どの権限で、どの操作が可能か）を最小PoCで示す
  - Reporting：原因を「保存時の型/制約不備」「再表示のコンテキスト別エスケープ不備」「サニタイズ誤用」「CSP不備」「権限境界（管理画面/運用UI）での表示」へ分解
- MITRE ATT&CK：
  - 初期侵入/実行の導線：Web閲覧を起点にクライアント側へ影響（Drive-by Compromise: T1189 へ接続） :contentReference[oaicite:1]{index=1}
  - 実務では「被害者権限での操作代行（Account/Workflow乗っ取り）」が中心で、後続は環境依存（SaaS/IdP/管理画面への踏み台になり得る）

---

## タイトル
格納XSS（Stored XSS）境界モデル

## 目的（この技術で到達する状態）
- 格納XSSを「保存された入力が後で表示される」以上に、**境界モデル**として説明できるようにする
  - どこに保存されたか（格納点：DB/検索/ログ/キャッシュ/ファイル）
  - どこで再表示されるか（再表示点：UI/API/export/通知/管理画面）
  - 誰が被害者か（閲覧者の権限：一般/運用/管理/他テナント）
  - どの“実行コンテキスト”に入ったか（HTML/属性/JS/URL/CSS）
  - どの防御（テンプレ自動エスケープ、サニタイズ、CSP）が、どの境界を守れていないか :contentReference[oaicite:2]{index=2}
- 「攻撃より」の意思決定として、次を即断できる
  - 影響が最大になる被害者（管理/運用）へ到達する“閲覧導線”があるか（通知・一覧・監査ログ・モデレーション等）
  - 反射よりも深刻になりやすい理由（誘導不要、持続、複数被害者、再発経路の多さ）を報告に落とせる

## 前提（対象・範囲・想定）
- 対象：
  - ユーザ生成コンテンツ（UGC）：コメント、プロフィール、チケット本文、記事、レビュー、チャット、テンプレ、メモ、タグ、商品説明
  - “UGCに見えない”が実務で多い：監査ログ表示、管理コメント、エラー/検証結果表示、インポート結果、CSV/PDF出力プレビュー
- 想定される現実制約：
  - WAF/簡易フィルタあり（ただし本質対策にならない前提）
  - リッチテキスト/Markdown/テンプレ等の「部分的にHTMLを許す」要件（ここが最頻の混入点）
  - CSPが一部導入されている場合（nonce/strict CSP の有無で“実行の成立条件”が変わる） :contentReference[oaicite:3]{index=3}
- 本ファイルの範囲：
  - **格納（永続化）→再表示→実行**のモデル化と、現実の格納点/再表示点の洗い出し
  - DOM XSS の詳細（クライアント側sink/source、フレームワーク特有）は次ファイル（03_DOM）で扱う
- 安全な検証範囲（原則）：
  - 目的は成立根拠の確定と影響評価。PoCは「最小の実行確認」まで（情報窃取・持続化・外部送信の具体化には踏み込まない）

---

## 境界モデル（入力→保存→再表示→実行）
### 1) 格納点（Persistence Boundary）
- DB：本文/タイトル/表示名/署名/テンプレ/注釈/メタ情報
- 検索/分析：Elasticsearch等のindex（“表示用に整形した値”が別途格納されることがある）
- キャッシュ：レンダリング済みHTMLのキャッシュ（CDN/アプリ内）
- ログ：監査ログ、操作ログ、Webhookログ、APIログ（運用UIで閲覧される）
- ファイル/オブジェクト：HTML断片、エクスポート生成物、テンプレ資産

### 2) 再表示点（Render Boundary）
- 一般ユーザ画面：詳細/一覧/通知/タイムライン
- 管理/運用画面：モデレーション、検索、監査、問い合わせ対応、ジョブ結果一覧（最優先で危険）
- API：JSONに入るだけに見えて、フロントが `innerHTML` 等で描画しDOM XSSへ合流することがある（“格納→API→DOM”）
- export：CSV/PDF/HTMLレポート（閲覧者が運用者になりやすい）
- 通知：メール/Slack/Teams等（HTMLメール、プレビューUI、リンク展開で別レンダラが動く場合）

### 3) 実行コンテキスト（Execution Context）
- HTML本文 / 属性値 / URL属性 / JS文字列 / JSON埋め込み / CSS
- 格納XSSは「同じデータが複数画面で別コンテキストに入る」事故が多い
  - 例：詳細画面は安全だが、一覧画面の “短縮表示” が unsafe など（= “再表示点差分”が本体）

---

## 攻撃者視点の“価値”の決め方（優先度モデル）
格納XSSは「どこで誰が見るか」が価値。payloadの工夫より、**閲覧導線**の設計ミスを突く。

### A) 被害者（閲覧者）のランク付け
- Tier 0：運用/管理（管理コンソール、サポートUI、監査ログビューア）
- Tier 1：他ユーザ（同一テナント内の一般ユーザ）
- Tier 2：自己（self-XSS：基本は低いが、運用UI/支援ツール経由でTier0に跳ねると危険）

### B) “閲覧が必ず発生する”導線
- モデレーション（未承認投稿のレビュー）
- 問い合わせ（サポートが必ず見る）
- 監査/アラート（セキュリティ/運用が必ず見る）
- 通知（新規投稿・メンション・エラーの通知）

### C) 影響の現実評価（実行できた後に何が起こるか）
- 被害者権限での操作代行（承認、権限変更、設定変更、課金、データ閲覧）
- 権限伝播（管理画面で見た場合の影響が大きい）
- ただし “盗む/外部送信”をPoCにする必要はない。操作代行やUI上の状態変化で十分に根拠化できる

---

## 成立根拠（差分＝成立根拠）を取る：最大限現実寄り
格納XSSは「保存できた」「別ページで表示された」「その表示が“実行コンテキスト”だった」を分解して証拠化する。

### 1) まずは “格納できた” を証明する（保存点の確定）
- 入力に **ユニークマーカー** を入れる（例：短い英数字＋タイムスタンプ）
- 保存後に以下を確認
  - 再編集画面に同じ値が残っている（DB格納の最短証拠）
  - APIレスポンス/一覧/検索結果に同じ値が含まれる（再表示点候補が増える）

### 2) 次に “再表示点の全探索” をする（同一データが出る場所を潰し切る）
- 探索の順序（現実で当たりやすい）
  1) 一覧（短縮表示・ハイライト・サマリ生成が事故りやすい）
  2) 管理/運用（サニタイズが甘い or “信頼済み”扱いされがち）
  3) 検索（ハイライト表示、クエリ強調、タグ表示）
  4) 通知（HTMLメールテンプレ、プレビュー）
  5) export（HTML/PDF生成のテンプレ）
- 重要：同じ入力でも、表示点ごとに「エスケープ方式」が変わる（= 差分観測の価値）

### 3) 最後に “実行コンテキストに入った” を確定する
- コンテキスト別に、成立根拠を言語化する（payload依存にしない）
  - HTML本文：DOM構造が変わる／要素として解釈される兆候
  - 属性：属性境界（クォート）や値の構造が変わる兆候
  - JS/JSON：構文エラー/挙動差分が入力に連動する兆候
- 併せてCSP状態を記録（CSPは“成立可否”を左右する） :contentReference[oaicite:4]{index=4}

---

## “格納XSSあるある”の深掘り（設計ミスのパターン）
### パターン1：入力側サニタイズに依存している（出力側が生）
- 一度通った値が、別画面（管理・一覧・メール）で raw 表示されると破綻
- 重要：XSS対策は原則「出力時（コンテキスト別）」が主。入力時フィルタは補助であり、完全性がない :contentReference[oaicite:5]{index=5}

### パターン2：リッチテキスト/Markdown/テンプレ機能が混ざっている
- “一部HTMLを許す”設計は、許可リストとレンダラ差分（画面ごとに違うレンダラ）で事故りやすい
- 典型事故：本文はサニタイズ済みだが、プレビュー/検索ハイライト/引用表示が別実装で未対策

### パターン3：二次利用（再掲・引用・要約）で別コンテキストに落ちる
- 「要約」「引用」「カード表示」「OGP」「通知」のように、同じデータが “別テンプレ” に入る
- ここで属性/JSに入りやすく、反射よりも再現が安定する

### パターン4：テナント/権限境界と合流する（最も危険）
- 他テナントの運用者が閲覧する導線（共有・承認・監査）で発火すると、影響が跳ねる
- したがって格納XSSは **AuthZ（閲覧範囲）** とセットで評価する（どのロールが閲覧できるか）

### パターン5：CSPはあるが “例外” が多い
- `unsafe-inline` や広い許可ドメイン、またはnonce運用が部分的で、ページごとに強度が違う
- nonce/strict-dynamic の考え方を理解し、「このページのCSP強度」を証拠として残す :contentReference[oaicite:6]{index=6}

---

## 確認（最大限詳しく：現場手順としてブレない形）
### 手順0：対象データ（候補）を“格納型”で分類する
- 文字列（短文）／長文（本文）／リッチテキスト／タグ配列／テンプレ（差し込み）／メタ情報（タイトル等）
- それぞれで “再表示点” がどこに出るか仮説を立てる（一覧・検索・通知・管理）

### 手順1：マーカーで格納→再表示の経路を作る
- 入力にユニークマーカーを設定（例：`keda_xss_store_YYYYMMDDhhmm`）
- 保存・編集・一覧・検索・管理画面で、そのマーカーがどこに出るかを列挙する
- ポイント：ここでは実行させない。経路と文脈の棚卸しが目的

### 手順2：表示点ごとに“コンテキスト”を確定する
- 表示HTMLの該当断片を取り、マーカーが
  - テキストノードか
  - 属性値か（href/src/data-* など）
  - script/JSON内か
  を分類する
- CSPヘッダも同時に控える（ページごとに差がある） :contentReference[oaicite:7]{index=7}

### 手順3：最小PoCで“実行境界を跨いだ”根拠を取る
- 実務の推奨：破壊や外部通信ではなく、UI上の最小変化で成立根拠を取る（監査・再現性・安全性の観点）
- ここで重要なのは payload の技巧ではなく、
  - “どの表示点で”
  - “どのコンテキストで”
  - “どの防御が効いていないか”
  を確定すること

### 手順4：被害者・導線・影響を確定する（攻撃よりの本体）
- 被害者（誰が見るか）を確定：一般/運用/管理
- 閲覧導線を確定：通知、一覧、問い合わせ、監査、モデレーション
- 影響を確定：被害者権限で可能な操作（重要操作があるなら最優先）
- これを「再現手順」と「影響説明」に落とし込む（CTFでなく実務評価）

---

## 次に試すこと（仮説A/B分岐）
- 仮説A：一般画面は安全だが、管理/運用画面で未対策（最頻・最危険）
  - 次：管理画面の一覧/検索/詳細/監査表示で同一データの“別レンダリング”を確認（短縮・ハイライト・引用が特に狙い目）
- 仮説B：検索/ハイライト（強調表示）が別実装で事故っている
  - 次：検索結果のハイライト箇所が `innerHTML` 等で描画されていないか（DOM編へ接続）
- 仮説C：通知/メール/外部連携でレンダラが違う
  - 次：通知テンプレのエスケープ・HTML許可範囲・プレビューUIの実装を確認
- 仮説D：CSPが強いページと弱いページが混在
  - 次：弱いページ（CSP無し/例外多い）での成立根拠を優先的に確定し、CSP統一の改善提案へ

---

## 手を動かす検証（Labs連動：現実に寄せた再現）
- 追加候補Lab：
  - `04_labs/02_web/05_input/06_xss_stored_boundary/`
- 再現要件（現実寄り）
  - UGC保存（DB）
  - 表示点を最低3つ用意（一般詳細／一般一覧（短縮）／管理一覧）
  - 表示点ごとにレンダラ/テンプレを変える（“事故の起き方”を再現）
  - CSPを段階導入（無し→弱い→nonce/strict）で差分を体感
- 証跡
  - HAR（保存→表示点A/B/C）
  - HTML断片（反射位置、コンテキスト）
  - CSPヘッダ（ページごと）

---

## コマンド/リクエスト例（最小限：意味が伝わる“観測用”）
~~~~
# 目的：格納→再表示点の棚卸し（実行させない）
# 1) 投稿/保存リクエストにユニークマーカーを入れる
POST /comment
Body: { "body": "keda_xss_store_20251219_2230" }

# 2) 一覧/詳細/管理で同じマーカーがどこに出るか確認する
GET /comments
GET /comments/123
GET /admin/moderation/comments
~~~~
- この例で観測していること：
  - 格納点（保存された）と、再表示点（どこで見えるか）の網羅
  - 表示点ごとのHTMLコンテキスト差分

---

## 参考（必要最小限）
- OWASP WSTG：Testing for Stored Cross Site Scripting（格納XSSの定義とテスト観点） :contentReference[oaicite:8]{index=8}
- OWASP Cheat Sheet：XSS Prevention（コンテキスト別エンコーディングの原則） :contentReference[oaicite:9]{index=9}
- MDN：CSP（script-src、nonce/strict-dynamic 等） :contentReference[oaicite:10]{index=10}
- MITRE ATT&CK：Drive-by Compromise（T1189） :contentReference[oaicite:11]{index=11}

---

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/05_input_06_xss_01_反射_境界モデル.md`
- `01_topics/02_web/06_config_03_セキュリティヘッダ（CSP_HSTS_Frame_Referrer）.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`（被害者権限の影響評価に接続）

---

## 次（作成候補順）
- `01_topics/02_web/05_input_06_xss_03_DOM_境界モデル.md`
