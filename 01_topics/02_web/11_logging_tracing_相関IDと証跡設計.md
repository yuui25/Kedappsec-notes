## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：認証・認可・入力防御が一定でも、ログが「追えない」「改ざんされる」「機微が漏れる」「相関できない」状態だと、(1) 侵害の検知・封じ込め・原因究明ができない、(2) 重要操作の証跡が残らず否認に弱い、(3) ログ自体が情報漏えい（トークン/個人情報）になる、(4) ログ注入（改行/CRLF）で監査が崩れる、が現実に起きる。結果として“安全に運用できる境界”が成立しない。
  - 満たす：相関ID（request/trace）と、主体（principal）・テナント（tenant）・操作（action）・対象（object）・判断（decision）を最小セットとして一貫記録し、改ざん耐性（WORM/署名/集中管理）と機微保護（マスキング/最小化）を設計要件化する。さらに、同期（API）だけでなく非同期（ジョブ/キュー）まで“同じ相関”で追えるようにする。
- WSTG
  - 観点：脆弱性の有無だけでなく、検証で得られた事象を「再現・説明・証跡化」できるかが品質になる。テストは (1) 相関IDが各Hopに伝播するか、(2) 認証/認可の判定点がログ化されるか、(3) 異常（失敗/拒否/レート制限/CSRF等）が可観測か、(4) ログ注入や機微混入が起きないか、を観測で確定する。
- PTES
  - 位置づけ：Recon〜Exploitationの“結果”を、Reportingで説得力ある根拠に変えるための基盤。攻撃成立の証跡（リクエスト/レスポンス/相関ID/監査ログ）を揃え、同時に運用是正（検知・追跡・封じ込め）へ繋げる。特にマイクロサービス/非同期では、相関ID設計がないと「どこで何が起きたか」が崩れて評価が曖昧になる。
- MITRE ATT&CK
  - 攻撃者は痕跡を残さない/分断する方向に動く（例：ログ無効化・ログ改ざん・相関不能化・大量ノイズ）。防御側は相関IDと監査ログで「行為の連鎖（Discovery→Credential→Lateral/Impact）」を繋ぐ。
  - 本ファイルはATT&CKの網羅ではなく、(a) 攻撃者が“隠す/分断する”対象としてログが狙われる、(b) 相関設計があると検知・追跡の目的に直接効く、という接続を明示する。

---

## タイトル
Logging/Tracing 境界（相関IDと証跡設計）
「どの層で何が起きたか」を“同じID”で追い、監査可能な証跡として残すための設計単位

---

## 目的（このファイルで到達する状態）
- Webアプリ（Browser→BFF→API→DB→Job/Queue→外部SaaS）を跨ぐ処理を、**相関IDで1本の線として追える**状態にする。
- 「ログを出す」ではなく、境界として以下を説明できる：
  1) 観測対象（何を見ているか：プロトコル/データ/境界）  
  2) 観測結果の意味（何が言える/言えない、前提条件）  
  3) 仮説A/B（相関できない原因が“伝播欠落”か“記録欠落”か“改ざん/欠損”か）  
  4) 次の一手（実装/運用/監視/検証の優先度）  
- 証跡設計として、改ざん耐性・最小化・アクセス制御・保持・検索性を、実務要件に落とせる。

---

## 扱う範囲（スコープ）
- 扱う
  - 相関ID（Request-ID / Trace-ID / Span-ID）設計と伝播（同期/非同期）
  - 分散トレーシング（traceparent / tracestate / B3 等）の“境界での扱い”
  - 監査ログ（誰が/どこで/何を/どれに/許可or拒否）設計
  - ログの機微保護（トークン/個人情報/秘密情報）とログ注入対策
  - 証跡の完全性（改ざん耐性、WORM、時刻同期、チェーン・オブ・カストディの前提）
- 扱わない（接続先）
  - 個別のWAF/SIEM/APM製品の選定・操作手順（本リポジトリの方針上、製品紹介で終えない）
  - 低レベルのOS/基盤ログ設計（必要なら 08_blue-dfir へ接続）

---

## 境界モデル：ログ/トレースは「相関の連続性」と「証跡の完全性」で壊れる
### 1) 3つの境界（資産/信頼/権限）
- 資産境界（どこまで記録対象か）
  - ブラウザ（RUM/エラー/操作イベント）、CDN/WAF、LB/Ingress、BFF、API、DB、キャッシュ、ジョブ/キュー、外部SaaS（Webhook/IdP）
- 信頼境界（どのID/フィールドを信じてよいか）
  - クライアントが送ってくる `X-Request-ID` / `traceparent` は“自己申告”になり得る
  - 内部（Gateway/Ingress）が発行するIDは、内部境界の担保（注入不可）とセットで信頼できる
- 権限境界（誰の行為として記録するか）
  - principal（ユーザ/サービス/ジョブ）と、tenant（組織）と、actor（代理実行/On-behalf-of）を分離して記録しないと否認が成立する
  - 認可判定点（policy/guard）での decision を残さないと、成功/失敗の意味が曖昧になる

### 2) 相関の連続性（Correlation Continuity）
- 同期（HTTP）では、Hopが増えるたびに「IDが欠落・置換・分岐」しやすい
- 非同期（Queue/Job）では、さらに「時間の断絶」が入り、親リクエストとの紐付けが消えやすい
- 結果として、次が起きる：
  - “同じユーザ操作”が複数のrequest_idに散らばる
  - “同じ障害”が複数サービスのログに分断され、原因が特定できない
  - “同じ攻撃”がノイズに埋もれる

### 3) 証跡の完全性（Evidence Integrity）
- ログが揃っても、改ざん・欠損・時刻ずれ・注入で証拠として崩れる
- 監査の観点では「存在する」だけでなく
  - 改ざんされにくい（Write Once / 署名 / 集約）
  - 欠損しにくい（バッファ/再送/バックプレッシャ）
  - 時刻が揃う（NTP/UTC/単調増加）
  - 検索できる（正規化された構造ログ）
  が必要になる

---

## 相関ID設計（Request-ID と Trace-ID を“役割”で分ける）
### 1) 最小セット（まずこれが揃わないと運用が崩れる）
- request_id：1つのHTTPリクエスト（Hop単位）を識別
- trace_id：ユーザ操作から連なる一連の処理（複数Hop/複数リクエスト）を束ねる
- span_id：trace内の区間（各HopやDB呼び出し等）を識別

実務では「request_idだけ」だと、リダイレクト/並列API/再試行で追えなくなるため、trace_id（分散トレーシング）の導入価値が高い。

### 2) 発行責任（誰がIDを発行するか）
- 原則
  - trace_id：入口（Ingress/Gateway または BFF）で発行し、下流へ伝播
  - request_id：各Hopで新規発行してもよいが、trace_idにぶら下げて紐付ける
- 例外（既存運用）
  - クライアントの `X-Request-ID` を採用する運用はあるが、信頼境界が崩れやすい
  - 対応方針は「採用するならサーバ側で正規化し、内部IDを別名で必ず付与する」

### 3) 伝播の規約（ヘッダ/メタデータ）
- HTTP（同期）
  - W3C Trace Context：`traceparent` / `tracestate`
  - 互換枠：`X-Request-ID`（内部用）、`X-Correlation-ID`（運用用）
- WebSocket / SSE
  - 接続確立時のHTTP handshakeで trace_id を決定し、その後のメッセージに “connection_id + trace_id” を紐付ける
- Queue/Job（非同期）
  - メッセージ属性（headers/properties）に `trace_id`, `parent_span_id`, `request_id`, `message_id`, `job_id` を持たせる
  - “再試行”や“DLQ”でも trace_id が維持される設計にする（運用上の追跡に直結）

---

## 監査ログ（Audit）設計：相関IDだけでは足りない“誰が何をしたか”
### 1) 監査ログの目的を固定する（一般ログと分ける）
- 一般ログ（運用/デバッグ）：障害調査、性能、エラーの原因
- 監査ログ（証跡/否認防止）：重要操作の説明責任（誰が/いつ/どこで/何を/どれに/許可or拒否）

監査ログは「量」より「意味」が重要。重要操作の判定点に近いところ（Policy/Service層）で記録する。

### 2) 監査ログの最小フィールド（実務で揉めないための固定）
- 相関
  - trace_id / request_id / span_id
- 主体と境界
  - actor_type（user/service/job）
  - actor_id（user_id / client_id / service_account）
  - on_behalf_of（代理実行なら依頼者）
  - tenant_id / org_id（マルチテナントは必須）
  - session_id（あれば）/ device_id（あれば）/ auth_context（amr/acr/auth_time 等）
- 操作と対象
  - action（例：grant_role / disable_mfa / create_webhook / approve_payment）
  - object_type / object_id（例：invoice:123 / project:abc）
  - decision（allow/deny）と reason（ポリシー名・ルールID・評価結果の要約）
- ネットワーク/クライアント
  - source_ip（信頼できる境界で確定）、user_agent、origin/referer（取得できる範囲）
- 結果
  - status（HTTPステータス/業務結果）、error_code、latency_ms

---

## 機微情報の取り扱い（ログが情報漏えいにならない設計）
### 1) “ログに入れてはいけないもの”を先に決める
- 認証秘密
  - パスワード、MFAシード/回復コード、秘密鍵、セッション秘密、CSRF秘密
- トークン類
  - Authorizationヘッダの生値、Refresh token、ID token/Access tokenの完全値（原則）
- 個人情報/機微データ
  - 必要最小限を超えるPII（住所、氏名、電話など）
  - 決済情報（PAN等）

### 2) それでも必要な場合の“代替”を用意する
- トークンはハッシュ（先頭数文字＋hash）やJTI（識別子）をログ化し、完全値は残さない
- メール等は正規化（例：ドメインは残すがローカル部はマスク）など、用途に応じて段階を定義
- リクエストボディは原則ログ化せず、必要時はサンプリング＋フィールド単位マスキング

---

## ログ注入・ログ偽装の境界（証跡を壊す攻撃を前提にする）
- 文字列に改行や制御文字が混ざると、構造ログが壊れ「別イベント」に見える（監査が崩れる）
- 対応の方向性
  - 構造ログ（JSON等）で出し、入力値はエスケープ/正規化して格納する
  - ヘッダ/クエリ/フォーム入力の “そのまま出力” を避ける（特にUser-Agent/Referer/Origin/filename）
  - 監査ログでは、ユーザ入力を直接フィールドに置かず、別フィールドに隔離して長さ制限・正規化する

（接続先：`05_input_20_crlf_injection_*` と合わせて、ログ破壊を“攻撃者視点で利用”に繋げる）

---

## 観測ポイント（診断で“相関できる/できない”を状態として確定する）
### 1) Hop別に見る（Browser→Edge→BFF→API→Job）
- Browser
  - レスポンスヘッダで request_id / trace_id を返しているか（問い合わせ・運用に直結）
  - フロント計測（エラー/操作イベント）が trace_id と結び付くか
- Edge（CDN/WAF/LB/Ingress）
  - 入口で trace_id を発行しているか、下流へ伝播しているか
  - 入口で受けた `X-Request-ID` 等を“そのまま信じていないか”（自己申告の混入）
- BFF/API
  - 受け取った traceparent を引き継ぐか、別IDへ置換するか（置換するなら対応関係がログで残るか）
  - 認可判定点で decision が trace_id と一緒に記録されるか
- Job/Queue
  - メッセージに trace_id が積まれ、ワーカーがそれを採用してログ/監査に残すか

### 2) 重要イベントの観測（“監査が必要なもの”が記録されるか）
- 認証
  - login success/failure、MFA challenge/verify、recovery、logout、token refresh/revoke
- 認可
  - deny のログ（理由付き）が残るか（denyが残らないと検知が弱い）
- 高影響操作
  - 権限付与、設定変更、連携追加、支払い/承認、データエクスポート
- 異常
  - rate-limit、CSRF、入力検証失敗、WAFブロック、予期せぬリダイレクト/エラー連鎖

### 3) 証跡の完全性（運用面の観測）
- ログ配送の欠損（バッファあふれ、ネットワーク断）を検知できるか
- 時刻が揃っているか（サービス間で秒単位のズレがあると相関が崩れる）
- アクセス制御（誰がログを見られるか）と改ざん防止（WORM/権限分離）の前提があるか

---

## 結果の意味（状態分類）：どこが壊れているかを短時間で言えるようにする
### 状態A：相関IDが全Hopに一貫している（追跡可能）
- 言えること
  - “ユーザ操作→下流処理→ジョブ”まで追えるため、検知・調査・報告が強い
- 次の一手
  - 監査ログの意味（action/object/decision）が十分か、機微が混入していないか、へ評価を進める

### 状態B：入口はあるが下流で欠落する（伝播欠落）
- 言えること
  - マイクロサービス/非同期で原因究明が崩れる典型。境界は“伝播点”にある
- 次の一手
  - どのHopで欠落するかを特定し、ヘッダ/メタデータの規約とミドルウェア実装を是正する（優先度高）

### 状態C：IDがHopごとに置換され対応関係がない（相関断絶）
- 言えること
  - “置換自体”はあり得るが、対応表（旧→新）がないと証跡が繋がらない
- 次の一手
  - 置換が必要な理由（プロキシ/再発行）を確認し、必ず “parent/linked” としてログに残す設計にする

### 状態D：クライアント自己申告IDを信じている（信頼境界の崩壊）
- 言えること
  - 攻撃者がIDを偽装し、追跡を混乱させたり、他者の事象に見せかける余地がある
- 次の一手
  - 入口で正規化（内部ID付与）し、自己申告は参考値として別フィールドに隔離する

### 状態E：監査ログが不足（相関はあるが“誰が何をしたか”が言えない）
- 言えること
  - トレースがあっても否認に弱い。運用監査・事故対応で困る
- 次の一手
  - 重要操作の判定点で監査ログ（action/object/decision/reason）を追加し、保持・検索要件を定義する

---

## 攻撃者視点での利用（相関/証跡が弱いと“やりやすくなる”）
- 追跡不能化
  - 相関IDが欠落/分断していると、攻撃の連鎖（入口→権限→影響）が繋がらず、封じ込めが遅れる
- ノイズ埋め（大量リクエストで調査不能化）
  - 構造化されていないログ、相関キーが弱いログは検索・集計が破綻しやすい
- ログ偽装/注入
  - 改行や制御文字でログを壊せると、監査や検知ロジックが誤作動する（証跡の信頼性が崩れる）
- 機微混入の悪用
  - ログにトークンや個人情報が混ざると、ログ閲覧権限が事実上の“特権”になり、横展開や情報漏えいの二次被害になる

---

## 次に試すこと（仮説A/B：原因が違うと次の手が変わる）
### 仮説A：相関IDの“伝播”が問題（欠落/置換/非同期で消える）
- 次の一手
  1) 入口で trace_id を発行しているか（Edge/BFF）
  2) HTTPヘッダ（traceparent等）が下流へ渡っているか（Hopごとに観測）
  3) Queue/Jobのメタデータに trace_id が積まれているか（投入/実行の双方）
  4) 置換があるなら、parent/linked をログに残す設計へ是正

### 仮説B：記録の“意味”が問題（誰が/何を/許可or拒否が残らない）
- 次の一手
  1) 重要操作の一覧を作り、監査ログを「判定点」で出す（UI層ではなくService/Policy寄り）
  2) principal/tenant/action/object/decision/reason を最小セットとして固定
  3) deny（拒否）も必ず残す（攻撃・誤設定の検知に直結）
  4) 監査ログの保持・改ざん耐性・アクセス制御を運用要件に落とす

### 仮説C：証跡の“完全性”が問題（欠損/時刻ずれ/改ざん余地）
- 次の一手
  1) 時刻同期（NTP/UTC）とタイムスタンプ形式を統一
  2) 集約先を一元化し、書き込み権限と閲覧権限を分離
  3) 欠損検知（配送失敗、遅延、バッファ溢れ）をメトリクス化
  4) WORM/署名/改ざん検知など、証跡としての要件を明文化

---

## 04_labs（手を動かす：相関が“繋がる/切れる”を再現して腹落ちさせる）
- Lab候補（例）
  - `04_labs/02_web/11_logging_tracing_01_request_trace_propagation_hops/`
  - `04_labs/02_web/11_logging_tracing_02_async_job_context_linking/`
  - `04_labs/02_web/11_logging_tracing_03_audit_log_minset_and_redaction/`
- Lab設計要件（手順書ではなく設計）
  - 2〜3サービス（BFF/API/Worker）＋Queueを用意し、入口からジョブ完了まで trace_id が維持される/されないを切替可能にする
  - 観測点：HTTPヘッダ、メッセージ属性、構造ログ、監査ログ、相関キー（trace_id/request_id/message_id）
  - 巻き戻し：スナップショット/リセットで状態を戻せる（欠損・遅延・再試行も再現する）
  - 成功条件：
    - “どこで相関が切れると何が言えなくなるか”
    - “監査ログが不足すると何が説明できないか”
    を、ログとIDの差分だけで説明できる

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# 目標：
# - 1つのユーザ操作が、複数サービス/ジョブに跨っても trace_id で追える
# - 重要操作は、auditログで actor/tenant/action/object/decision が追える
# - ログに token/PII を混入させず、注入で壊れない（構造ログ＋正規化）

# 推奨の“ログ1行に必ず入れる”最小セット（例）
# - ts, level, service, env
# - trace_id, span_id, request_id
# - principal(user/service/job), tenant_id
# - http.method, http.path, http.status, latency_ms
# - decision(allow/deny) は重要操作/認可判定点で必ず
~~~~

---

## 深掘りリンク（最大8）
- `01_topics/02_web/10_authn_to_authz_接続（claims_権限伝播）.md`
- `01_topics/02_web/04_api_01_権限伝播モデル（フロント_バックエンド_ジョブ）.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `01_topics/02_web/05_input_20_crlf_injection_01_response_splitting（header_body）.md`
- `01_topics/02_web/05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `01_topics/02_web/06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
- `01_topics/02_web/02_authn_02_session_lifecycle（更新_失効_固定化_ローテーション）.md`
- `01_topics/02_web/03_authz_06_privileged_action_重要操作（承認_送金_権限）.md`
