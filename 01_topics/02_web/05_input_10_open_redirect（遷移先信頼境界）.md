## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - この技術で満たす/破れる点：
    - 典型（ASVS v4系でよく参照される要求）：URLのリダイレクト/フォワードは allowlist または警告（ユーザに制御外遷移を知らせて中止可能に）を要求する、という要件群。
    - ASVS v5系（草案含む議論の要旨）：(1) 外部ホスト/ドメインへの自動リダイレクトは allowlist、(2) アプリ制御外への遷移時は通知＋キャンセル、という整理が強い（“成立させない”と“成立しても安全に扱う”の二段）。  
    - OAuth/OIDCの redirect URI：認可サーバ側で「クライアントごとの事前登録 allowlist」「完全一致」で検証する（“前提としての境界条件”だが、Open Redirectがあるとここを崩しやすい／逆にここが堅いと影響を限定しやすい）。
  - 支える前提：
    - Open Redirectは「入力→実行境界」というより「入力→遷移（ブラウザの行動）境界」であり、入力バリデーションの問題である。
    - 影響は“フィッシング”で終わらない。認証フロー・トークン・Referer・SSO/決済/パスワードリセット等の“高価値画面”と結び付いた瞬間に、リスクが跳ね上がる。
- WSTG：
  - 該当テスト観点：
    - Client-side URL Redirect（open redirection：WSTG-CLNT-04）  
    - さらに実務では、サーバサイド（Locationヘッダ）も同じ発想で扱い「遷移先がユーザ入力で決まる注入点」を洗い出して検証する（WSTGの“入力点の特定→遷移先の評価→制御/回避の有無”の流れを流用）。
  - どの観測に対応するか：
    - 遷移が自動か（JS/3xx/Meta Refresh）・遷移先が外部か・警告/中止があるか・正規化/デコード/URLパース差分で回避できるか、を観測して成立を確定する。
- PTES：
  - 該当フェーズ：
    - Information Gathering：リダイレクトパラメータ（next/return/url/continue/dest 等）の列挙、認証/決済/招待/管理導線の把握
    - Vulnerability Analysis：遷移先の制約（相対のみ/allowlist/プレフィックス/正規表現/ID参照）をモデル化、回避可否を差分で立証
    - Exploitation：影響の最大化は“現実の導線”に寄せる（メールリンク、SSO戻り、パスワードリセット、招待リンク、決済戻り）※過度な悪用手順ではなく、成立条件と影響範囲の確定を目的にする
    - Reporting：被害シナリオ（ユーザ視点）＋技術根拠（Location/JS/レスポンス差分/ログ）＋設計改善（allowlist/中間ページ/サーバ保持）をセットで提示
- MITRE ATT&CK：
  - 戦術：Initial Access / Credential Access / Collection
  - 代表的な接続：
    - Phishing（誘導に“正規ドメイン”を使える）→認証情報/セッション/二次要素の回収や、認証フローの攪乱に繋がる。
    - ただし“Open Redirect単体＝即侵害”ではない。周辺（SSO/トークン/Referer/同一サイト制約/ログ）と結び付けて攻撃面を確定する。

## タイトル
open_redirect（遷移先信頼境界）

## 目的
- 「遷移先がユーザ入力で決まる」設計を、攻撃者視点で“成立根拠（差分）”まで確定し、影響範囲（フィッシング止まりか／認証・トークン・権限回りに波及するか）を切り分けられるようにする。
- 併せて、実装・設計・運用（ログ/監視/UX）で“成立しない状態”へ戻すための判断材料（どこで止めるべきか）を提供する。

## これは何か（脆弱性の核）
- Open Redirect（CWE-601）は「リダイレクト先URL（またはそれに等価な値）をユーザ入力として受け取り、十分な検証なしに遷移させる」ことで発生する。
- “遷移”には複数の実装形態がある（どれでも成立する）：
  - サーバサイド：HTTP 3xx + Location
  - クライアントサイド：window.location / location.href / location.assign / SPA router のpush
  - HTML：meta refresh、aタグの自動クリック、フォーム自動submit（間接的に遷移）
- 本質は「ユーザが信頼するドメイン（正規のURL）を踏み台にして、攻撃者の制御する遷移先へ到達させられる」こと。

## 境界モデル（何が信頼境界か）
### 1) 主体と資産
- 主体：
  - 被害者ユーザ（ブラウザ）
  - アプリ（フロント/バック）
  - 遷移先（外部サイト、別サブドメイン、同一オリジン配下の別アプリ、CDN/静的ホスト）
  - IdP/認可サーバ（OAuth/OIDC/SAMLが絡む場合）
- 守りたい資産：
  - 認証情報（資格情報・回復コード・二要素の承認）
  - セッション/トークン（Cookie、URLパラメータ、フラグメント、localStorage）
  - 操作の意図（ユーザが「どこへ遷移するつもりだったか」）
  - アプリの信頼（正規ドメインを用いた誘導による信用毀損）

### 2) データフロー（入力→遷移）
- 典型：
  - GET /login?next=... → 認証後に next にリダイレクト
  - GET /redirect?url=... → 指定URLへ 302
  - GET /out?to=... → 広告/外部リンク計測 → 外部へ 302
  - #hash や ?query を JS が読み取り window.location に代入（SPAで多い）

### 3) 信頼境界（どこで“危険”になるか）
- 危険境界A：ユーザ入力（next/url/return など）が“絶対URL/外部ホスト”として扱われる瞬間
- 危険境界B：入力が“相対パス扱いのつもり”でも、正規化/デコード/URLパーサ差分で外部扱いに化ける瞬間
- 危険境界C：外部遷移が仕様上必要でも、「警告・中止・表示（中間ページ）」なしで自動遷移する瞬間
- 危険境界D：認証・決済・招待・回復など“高価値導線”に結び付いている瞬間（影響が跳ねる）

## ありがちな注入点（見つけ方：実務）
### 1) パラメータ名（入口）
- next / return / return_to / continue / url / redirect / redirect_url / redirect_uri（※OAuthのredirect_uriとは意味が違う場合もある）
- dest / destination / target / goto / out / forward / callback / back / r / u / to
- SPA：location.hash / state（history）/ router query

### 2) 画面/機能（現場で刺さる導線）
- ログイン/ログアウト後の戻り先
- パスワードリセット完了後の遷移
- 招待リンク承諾後の遷移（社内/テナント境界に絡む）
- 決済（3DS/外部決済）戻り
- 管理画面：外部ドキュメント/サポート誘導/監査画面リンク
- “外部へ出る”機能（広告、短縮URL、トラッキング、PDFプレビュー、Webhookのテストリンク等）

## 成立条件（差分＝成立根拠）
ここが薄いと「Open Redirectっぽい」止まりになる。差分で“成立”を確定する。

### 1) 遷移が「入力で決まる」差分
- 入力A：next=/account（期待：内部へ遷移）
- 入力B：next=https://attacker.example/（期待：外部へは遷移しない or 警告）
- 観測：
  - Locationヘッダが外部になっている（サーバサイド）
  - JSが外部へ遷移している（client-side）
  - 中間ページ/警告が出るか（“仕様として外部遷移する”場合の必須要件）

### 2) 制約がある場合の「回避」差分（成立根拠の本命）
実装者はだいたい何かしらの制約を入れる。弱い制約ほど回避できる。

- (a) プレフィックス/startsWith 系
  - 例：if (next.startsWith("/")) allow; else deny
  - 回避の発想：正規化で“/始まりに見せる”または“ブラウザ解釈で外部化”
- (b) “同一ホスト”判定のつもり（urlparse/netloc等）
  - 回避の発想：アプリ側パーサとブラウザ/プロキシの解釈差（URL parser differential）
- (c) 正規表現 allow（例：^/[\w/]+$）
  - 回避の発想：エンコード/デコード順序差、二重デコード、Unicode、バックスラッシュ扱い
- (d) allowlist（強いが運用で崩れやすい）
  - 回避の発想：allowlist項目の過剰一般化（*.example.com や部分一致）／サブドメイン乗っ取り／同居推定での混線

“回避まで立証できる”と、単なる指摘ではなく「防御の再設計」が提案できる。

## 代表的な回避パターン（攻撃者が狙うズレ）
※ここは“実装の穴の種類”を理解するため。実際の検証では、最小の試行で差分が出る組だけを選ぶ。

### 1) scheme-relative / 多重スラッシュ
- //evil.example はブラウザが「現在のスキーム＋evil.example」扱いすることがある。
- “/で始まるから安全”という判定は、この系統で崩れる可能性がある（実装依存）。

### 2) バックスラッシュ、エンコード、混在
- \ を / と同等に解釈する実装・ミドルウェアがある。
- %2f や %5c（/ や \）が、どの層でデコードされるかで解釈が変わる。

### 3) ユーザ情報（userinfo）や @ の扱い
- https://trusted.example@evil.example/ のように、見た目と実際のホストがズレる表現がある。
- “文字列 contains trusted.example” のような判定は危険。

### 4) パーサ差分（URL parser differential）
- アプリ側が「相対URLで安全」と判断しても、ブラウザが外部URLとして解釈する例が現実にある。
- これが起きると「サーバ側のバリデーションは通るのに、ユーザは外へ飛ぶ」という最悪の状態になる。

## 影響の棚卸し（“フィッシング止まり”で終わらない条件）
### 1) フィッシング/信用悪用（基本）
- 正規ドメインで誘導できるので、被害者は警戒しにくい。
- ただし、これだけだと組織によっては「低〜中」と評価されることがある。

### 2) 認証フロー（SSO/OAuth/OIDC）と結び付くと重くなる
- “戻り先”がOpen Redirectだと、認証直後の導線を攻撃者が握れる。
- 特に次の条件が揃うと危険度が上がる：
  - 認証コード/トークンがURLに載る（クエリ/フラグメント）
  - Referer が外部へ漏れる（遷移方法・Referrer-Policy次第）
  - 画面上に“自動遷移”がありユーザ操作が介在しない

### 3) アクセス制御回避（forward系の亜種）
- “redirect”ではなく“forward”（サーバ内部で別ハンドラに転送）に近い実装だと、認可チェックの境界を飛び越えることがある。
- 例：/go?path=/admin を内部転送してしまう、など。
- この場合は「Open Redirect」というより「認可境界（03_authz）」として重大化する。

### 4) 他脆弱性の踏み台（連鎖）
- SSRFのallowlist回避：
  - SSRF対策が「example.com のみ許可」などの場合、example.com のOpen Redirectを踏ませると、実質的に外部へ到達できる（サーバがリダイレクト追従する実装だと成立）。
- WAF/Link scanner の挙動差：
  - 一部のスキャナはリダイレクト追従や正規化が本物ブラウザと異なる。差分が攻撃者の“すり抜け”になる。

## 検証手順（意味→判断→次の一手）
### フェーズ0：安全な検証方針（最低限）
- 外部ドメインに“実害のあるURL”を置かない。検証は自分が管理する無害な到達先（自ドメインの受け口等）で行い、遷移・ヘッダ・ログの差分を取る。
- 自動スキャンで大量リクエストを投げるより、代表注入点×代表回避パターンの少数で確定する（ログ汚染/誤検知/DoSを避ける）。

### フェーズ1：注入点の特定（どこで遷移先が決まるか）
- 画面操作で “戻る/続行/外部へ” の導線を全部踏む（ログイン、ログアウト、リセット完了、招待、決済、ヘルプ、外部リンク、トラッキング）。
- それぞれで以下を観測：
  - サーバ：3xx + Location、Refreshヘッダ、HTML meta refresh
  - クライアント：window.location 操作、router push、アンカーのhref生成

### フェーズ2：制約の推定（どの種類の防御か）
- 入力を3種類に分けて試す（差分で“判定式”を推定する）：
  - 相対パス：/account
  - 絶対URL：https://example.test/
  - 変形URL：//example.test/、%2f%2fexample.test/、\example.test\ など
- 観測結果から分類：
  - 相対のみ通る → 相対パス制約（ただし回避の余地あり）
  - 特定ホストのみ通る → allowlist/ドメイン制約
  - 文字列を少し変えるだけで通る/落ちる → startsWith/contains/正規表現の可能性
  - デコード順で挙動が変わる → 正規化バグの可能性

### フェーズ3：成立の確定（“回避”の立証）
- “1回で刺す”より、「同一注入点で入力だけを変え、Location/JSの差分を証拠化」する。
- 立証の観点（最低限）：
  - (1) 外部に遷移できる（Open Redirectの成立）
  - (2) その遷移がユーザに警告・確認なしで実行される（ASVS観点での弱さ）
  - (3) もし制約があるなら、正規化/パース差分で回避できる（設計欠陥の根拠）

### フェーズ4：影響の最大化（現実導線に寄せる）
- “攻撃手順”ではなく、“影響範囲の確定”として次を確認する：
  - 認証直後/重要操作直後に同注入点が使われているか（return_to など）
  - URLに機微（token, code, state, email等）が載る設計になっていないか
  - 遷移方法がReferer漏えいを誘発しうるか（Referrer-Policy、302→GET、外部遷移の有無）
  - 他の脆弱性（SSRF、XSS、キャッシュ、OAuthクライアント）と“連鎖可能な形”か

## リクエスト/レスポンスの証拠例（最小）
~~~~
GET /redirect?next=https://example.test/ HTTP/1.1
Host: victim.example
~~~~

~~~~
HTTP/1.1 302 Found
Location: https://example.test/
Cache-Control: no-store
~~~~

- この2点が揃うと「入力→Location」の直結が強く疑われる。
- ただし “制約がある/ない” “警告がある/ない” “正規化の回避がある/ない” を差分で詰めるのが報告品質を決める。

## 実装レビュー観点（なぜ起きるか：設計/実装の罠）
### 1) “URLそのもの”を受け取っている
- redirect(url) / res.redirect(next) / Response.Redirect(url) の引数にユーザ入力が直入れになっている。
- 対策の基本は「URLを受け取らない」。受け取るなら allowlist or 中間ページ。

### 2) “相対のみ”のつもりが、パース差分で外部化
- アプリがURLパースして netloc/host を見て安全判定 → ブラウザは別解釈で外へ飛ぶ、が最悪。
- URL正規化の責務（どの層で decode/normalize するか）を設計として固定しないと、対策が揺れる。

### 3) allowlistの運用崩壊
- allowlistが「*.example.com」「example.com を含む」など、広すぎる。
- サブドメイン乗っ取り/同居/外部SaaS導入で、allowlistが“攻撃者に管理される場所”を含むようになる。

## 防御（設計として“成立しない”に戻す）
### レベル1：最優先（強い）
- 外部遷移を設計上なくす：
  - return_to は「相対パスのみ」＋「サーバ側でセッションに保持（nonceキー）」にする。
  - つまり「クライアントからURLを渡さない」。渡すのはID（例：return_id）だけにする。

### レベル2：外部遷移が必要な場合（現実解）
- allowlist（完全一致）で外部ホスト/パスを限定する。
- 中間ページ（警告＋遷移先表示＋キャンセル）を入れる：
  - “自動遷移”をやめる（UXは落ちるが、セキュリティ要求として通りやすい）。
- リンク計測（out/redirect）は「外部URLを直接持たず、サーバ側でID→URL引き当て」に寄せる（運用が強い）。

### レベル3：実装の補強（バイパス耐性）
- URL正規化の手順を固定：
  - decode回数、Unicode正規化、スキーム/ホスト/ポートの解釈、相対URLの解釈、をライブラリで統一。
- “文字列判定”をやめる：
  - startsWith/contains は危険。パースして構造（scheme/host/path）で判定する。
- OAuth/OIDC：
  - redirect_uri は事前登録の完全一致（認可サーバ側で強制）。
  - クライアント側の “戻り先” と混同しない（別の入力点として検証/対策する）。

## 監視・検知（運用で落とす）
- リダイレクト系エンドポイントのログを整備（ただし個人情報/機微はマスキング）：
  - どのパラメータで遷移先が決まったか（next/url等）
  - 判定結果（allowlist hit / warn / block）
  - trace_id（後追いできるように）
- 検知の着眼点（例）：
  - 外部ホストへの遷移が急増
  - パラメータに “://” “//” “%2f%2f” “@” 等が多発
  - 同一IP/UAが多様な変形URLを試す（探索フェーズの兆候）

## すぐ使えるチェックリスト（短縮版）
- [ ] 遷移先がユーザ入力で決まる注入点を列挙した（next/url/return 等）
- [ ] サーバサイド（Location）かクライアントサイド（window.location等）か切り分けた
- [ ] 外部へ自動遷移できるか（警告/中止の有無含む）を差分で確定した
- [ ] “相対のみ/allowlist/プレフィックス/正規表現”のどれで守っているか推定した
- [ ] 正規化/パース差分で回避できるか（成立根拠）を確認した
- [ ] 認証/回復/決済/招待など高価値導線に結び付くかで影響を評価した
- [ ] 推奨対策を「URLを受け取らない（ID化/サーバ保持）」へ寄せて提案できる

## 深掘りリンク（最大8）
- ./02_authn_04_sso_oidc_flow観測（state_nonce_code_PKCE）.md
- ./02_authn_10_password_reset_回復経路（token_失効_多要素）.md
- ./03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md
- ./05_input_09_ssrf_01_reachability（internal_localhost_metadata）.md
- ./05_input_06_xss_03_DOM_境界モデル.md
- ./06_config_03_セキュリティヘッダ（CSP_HSTS_Frame_Referrer）.md
- ../04_labs/01_local/02_proxy_計測・改変ポイント設計.md
- ../02_playbooks/02_web_recon_入口→境界→検証方針.md
