## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）

- ASVS
  - 認可（AuthZ）：マルチテナント/組織境界/オブジェクト境界を「行」ではなく **グラフ探索（ノード・関係・パス）** で強制できているか
  - 設計：スコープ（tenant/org/owner）を **クエリの最外周で固定** し、入力や探索条件によって揺らがないこと
  - 返却縮退：探索結果（path, nodes, relationships）をそのまま返さず、必要最小限へ縮退（DTO化）
  - 可用性：探索深さ・分岐数・結果件数・期間の上限、タイムアウト、レート制限の設計
  - 監査：探索APIの実行者・対象スコープ・深さ・ヒット数を相関し、異常探索を検知できるか
- WSTG
  - Authorization testing：IDOR/BOLA と異なる「探索で越境」する形（graph traversal）をテスト観点に入れる
  - Input/Logic：入力が探索深さや探索対象ラベルを広げられる場合、Injectionでなくても越境の成立点になる
- PTES
  - 情報収集→脆弱性分析：グラフ機能（関連/おすすめ/可視化/監査）を入口に、スコープの破れを差分で確定
  - 侵入→影響実証：大量抽出は避け、越境混入の成立根拠（1〜数件）を証拠化
  - 報告：原因を「スコープ固定不備」「返却縮退不足」「探索制限不備」「権限モデル混同」に分解して提案
- MITRE ATT&CK
  - TA0009 Collection：グラフ探索は関係性情報の収集に強い
  - TA0007 Discovery：内部関係の発見（組織/権限/関係）に繋がる
  - 入口は公開アプリならT1190に接続

---

## タイトル
Neo4j 認可：graph_traversal_scope（探索で越境しないスコープ強制）

## 目的（この技術で到達する状態）
- Neo4j を利用する機能において、Injectionの有無に関わらず起きる「探索で越境」を、
  1) スコープ（tenant/org/owner）の定義  
  2) 探索（トラバーサル）での破れ方  
  3) 返却縮退と可用性制限の設計  
  4) 検証の取り方（差分＝成立根拠）  
  に落として、実務で再現・評価・修正提案できる状態になる。

## 前提（対象・範囲・想定）
- 対象
  - 関連ノード表示（related）、おすすめ（recommendation）、共通点、関係グラフ可視化、権限グラフ、監査グラフ
  - “パス（path）” “関係（relationship）” “深さ（depth）” の概念が出る機能
- 想定する権限モデル
  - アプリ権限：ユーザ→ロール→テナント/組織/プロジェクトなど
  - DB（Neo4j）権限：DBユーザ/ロール（これはアプリ権限と別物。混同が事故る）
- 本ファイルの焦点
  - graph_traversal_scope：探索でスコープが漏れる設計問題（BOLA/BFLAのグラフ版）
- 非スコープ
  - Cypher injection（構文注入）：別ファイル
  - APOC（外部到達/動的実行）：別ファイル

## スコープの定義（まず“境界”を言語化する）
- 何を守る境界か（例）
  - tenant：顧客/契約単位（最上位境界）
  - org/project：同一tenant内の組織/プロジェクト境界
  - owner：ユーザ本人に紐づくデータ境界
- グラフで境界が難しい理由
  - 関係（edge）が境界を跨いで張られていると、探索で自然に越境する
  - 「ノードのtenant_id」だけではなく、「関係の意味（relation type）」も境界になる
- 重要原則
  - “探索を許す”場合は、**探索可能なラベル/関係/深さ** を仕様として固定する必要がある  
    （自由探索＝実質的に内部探索APIの提供になる）

## 典型的な破れ方（Injectionがなくても起きる）
> ここを押さえると、SQL的なIDOR検査だけでは見落とさなくなる。

### 1) スコープ固定が「入口ノード」だけに掛かっている（途中で越境）
- 例（概念）
  - STARTは自分のtenantのノードだが、隣接ノードが別tenantに繋がっていて、探索で到達する
- 原因
  - “到達したノードにもtenant条件を適用する” という当たり前が抜けがち
- 証拠の取り方
  - 同一操作で、返却に別tenantの特徴（識別子・名称）が混ざるか（1件で十分）

### 2) 探索ラベル/関係種別が入力で広がる（語彙の委譲）
- 例（概念）
  - `type=...` `label=...` `relation=...` を入力で渡せる
- 原因
  - 柔軟な検索要件のために「語彙（ラベル/関係）」をユーザに委譲している
- 証拠の取り方
  - 入力の選択肢が増えると、探索対象が増え、返却構造/件数が不自然に増える

### 3) 深さ（depth）や可変長パスが入力で増やせる（面積の爆発）
- 例（概念）
  - `depth=1..N` のような指定、または“詳細モード”で深さが増える
- 原因
  - 深さ上限が仕様化されていない、または内部用の上限が外部に露出
- 証拠の取り方
  - 深さを上げるほど返却ノード数が急増する（ただし負荷をかけない範囲で観測）

### 4) 返却縮退がなく、path全体を返す（情報露出の増幅）
- 例（概念）
  - nodes + relationships を丸ごと返す、propertiesが過剰
- 原因
  - “グラフを表示する”ことを優先し、DTO/view modelがない
- 証拠の取り方
  - レスポンスに不要なプロパティ（メール、内部ID、ロール等）が含まれる

### 5) スコープ境界を“アプリ側後処理”で担保している（漏れやすい）
- 例（概念）
  - 取得後にフィルタする設計（DBは広く取り、アプリで絞る）
- 原因
  - 早期最適化や実装都合で “まず取る” になっている
- 証拠の取り方
  - 返却前フィルタ漏れが起きる条件（特定モード/例外/エラー時）で混入が出る

## 正しい設計の要点（“探索でも揺れない”ために）

### 1) スコープ制約はクエリの“最外周”で強制（到達ノードにも適用）
- 原則
  - 入口ノードだけでなく、探索で到達するノードも同一スコープで制約する
- 実装戦略（概念）
  - tenant/org/owner の条件を、探索パターン全体に適用する（途中で消えない位置へ）

### 2) 探索語彙（ラベル/関係種別）はallowlistで固定
- 入力に渡させないもの
  - 任意ラベル、任意関係種別、任意プロパティ名
- 渡させる場合の条件
  - UI選択肢→サーバ側マッピング→固定語彙へ変換（allowlist）

### 3) 探索深さ・分岐・件数の上限を仕様化（可用性と情報露出）
- 深さ上限（max depth）
- 結果件数上限（limit）
- 分岐上限（隣接数制限、重い探索の禁止）
- タイムアウト、レート制限、ジョブキュー化（重い可視化は非同期）

### 4) 返却縮退（DTO/view model）を徹底
- グラフの内部表現（path/nodes/relationships）をそのまま返さない
- “表示に必要な最小情報”だけ返す（ID、ラベル、表示名、最小属性）
- 管理者向けの詳細返却は別API・強い認可・監査で分離

### 5) 権限伝播の整理（アプリ権限とDB権限を混同しない）
- DBユーザ権限は “アプリの入口の強さ” に依存して変える
  - 一般ユーザ経路で使うDBユーザは最小権限
  - 管理/運用は別ユーザ/別経路で分離
- 目的
  - アプリ側に穴があっても、DB側で被害を局限する

## 検証方法（差分＝成立根拠：実務で安全に）

### 1) 役割/テナント差分での期待値を固定する
- テナントAのユーザ vs テナントBのユーザ
- 同一tenant内のロール差分（一般 vs 管理）
- 期待：越境しない、ロールに応じて許可範囲だけ変わる

### 2) “探索の入口”を3種類に分けて見る
- 入口1：検索（キーワード）
- 入口2：関連表示（あるIDを起点）
- 入口3：推薦（内部ロジック）
- それぞれで、同じスコープ制約が強制されているかを見る（入口ごとに実装が違って漏れが出る）

### 3) 観測指標（oracle）
- Boolean（主）
  - 返却ノード数、関係数、件数、レスポンス長
  - “別tenant由来の識別子/名称”の混入（1件で成立根拠になる）
- Error（補助）
  - エラーが詳細すぎる場合は情報露出として切り出す（oracle化）
- Time（補助）
  - 重くなる兆候は「上限制約の欠如」として扱い、負荷検証は避ける

## よくある“事故のパターン”と修正案テンプレ

### 事故A：related APIで越境する（入口2だけ漏れる）
- 原因
  - related表示は別チーム/別実装で、tenant filterが抜けた
- 修正案
  - 共通のスコープ強制（ミドル/共通関数）で付与し、入口ごとの差をなくす
  - 返却縮退で被害面積を小さくする

### 事故B：graph可視化でpathを丸返し（情報露出増幅）
- 原因
  - フロント描画都合で内部表現を返した
- 修正案
  - DTO化（必要最小限のノード情報＋関係種別のみ）
  - 深さ上限、結果上限、非同期化

### 事故C：入力でラベル/関係種別を選べる（語彙の委譲）
- 原因
  - 柔軟検索要件により“内部語彙”を外部へ出した
- 修正案
  - allowlist化（UI選択肢→内部語彙へマップ）
  - 未許可語彙は統一エラーで拒否

### 事故D：アプリ後処理フィルタに依存（例外時に漏れる）
- 原因
  - DBは広く取り、アプリで絞る設計
- 修正案
  - DBクエリ段階でスコープを強制（“先に絞る”）
  - 例外/エラー経路も同じポリシーで統制

## 手を動かす検証（Labs連動：graph_traversal_scopeの再現）
- 目的：同じ探索UI/APIを、(1)スコープ強制あり と (2)なし で比較し、越境混入の成立根拠を取る
- 最小構成（推奨）
  - (1) 正常：全ノードに tenant_id を持たせ、探索で到達ノードにも tenant一致を強制
  - (2) 異常：入口ノードだけ tenant制約、到達ノードは無制約（越境しやすい）
  - (3) 異常：path丸返し（情報露出増幅）
  - (4) 異常：depth入力で拡大できる（可用性/露出の面積増）
- 証跡
  - HAR：入口1/2/3ごとの baseline と差分
  - アプリログ：trace_id、探索深さ、返却ノード数、スコープ判定結果
  - DBログ（Labsのみ）：クエリテンプレID、実行時間

## 例（最小限：設計思想の固定）
~~~~
# 原則（概念）
# - tenant/org/owner の制約は探索全体に適用（入口だけでなく到達ノードにも）
# - ラベル/関係種別はallowlist
# - 深さ/件数に上限
# - 返却はDTO化（path丸返し禁止）
~~~~

## 参考（必要最小限）
- Neo4j Operations Manual：Security（ロール、権限、設定）  
  - https://neo4j.com/docs/operations-manual/current/security/
- Neo4j Cypher Manual：Patterns / Path / variable length（探索の特性理解）  
  - https://neo4j.com/docs/cypher-manual/current/
- Neo4j APOC Docs（APOCが探索を増幅し得る前提）  
  - https://neo4j.com/docs/apoc/current/

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/05_input_04_nosql_injection_03_neo4j_cypher_01_query（cypher_injection）.md`
- `01_topics/02_web/05_input_04_nosql_injection_03_neo4j_cypher_02_apoc（procedure_security）.md`

---

## 次（作成候補順）
- `01_topics/02_web/05_input_05_command_injection_01_shell（metachar_pipeline）.md`
