## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：アプリがレスポンスヘッダ（例：Location / Set-Cookie / Content-Disposition / 任意カスタムヘッダ）へ未検証入力を反映し、かつ中継点/クライアントがCRLFを“ヘッダ境界”として解釈すると、ヘッダ改ざん・レスポンス分割・キャッシュ汚染・誤誘導が起きる。実装が安全でも、中継点（CDN/Proxy/WAF）との解釈差で成立する。
  - 満たす：レスポンスヘッダへ反映する値は **CR/LF禁止**（正規化/拒否）を基本とし、フレームワーク/サーバ設定で二重化する。リダイレクト先やファイル名等は allowlist/エンコードで固定し、ヘッダ生成APIを統一して“自作連結”を禁止する。中継点も含めて、ヘッダの不正文字を拒否する一貫設定と監視（ログ/アラート）を持つ。
- WSTG
  - 該当観点：入力が「レスポンスヘッダ構築」に到達するか、到達した際に **(1) アプリ層で拒否されるか**、**(2) 中継点が正規化/拒否するか**、**(3) キャッシュ/ブラウザへどう到達するか** を観測で確定する。単に “%0d%0a が入る” で止めず、「境界が本当に割れるか」を証拠化する。
- PTES
  - 位置づけ：脆弱性分析〜侵害評価。レスポンス分割は第三者影響（キャッシュ/共有プロキシ）を含み得るため、検証は **安全設計（影響半径最小化）** と **観測重視** で行う。多段（CDN→Proxy→Origin）のどこで成立するかを切り分けて所見化する。
- MITRE ATT&CK
  - T1190（公開アプリの脆弱性悪用）に接続し得る。
  - Impact（誤配布/誤誘導/可用性劣化）や Collection（混線による情報露出）に接続し得るが、断定は「分割の成立」と「配布範囲」の証跡が揃ってから行う。

---

## タイトル
CRLF Injection（Response Splitting）：HTTPヘッダ境界（CRLF）を“境界入力”として扱わないと、レスポンスが分割され中継点を巻き込んで壊れる

---

## 目的（このファイルで到達する状態）
- 「CRLFが入る/入らない」の話ではなく、**ヘッダ境界が割れる（Response Splitting）成立根拠** を観測で固める。
  1) どの入力がレスポンスヘッダに反映されるか（到達点）
  2) どの層（Origin/Reverse Proxy/CDN/Browser）がCRLFを境界として解釈するか
  3) “分割”の結果として何が起きるか（ヘッダ追加/ステータス/ボディ混線/キャッシュ格納）
  4) 影響半径（自分だけ/共有キャッシュ/別ユーザ）を境界で説明できる
  5) 修正要求を「入力検証」「生成API統一」「中継点設定」「監視」に落とせる

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：Response Splitting（header/body境界）としてのCRLF注入
  - 反映ポイント（Location、Set-Cookie、Content-Disposition、カスタムヘッダ、ログ相関ヘッダ等）
  - 分割が成立する条件（層・パーサ・正規化）
  - 観測の取り方（証拠の積み上げ）
- 扱わない（接続先へ）
  - Cache Poisoning（配布範囲やキーの詳細）：`05_input_19_cache_poisoning_0x_*.md`
  - Request Smuggling（front/back解釈差の詳細）：`05_input_18_http_request_smuggling_0x_*.md`
  - XSSとしての最終到達（格納/反射/DOM）：`05_input_06_xss_0x_*.md`
  - Open Redirectの入口整理：`05_input_10_open_redirect（遷移先信頼境界）.md`

---

## 境界モデル：CRLFは“ヘッダ境界を決める制御文字”
### 1) HTTP/1.1の境界（最小理解）
- レスポンスは概ね「ステータス行」「ヘッダ群」「空行」「ボディ」からなる。
- ヘッダ行は行区切りで連なるため、CRLFが“行境界”として扱われると **ヘッダの追加/分断** が発生する。
- さらに “ヘッダ群の終端（空行）” に到達できると、以降はボディとして解釈され、**意図しない内容がボディへ混入** し得る。

### 2) 境界が割れると何が起きるか（結果の型）
- 型A：ヘッダ追加（同一レスポンスのヘッダを書き換える）
  - 例：キャッシュ制御、CORS、Cookie、リダイレクト等の“境界ヘッダ”が変更されると影響が大きい
- 型B：レスポンス分割（中継点が“別レスポンスが来た”ように扱う）
  - 後続通信と混線し、別ユーザ/別リクエストへ波及する余地が生まれる（ただし成立は層依存）
- 型C：キャッシュ格納の誤り（Poisoningへの入口）
  - 分割/ヘッダ改ざんで「キャッシュ可能」扱いになり、他者へ配布され得る（影響半径が跳ね上がる）

---

## どこに到達すれば危険か（反映ポイント：実務で見つかる順）
> “入力→ヘッダ反映”が見えたら、すぐに「境界ヘッダか」「中継点がいるか」で優先度が決まる。

### 1) Location（リダイレクト）
- リダイレクト先をユーザ入力で決める設計は多い（ログイン後遷移、return_to等）。
- Locationは“経路/境界”を変えるため、ヘッダ境界が割れると **遷移だけでなくヘッダ群全体** が影響を受け得る。

### 2) Set-Cookie / Cookie属性
- セッション境界に直結（Secure/HttpOnly/SameSite/Domain/Path）。
- ただし多くのフレームワークは防御しているため、「アプリは拒否したが中継点が生成する/上書きする」など層差に注意。

### 3) Content-Disposition（ダウンロード名）
- filename等にユーザ入力が混ざる設計がある。
- ブラウザ/中継点での解釈差が混入しやすく、ヘッダ境界を壊すと“別ヘッダ”の注入経路になる。

### 4) 反射されやすいカスタムヘッダ
- X-Request-Id、X-Trace、X-User 等の“デバッグ系”
- ここは本番でも残りがちで、入力が混ざる設計ミスが起きやすい。

---

## 成立条件（差分＝成立根拠）：どの層が何を拒否/正規化するか
### 前提：Response Splittingは“層の合成”で成立する
- アプリ層が弾いても、手前のミドルウェアがヘッダを組み立てる場合がある。
- 逆に、アプリが通しても、CDN/Proxyが正規化（無害化）して成立しない場合もある。

### 仮説A：Origin（アプリ/サーバ）がヘッダ生成時点で拒否しない
- 観測根拠：レスポンスヘッダが意図せず増減/分断している（“境界が割れた結果”が残る）

### 仮説B：Originは拒否するが、中継点で再解釈/再構築される
- 例：Proxyがエラー/リダイレクト/変換を生成し、その生成元に未検証入力が混ざる
- 観測根拠：Originログでは拒否/不達だが、エッジでヘッダ形状が変わる（層間差）

### 仮説C：HTTP/2/HTTP/1変換境界で不一致が起きる
- H2はヘッダが“行”ではなくフィールドとして扱われるが、H1へ落とす段で正規化が起きる。
- 観測根拠：H2で見えるヘッダと、H1としてエッジ/オリジンが受けるヘッダに差が出る（※別ファイルのH2→H1 desyncと接続）

---

## 観測ポイント（「分割の成立」を証跡化するための最小セット）
> “入った”ではなく、“境界が割れた結果が観測できる”ことが必要。

### 1) レスポンスの形状（最重要）
- ステータスコードが想定から変わるか
- ヘッダが増える/減る/順序が崩れる/同名が複数になるか
- Content-Length / Transfer-Encoding / Connection など“境界系ヘッダ”が不自然になっていないか

### 2) 中継点の関与シグナル
- キャッシュ関与（Age等）や経路情報（Via等）が見える範囲で増減するか
- 1回目/2回目で挙動が変わる（キャッシュ/圧縮/変換が絡む兆候）

### 3) 相関ログ（可能なら強い）
- Origin：受信した入力、レスポンス生成時の例外/拒否ログ
- Proxy/CDN：正規化/拒否ログ、生成レスポンス（エラー/リダイレクト）ログ
- ここがあると「どの層で境界が割れたか」を所見として断定できる

---

## 攻撃者視点での利用（ただし“成立根拠”ベースで評価する）
> ここは攻撃寄りに整理するが、具体手順の過度な提示は避け、評価軸（何が起きると危険か）を固定する。

### 1) ヘッダ改ざん（境界ヘッダの上書き）
- Cache-Control 等が変わる → キャッシュ格納条件が変化し得る（Cache Poisoningへ接続）
- CORS系が変わる → ブラウザ側の許可/拒否が変化し得る（ただし成立は厳密に観測）
- Cookie属性が変わる → セッション境界が変化し得る（ただしアプリ側の実装も同時に要確認）

### 2) レスポンス分割→後続混線
- “別レスポンス”が混入する形になれば、共有プロキシ/キャッシュ経由で第三者影響が発生し得る
- ただしこの系は層依存が強いので、断定は「store/serve/半径」の証跡が揃ってから（Cache Poisoningの流儀）

### 3) 誤誘導・誤配布（実害として強い）
- LocationやHTMLの参照先が変わる → ユーザが“正規の流れ”から外れる
- ここは「誰に配られるか（半径）」で重大性が決まる

---

## 次に試すこと（仮説A/Bで分岐：行動を固定）
### 分岐1：アプリ層で拒否されている（成立しない）場合
- 判断：入力はヘッダ反映点に到達していない、またはフレームワークが制御文字を拒否/正規化している
- 次の一手（現実寄り）
  - “同じ入力が別のヘッダ反映点に行く”経路を探す（ファイル名、return_to、デバッグヘッダ等）
  - エラー経路（400/500/リダイレクト）で同入力が反映されないか観測（中継点生成を疑う）

### 分岐2：ヘッダ形状が変わった（成立兆候）場合
- 判断：境界が割れる可能性がある
- 次の一手（安全重視）
  - どの層で変わったかを切り分け（Origin直/エッジ経由で差を見る）
  - キャッシュ関与（ヒット/ミス、TTL）を確認し、第三者影響の可能性があるなら検証を止めて範囲/合意を取る
  - “影響の型”を確定（ヘッダ追加止まりか、分割・混線の兆候があるか）

### 分岐3：H2/H1境界が疑わしい場合
- 判断：変換境界での正規化不一致が主因の可能性
- 次の一手
  - `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md` と接続し、同一経路での解釈差を“観測”中心で詰める

---

## 04_labs（Response Splittingを“安全に”観測する設計）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/20_crlf_injection_01_response_splitting_header_body/`
- Lab設計（手順書ではなく設計）
  - 構成：Reverse Proxy（正規化ON/OFF切替）→ Origin（ヘッダ反映を持つ簡易アプリ）
  - 反映ポイントを複数用意
    - redirect（Location）
    - download（Content-Disposition）
    - debug header（X-Trace）
  - 観測点
    - proxy：受信/転送したヘッダ（正規化ログ）
    - origin：生成したレスポンス（生ログ）
    - client：実際に届いたヘッダ形状
  - 成功条件
    - 「どの層が」「どの時点で」境界文字を拒否/通過/再構築したかを説明できる
    - 成立する場合は、影響を“型（ヘッダ追加/分割/キャッシュ）”で分類できる

---

## コマンド/例（例示は最小限：観測・判断を優先）
~~~~
# 目的は「境界が割れた結果」を観測で確定すること。
# - 同一入力を (1) Origin直、(2) Edge/CDN経由 で比較して層差を取る
# - レスポンスヘッダの形状（ヘッダ増減、重複、空行、CL/TEなど境界ヘッダ）を記録する
# - 第三者影響が疑われる（共有キャッシュ）場合は、検証を増やさずに証跡と範囲確認へ切り替える
~~~~

---

## 深掘りリンク（最大8）
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- `05_input_18_http_request_smuggling_01_te_cl（proxy_desync）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
- `05_input_06_xss_01_反射_境界モデル.md`
- `06_config_03_セキュリティヘッダ（CSP_HSTS_Frame_Referrer）.md`
