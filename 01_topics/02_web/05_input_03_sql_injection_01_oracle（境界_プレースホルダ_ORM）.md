## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - この技術で満たす/破れる点：SQLiは「入力→DB実行」の境界破壊。対策は(1)バインド徹底（値）、(2)識別子/構文のallowlist固定（列名/方向/関数）、(3)エラーモデル統一（差分＝オラクルの抑制）、(4)最小権限（DBユーザ/スキーマ/パッケージ実行権限）、(5)監査（遅延・例外・失敗頻度の相関）で成立/影響を潰す。
  - 支える前提：Oracleはエラーコード（ORA-xxxx）やPL/SQL例外、暗黙変換（NLS）、パッケージ実行権限の有無が“差分（oracle）”として観測されやすい。従って「どの差分が成立根拠か」を先に固定しないと、検証がブレて過剰試行になりやすい。
- WSTG：
  - 該当テスト観点：Injection（SQLi）、Error Handling（ORA/PLSQL例外の露出・統一）、Authorization（SQL改変による越境混入/存在オラクル）、Business Logic（検索/ソート/集計/状態遷移との組合せ）、Logging（検知・監査）。
  - どの観測に対応するか：Oracle特有の(1)エラー/例外差分、(2)型変換/日付/文字コード差分、(3)時間差分（遅延・ロック・タイムアウト）、(4)二次注入（保存→再利用）、を「入口→組立→実行→反応」で分解して確定する。
- PTES：
  - 該当フェーズ：Information Gathering（Oracle推定：ORA/dual/rownum等、入力面の棚卸し）、Vulnerability Analysis（sink分類：値/識別子/構文、バインド境界、成立根拠＝oracle確立）、Exploitation（低侵襲：差分証拠、影響範囲の最小確定、二次注入の導線確定）。
  - 前後フェーズとの繋がり（1行）：REST filters（検索/ソート/ページング）で見つけた動的組立点と、Error modelで整理した差分が、そのままOracle向けSQLiの成立根拠（oracle）になる。
- MITRE ATT&CK：
  - 戦術：Discovery / Collection / Exfiltration / Impact / Defense Evasion
  - 目的：差分（oracle）で内部構造・存在・権限を推定（Discovery）、越境データの収集（Collection）、エクスポート等の出口で持ち出し（Exfiltration）、高負荷/ロックで枯渇（Impact）、エラーモデル統一下でもブラインドで継続（Defense Evasion）。

## タイトル
sql_injection_01_oracle（境界_プレースホルダ_ORM）

## 目的（この技術で到達する状態）
- 「Oracle DB方言としてのSQLi」を、(1)Oracle推定、(2)sink（注入文脈）分類、(3)成立根拠＝差分（oracle）確立、(4)プレースホルダ/ORM境界の破綻点、(5)影響範囲（越境混入/列過剰/書込み/二次注入）まで、最小試行で説明・証跡化できる
- Oracle特有の“差分になりやすい要素”（ORA-エラー、PL/SQL例外、NLS/暗黙変換、パッケージ実行権限）を、攻撃者視点の意思決定（次の一手）に変換できる
- 開発側へ「直し方」を、バインド徹底（値）＋allowlist固定（識別子/構文）＋エラーモデル統一＋最小権限＋監査、の設計課題として返せる

## 前提（対象・範囲・想定）
- 対象
  - Oracle DB（オンプレ/クラウドを問わず）をバックエンドに持つWebアプリ/API
  - Oracleは「値のバインド」は強いが、「識別子/構文」を動的に組み立てると破綻しやすい（特に ORDER BY / 動的WHERE / 関数式 / JSON・全文検索系）
- スコープ
  - 本ファイルは「Oracle DB方言の差分（oracle）」と「プレースホルダ/ORM境界」を扱う
  - UNIONや関数名など“具体テクニックの羅列”ではなく、差分を根拠に成立を確定し、設計破綻点へ結びつける
- 安全配慮（実務）
  - 高負荷クエリ・長時間遅延・外部通信（OOB）は原則避け、最小回数・短時間・最小データで差分を取る
  - “取り得る”ことと“実行する”ことを分ける（影響確認はLabsに逃がす）

## 観測ポイント（何を見ているか：Oracle特有の差分と境界）
### 1) Oracleであることの推定（DB方言フィンガープリント＝前段の意思決定）
- 目的：以後の仮説（型/日付/エラー/時間差分）をOracle前提に最適化する
- 観測材料（例：どれか1つで断定しない）
  - エラー表面：ORA-xxxx形式、PL/SQL例外断片、スタックの断片（アプリが漏らす場合）
  - クエリ痕跡：dual、rownum、connect by、NVL、to_date/to_timestamp、fetch first 等の語彙（ログ/メッセージ/生成SQLに出る場合）
  - 挙動差分：日付/数値の暗黙変換エラーが“入力値依存で”出る、NLS設定により同じ入力でも揺れる
- 判断（次の一手へ）
  - Oracle推定が強い → 以後は「ORA/PLSQL/NLS/権限差分」が成立根拠（oracle）になりうる前提で検証設計
  - Oracle推定が弱い → “DB別ファイル”で決め打ちを急がず、まずsink（値/識別子/構文）と一般的なoracle（boolean/time）を優先

### 2) sink（注入文脈）の分類：Oracleは“識別子/構文”側が本命になりやすい
- 値（WHERE/INSERT/UPDATEの値）
  - 原則：プレースホルダ（bind）できる。ここで成立するなら「どこかで文字列結合」か「バインド漏れ」がある
- 識別子（列名/方向/関数名/NULLS FIRST/LAST等の指定）
  - 原則：バインドできない領域。allowlist固定がないと破綻しやすい
  - 典型：sort=（列名）や、fields=（表示列）を入力で受ける設計
- 構文（条件式全体、演算子、関数式、サブクエリ片）
  - raw SQL/fragmentの逃げ道があると成立しやすい
- 判断（次の一手へ）
  - 値で差分が出る → バインド漏れ/文字列結合の存在を疑い、プレースホルダ境界の確認へ
  - 識別子/構文で差分が出る → allowlist欠落が本質。WAFや入力フィルタでは止まらない（設計で固定が必要）

### 3) Oracle特有の“差分（oracle）”の種類：成立根拠として使えるもの
#### 3.1 Error oracle（ORA/PLSQL/NLS差分）
- Oracleは「エラーコードが具体的」になりやすく、差分＝推定器になりやすい
- 観測する差分（攻撃者視点で外形）
  - ステータス（4xx/5xx）と本文の構造（JSONならerror.code、message等）
  - 同一エンドポイントで、入力の揺れに応じてエラーが変わるか（入力依存性）
  - 日付/数値/文字コードの“変換エラー”が出るか（NLS/暗黙変換）
- 判断
  - エラーが入力依存で変わる → 差分が成立根拠になる（ただしDB由来か、アプリ側バリデーションかを切り分け）
  - エラーが統一されている → Error oracleは潰されている。Boolean/Timeへ移行する判断が早くなる

#### 3.2 Boolean oracle（結果差分：Oracleでも最も安全で強い）
- 目的：エラーが隠れていても、成立を“差分”で確定する
- Oracle特有というより「設計上の差分」を利用する
  - 件数差分（0件 vs 1件以上）
  - レスポンス長差分（一覧の要素数）
  - UI差分（ページ数、合計件数）
- 注意
  - Oracleはページングにrownum等が絡む設計があり、見える範囲が固定されると差分が見えにくい（ページ/limit/offsetの境界も同時に観測する）

#### 3.3 Time oracle（短時間・少回数で：Oracleは“遅延/ロック”が差分になりやすい）
- 目的：結果が固定、エラーが統一でも残る差分を取る
- Oracleで時間差分が出やすい領域（一般論として）
  - 条件で処理パスが変わる（インデックスが使える/使えない、型変換が入る等）
  - ロック/タイムアウト（更新系、整合性チェック、集計）
  - “パッケージ実行権限の有無”で処理時間が変わるケースもある（許可/不許可で即時失敗 vs リトライ等）
- 判断
  - 時間差分は揺れに弱いので、差分の定義（どの程度遅いか）と試行回数を最小に固定する
  - 取れないなら「二次注入」「別の観測点（一覧/エクスポート）」へ移る

#### 3.4 OOB oracle（外部到達の副作用：Oracleは“パッケージ権限”が成立条件）
- 目的：外部通信/DNS等の副作用で成立を確定（ただし高リスク・範囲外になりがち）
- Oracle特有の観点（攻撃者視点の意思決定）
  - OOBは“DBが外へ出られる”だけでなく、“該当パッケージ実行権限がある”ことが成立条件になりやすい
  - したがってOOBが成立した場合、影響は「SQLi」だけでなく「DB権限過大」問題にも接続する
- 実務判断
  - 原則：許可された検証環境（Labs）でのみ扱う
  - 本番相当では、OOBを使わずにBoolean/Timeで確定する方針を優先

#### 3.5 Second-order oracle（保存→別経路で実行：Oracleは運用系SQLで起きやすい）
- 入口：テンプレ名、検索条件保存、レポート条件、管理画面のメモ等
- 実行：一覧/集計/バッチ/エクスポート（CSV/PDF）で“保存値”がSQLの一部として再利用される
- Oracle特有の観点
  - PL/SQLや動的SQL（EXECUTE IMMEDIATE等）で「保存値をSQL文字列として組み込む」設計が残ると二次注入になりやすい
- 判断
  - second-orderが見えたら最優先：実行主体が管理者/ジョブになりやすく爆発半径が大きい

### 4) プレースホルダ（bind）境界：Oracleで安全化が破れる“典型”
- 何がバインドできるか（整理）
  - できる：値（文字列/数値/日付など）
  - できない（設計で固定が必要）：列名、テーブル名、ソート方向、NULLS FIRST/LAST等の句、関数名、演算子、式の断片
- 典型の破綻パターン（設計論として）
  - sortやfieldsを入力で受け、SQL文字列に連結する（識別子注入）
  - 動的WHEREを“条件式文字列”として組み立てる（構文注入）
  - IN句を「カンマ区切り文字列」として連結する（値であっても連結になる）
  - LIKE等で“ワイルドカード込みの文字列”をSQLに埋め込む（本来は値としてバインドすべき）
- 観測で確定したい点
  - 同じ入力点でも、「値」なのか「識別子」なのかで差分の出方が変わる（件数差分より、並び差分/エラー差分が出る等）
- 開発への還元（直し方）
  - 値は全てバインド、識別子はallowlist（サーバ側固定）、式は生成しない（生成が必要なら安全な抽象化層で限定）

### 5) ORM境界：Oracleでも“ORMだから安全”が崩れる地点
- Oracleでよく起きる（一般形）
  - raw/fragment機能（whereRaw/orderByRaw相当）を使った例外パス
  - ソート/列指定を文字列で受ける便利API（識別子をユーザ入力に近づける）
  - 動的条件（複雑検索）を式文字列で構築
  - 型変換・日付変換の扱い（NLS/暗黙変換に依存）
- 観測で確定したい点（攻撃者視点）
  - ORMが出す例外が、外形のエラーモデルに混ざっていないか（error oracle）
  - “特定の入力形式”だけで遅延/エラーになる（型変換差分）
- 直し方（開発向け）
  - raw機能の使用箇所を棚卸しし、レビュー対象として隔離
  - ソート/フィールド指定はallowlist、式文字列の外部入力は禁止
  - 例外は統一して返す（詳細は内部ログへ、外形は一定）

### 6) Oracleで影響範囲が伸びる条件（権限・分離・運用）
- DBユーザ権限
  - 読み取り専用/スキーマ限定であれば、被害は“読める範囲”に限定される
  - 強い権限（過大）だと、SQLiが“DB権限問題”に直結する（実害が増幅）
- テナント分離/行レベル制御
  - Oracleでも「アプリでwhere tenant_idを付ける」設計が多い
  - ここがSQLiで崩れると、越境混入（row/tenant）が成立する
- 監査/検知
  - エラー統一で“見えにくいSQLi”が残ると、攻撃者はboolean/timeへ寄せる
  - よって監査は「例外」「遅延」「失敗頻度」「同一入力点の反復」を相関する必要がある

### 7) “確認（確定）”の中核：Oracle向けに最小試行で成立根拠（oracle）を取る
- 原則
  - baseline（通常）1件＋差分2件（true/false または 遅延有/無）で終える
  - “何を差分として採用するか”を先に固定（件数/長さ/時間/ステータス）
- 推奨の順序（低侵襲）
  1) Boolean oracle（件数/長さ差分）で確定
  2) Error oracle（ORA/例外差分）が出るなら補助証拠として採用（ただし露出は本来NG）
  3) Time oracle（短い遅延・少回数）で補完
  4) Second-order（保存→実行）で発火点を変えて確定（最重要）
  5) OOBはLabsでのみ（範囲外になりやすい）
- Oracle特有の注意（差分がブレる要因）
  - NLS/暗黙変換：日付・数値・文字列の扱いでエラー/件数が揺れることがある → baseline入力の形式を固定する
  - ページング（rownum等）：見える範囲が固定だと件数差分が見えにくい → 指標を“レスポンス長”に切り替える、またはページ条件も同時に固定する
  - 例外モデル統一：error oracleが潰れているのは良い状態 → 無理にエラーを引き出さず boolean/time へ

### 8) sqli_oracle_db_boundary_key（正規化キー：後続へ渡す）
- 目的：Oracle向けSQLiを「成立条件」と「設計破綻点」で比較可能にする
- 推奨キー
  - sqli_oracle_db_boundary_key =
    oracle
    + <sink>(value_where|identifier_order|identifier_fields|syntax_fragment|in_list|like_pattern|json_search|stored_proc|unknown)
    + <composition>(bind_only|string_concat|hybrid|unknown)
    + <oracle>(boolean|error_ora|error_plsql|error_nls|time|second_order|oob|unknown)
    + <error_model>(uniform|verbose|mixed|unknown)
    + <scope_break>(none|row_cross_user|tenant_cross|column_excess|write_possible|unknown)
    + <second_order>(yes/no/unknown)
    + <db_privilege_risk>(low|medium|high|unknown)
    + <confidence>
- 最小フィールド（証跡として残す）
  - 入力点（URL/param/body）とsink推定（値/識別子/構文）
  - 差分の種類（oracle）と指標（件数/長さ/時間/ステータス）
  - error_model（統一/露出）と再現性（最小セットで再現）
  - 影響範囲（越境混入の有無、二次注入の有無）
  - DB権限の“外形推定”（強い権限が示唆される差分があるか：断定しない）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定可能）
  - Oracle DB方言の可能性（ORA/挙動/語彙の複数根拠による推定）
  - 注入文脈（値/識別子/構文）の分類と、どこがバインドされていないか（設計破綻点）
  - 成立根拠（oracle）が何か（boolean/error/time/second-order 等）と、その再現性
  - 影響範囲の“最小確定”（越境混入の兆候、列過剰の兆候、二次注入の有無）
- 推定（根拠付きで言える）
  - 識別子/構文側で差分が出る場合、allowlist欠落が本質である可能性が高い
  - OOBが成立するなら、SQLiだけでなくDB権限設計が過大である可能性が高い（ただし断定しない）
- 言えない（この段階では断定しない）
  - DB内部の正確な権限（GRANT）や、全スキーマ構造（推測で埋めない）
  - WAF/DBAFの内部ルール（外形差分から“挙動”は言えるが内部は断定しない）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- 優先度の決め方
  - P0（最優先）
    - tenant_cross / row_cross_user が観測できる（越境混入）
    - second_order が成立（管理者/ジョブ主体で爆発半径が大きい）
    - 識別子/構文側で差分が成立（allowlist欠落＝修正難度とリスクが高い）
    - OOBが成立（権限過大の可能性が高く、影響が跳ねる）
  - P1
    - boolean/timeで成立が確定（エラー統一でも成立する＝潜伏しやすい）
    - error oracle が見える（本来抑制すべきで、探索加速になる）
  - P2
    - 影響が限定的（同一ユーザ範囲）だが、設計上の破綻が確認できる（将来の拡張で悪化しやすい）
- 攻め筋（ただし実務は低侵襲）
  - 値（where）で成立 → バインド漏れ/文字列結合箇所の特定が“次の一手”
  - 識別子（order/fields）で成立 → allowlist欠落の証拠化（列名/方向を固定できていない）
  - エラー統一で見えない → boolean/timeに寄せる（差分の指標を変える）
  - second-order → 保存点と実行点を分離し、“実行経路”を特定する（最重要）

## 次に試すこと（仮説A/Bの分岐と検証：低侵襲で確定）
- 仮説A：値（WHERE値）でバインド漏れがある
  - 検証：boolean差分（件数/長さ）を最小セットで確定
  - 次の一手：どの入力だけが差分を起こすか（同型エンドポイントへ横展開）
- 仮説B：識別子（ORDER BY/fields）が動的組立されている
  - 検証：並び/表示列の差分（“値”では説明できない変化）を証拠化
  - 次の一手：サーバallowlistの欠落として設計課題に落とす（入力フィルタではなく固定が必要）
- 仮説C：エラーモデルが統一されているがSQLiは残る
  - 検証：time/booleanへ寄せ、指標（件数→長さ→時間）を切り替える
  - 次の一手：監査/検知（遅延・失敗頻度）を含めた防御提案に繋げる
- 仮説D：二次注入（保存→別経路実行）がある
  - 検証：保存点と実行点を切り分け、実行点で差分（oracle）を確定
  - 次の一手：実行主体（管理者/ジョブ）と出口（エクスポート等）を優先評価

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境の設計（例）
  - Oracle XE等を使い、以下の“境界”を切替できる小さな検証アプリを作る
    - (1) where値：bind有/無
    - (2) order/fields：allowlist有/無（識別子を動的にする/しない）
    - (3) error_model：verbose/uniform
    - (4) NLS/型変換：日付/数値の扱いを変える
    - (5) second-order：保存検索→管理画面で実行
    - (6) DB権限：最小/過大（Labsでのみ）
- 取得する証跡（観測点）
  - HTTP：baseline/差分（true/false or 遅延有/無）の最小セットをHARで保存
  - アプリログ（可能なら）：trace_id、例外分類（ORA/PLSQL/NLS）、実行時間
  - DB側（Labsのみ）：実行されたSQLの種別（bindか連結か）、遅延の原因（ロック/関数/変換）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
~~~~
# 例（擬似）：同一エンドポイントで入力だけ変えて差分を取る
GET /api/items?filter=<BASELINE>
GET /api/items?filter=<CANDIDATE_TRUE>
GET /api/items?filter=<CANDIDATE_FALSE>

# 例（擬似）：ソート/表示列（識別子）境界の観測
GET /api/items?sort=<BASELINE_SORT>
GET /api/items?sort=<CANDIDATE_SORT>

# 例（擬似）：保存→実行（二次注入）経路の切り分け
POST /api/saved-searches  body: { "name": "<INPUT>", "query": "<INPUT>" }
GET  /admin/saved-searches/<ID>/run
~~~~
- この例で観測していること
  - sink（値/識別子/構文）のどこに入力が入っているか
  - oracle（件数/長さ/時間/エラー）が何か
  - second-order（保存→実行）で差分が“どこで”出るか
- この例が使えないケース
  - 結果が常に固定/ページングで差分が見えない → 指標を長さ/時間へ切替、または出口（エクスポート）を観測点にする

## 参考（必要最小限）
- ASVS：入力検証、エラーハンドリング、監査、最小権限
- WSTG：SQLi、エラー差分（オラクル化）の検証設計
- PTES：差分証拠の最小セットで確定する運用
- ATT&CK：Discovery/Collection/Impactへの接続

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `01_topics/02_web/04_api_08_file_export_エクスポート境界（CSV_PDF）.md`

## 次（05_input_03_sql_injection_02_mysql 以降）に進む前に確認したいこと（必要なら回答）
- 次は MySQL 方言として「差分（oracle）」がどこに出るか（例：エラー表面の違い、型変換差分、時間差分の取りやすさ、ORM境界の典型）を同じ粒度で書く。
- 以降のDB別ファイルでも、(1)sink分類、(2)成立根拠＝oracle確立、(3)プレースホルダ/ORM境界の破綻点、(4)二次注入、(5)影響範囲（越境混入/出口）、の順で揃えて比較可能にする。
