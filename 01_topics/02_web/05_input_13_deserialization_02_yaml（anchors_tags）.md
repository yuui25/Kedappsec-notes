## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - YAMLは「設定ファイル」扱いされやすいが、Webでは import / template / workflow / webhook / policy など“機能定義”として受理されることがある。ここで `タグ（型）` と `アンカー（参照）` が有効だと、**外部入力が“オブジェクト生成”や“処理分岐”を制御**し得る（=入力→実行境界）。
  - 要件としては、(1) 安全なローダ、(2) タグのallowlist、(3) アンカー/深さ/サイズ制限、(4) エラー露出抑制、(5) 取り込み後のスキーマ検証が中核。
- WSTG
  - 入力処理（パーサ/デシリアライザ）のテスト：予期しない型（タグ）、参照（アンカー/エイリアス）、多段ネスト、巨大コレクション、複数ドキュメント、重複キー等を“差分”で当て、境界（どこで拒否/例外/フォールバックするか）を確定する。
- PTES
  - 情報収集：YAMLを受け付ける入口（import/export、CI/CD連携、設定UI、API、Webhook、ジョブ定義）と、ローダ実装（言語/ライブラリ/設定）を推定。
  - 脆弱性分析：タグ解釈の有無、アンカー/マージ/重複キーの扱い、例外時フォールバック（YAML→JSON変換等）をモデル化。
  - 侵害評価：RCEに短絡せず、まず「外部入力で型が作れる」「資源枯渇できる」「到達性（SSRF/OOB）に接続する」を成立根拠として固める。
- MITRE ATT&CK
  - T1190 公開アプリ脆弱性悪用（YAML受理→unsafe load）
  - 影響：DoS（アンカー/巨大展開、深いネスト）、設定改ざん（import系）、情報漏えい（例外/ログ）
  - 追加接続（成立条件つき）：タグでオブジェクト生成が可能、かつ生成オブジェクトが“外部参照/コマンド/テンプレ評価”へ到達する場合に、実行・横展開へ波及。

---

## タイトル
YAMLデシリアライズ（anchors/tags）：再利用機能が“型生成・参照展開・キー合成”を生み、入力→実行境界を太くする

---

## 目的（このファイルで到達する状態）
- YAMLを“JSONの別表現”として扱わず、YAML固有の機能が作る境界を説明できる：
  1) **アンカー/エイリアス/マージ**（参照と合成）＝データ構造の増幅・共有参照
  2) **タグ**（型）＝オブジェクト生成・挙動分岐（言語/ローダ依存）
  3) **複数ドキュメント**（`---`）＝境界の切替・フォールバックの温床
  4) **重複キー**＝実装差分（上書き/拒否/不定）で認可や検証を崩す
- 診断では、少数の“差分入力”で次を確定できる：
  - タグ解釈が有効か（unsafe load か、safe/allowlist か）
  - アンカー展開が無制限か（DoS土壌）
  - マージ/重複キーの扱いが、検証・認可・署名検証に影響するか
  - エラー時に情報露出・フォールバックがあるか

---

## 前提（YAMLが出てくる“現実の入口”）
WebでYAMLが現れるのは、だいたい次のどれか：
- インポート/エクスポート（設定、通知、テンプレ、権限、ワークフロー）
- CI/CD・自動化（パイプライン定義、ルール、ポリシー）
- 管理画面（「高度な設定」をYAMLで貼るUI）
- API（Content-Type: application/yaml、もしくはYAML文字列をボディに含める）
- Webhook/連携（外部SaaSがYAMLを投げる、またはYAMLを受け取って解釈）

結論：YAMLは“管理者だけ”のものではなく、実務ではしばしば外部入力として成立する。

---

## 境界モデル（YAML→データ復元は“参照展開”と“型生成”を含む）
### 1) 最小データフロー
YAML text
→ Parser（構文：インデント/スカラー/コレクション）
→ Composer（アンカー/エイリアス/マージ：参照と合成）
→ Constructor（タグ：型の決定・オブジェクト生成）
→ Domain（検証/保存/実行）
→ Sink（HTTP fetch/テンプレ評価/FS/SQL/コマンド/ジョブ…）

危険ポイントは主に Composer と Constructor。
- Composer：参照展開が資源枯渇（DoS）や“共有参照”による想定外副作用を生む
- Constructor：タグが“型生成”を許し、入力→実行経路を増やす

### 2) 境界（診断で固定すべき4点）
- タグ境界：任意タグが通るか（unsafe） / 標準タグのみか（safe） / allowlistか（推奨）
- 参照境界：アンカー/エイリアスの数・深さ・展開後サイズに制限があるか
- 合成境界：マージ（`<<`）を解釈するか、重複キーをどう扱うか
- エラー境界：例外露出・ログ露出・フォールバック（YAML→JSON等）があるか

---

## YAML固有機能の“意味→判断→次の一手”
### A. アンカー & エイリアス（& / *）：参照と再利用
#### 意味
- `&name` でアンカー定義、`*name` で参照（エイリアス）。
- 目的は重複排除だが、実装上は「参照の共有」や「展開」が起きる。

#### 攻撃者視点の価値
- DoS：小さい入力で大きい構造（大量要素、深いネスト）を作る土台になりやすい
- “共有参照”の副作用：
  - アプリが復元後オブジェクトをミューテートする実装だと、別箇所の値も同時に変わり、検証・署名・認可を崩すことがある（特に“同じオブジェクトを参照する”実装の場合）

#### 判断（観測で確定する）
- アンカー/エイリアスを含む入力が通るか
- “展開後のサイズ”に制限があるか（エラー/拒否/タイムアウト）

#### 次の一手（仮説分岐）
- 仮説A：制限がある（拒否/上限）→ タグ境界や重複キーへ重点
- 仮説B：制限がない（処理が重い/落ちる）→ DoS所見として成立（再現は最小で止める）

---

### B. マージキー（`<<`）：マッピングの合成（Mixin）
#### 意味
- `<<` は、指定したマップのキーを現在のマップに“差し込む”合成機構。YAMLの標準的な型として説明される。  
- 実装差分が出やすい（対応していない、対応しているが衝突解決が曖昧、等）。

#### 攻撃者視点の価値
- 検証回避：
  - “必須キー”や“禁止キー”の検査が「合成前」だけだと、合成後に禁止キーを混入できる
- 認可境界の崩壊：
  - allowlistベースの検査が、合成前の見かけ上のキー集合だけを見る実装だと、合成で権限フィールドが滑り込む

#### 判断（観測で確定）
- `<<` を含む入力が通るか
- 合成後の最終値がどうなるか（衝突時に上書きされるか、拒否されるか）

#### 次の一手
- 合成が有効なら「検証のタイミング（pre/post）」を詰める（合成後にスキーマ検証しているか）
- 合成が無効なら「重複キー」「タグ」へ重点（別の差分が主戦場）

---

### C. タグ（`!!` / `!<...>`）：型選択＝入力→実行経路の分岐
#### 意味
- YAMLは値に“タグ”を付与でき、ローダがそれを解釈すると、復元される型（オブジェクト）が変わる。
- ここが JSON との差分で、危険度を決めるのは「どのローダを使い、どのタグを許すか」。

#### 代表的なリスク形（RCEに短絡しない）
- 任意オブジェクト生成（言語によってはコンストラクタ/フックが動く）
- 生成オブジェクトが後段のsinkへ到達（HTTP fetch、テンプレ評価、式評価、ファイル操作）
- “safe”に見えるローダでも、設定/コンストラクタの使い方で破れることがある（特にJavaのコンストラクタ指定など）

#### 判断（成立根拠の取り方：安全寄り）
- 未知タグを投げた時の挙動：
  - “unknown tag” で拒否 → 標準タグ限定（安全寄り）
  - 何かの型として通る/例外が変わる → タグ解釈経路がある可能性
- エラー文言で“型解決”が見えるか（ただし露出自体が所見になる）

#### 次の一手
- タグが通るなら：
  - 「どの入力点で通るか」（管理者限定/一般ユーザ/外部連携）
  - 「復元後のオブジェクトがどこへ流れるか」（HTTP/テンプレ/FS/ジョブ）
  を最短で詰め、影響を“業務機能”として報告できる形にする。

---

### D. 複数ドキュメント（`---`）：境界の切替とフォールバック
#### 意味
- YAMLはストリームとして複数ドキュメントを持てる。
- 実装が `load_all` などを使うと、複数のオブジェクトが生成される。

#### 攻撃者視点の価値
- 1件だけ処理する想定の実装で、2件目が“別経路”に流れる（検証漏れ）
- “先頭だけ検証→全体を実行”のズレが起きる

#### 判断
- `---` を含む入力が通るか
- 1件目だけ反映される/全件反映/拒否のどれか

---

### E. 重複キー：仕様上はNGでも“実装差分”が現実
#### 意味
- マッピングはキーの一意性が期待されるが、現実の実装は「後勝ち」「前勝ち」「例外」「不定」があり得る。

#### 攻撃者視点の価値
- 検証回避：
  - 検証が「最初のキー」だけ見てOK→後で上書き、など
- 署名/ハッシュ/正規化の差分：
  - 署名側と検証側で“どちらのキーが採用されるか”が違うと、整合性が崩れる

#### 判断
- 同一キーを2回出したときの結果（拒否/上書き/不定）を観測で固定する

---

## 破綻パターン（実務で起きやすい順）
### パターン1：unsafe load（タグで任意型生成）
- 根拠：未知タグが通る／型解決エラーが露出／特定型だけ通る、等の差分
- 影響：設定改ざん、到達性（SSRF/OOB）、場合により実行へ接続
- 重要：RCEの再現より、“外部入力が型生成を制御できる”事実が設計欠陥として強い

### パターン2：アンカー/エイリアス無制限（DoS土壌）
- 根拠：小さな入力でCPU/メモリが増える、タイムアウトがない、等
- 影響：ワーカー枯渇、キュー滞留、API遅延（SLO崩壊）

### パターン3：マージ/重複キーによる検証/認可のズレ
- 根拠：合成後に禁止キーが混ざる、重複キーで検証値と最終値がズレる
- 影響：権限逸脱、意図しない設定反映、監査破壊（ログ上はOKに見える）

### パターン4：エラー露出（型・パス・ライブラリ名）
- 根拠：例外スタック/クラス名/ファイルパスが返る
- 影響：技術特定→CVE探索の精度向上、内部構造漏えい

---

## 観測ポイント（薄くしない：何を取れば境界が確定するか）
### 1) HTTPレイヤ
- Content-Type / 受理形式（yaml/text/plain/jsonのどれで処理されるか）
- エラーの分類（構文エラー/型解決/検証/ドメインエラー）
- レスポンスに“型”や“タグ”が戻るか（往復で手掛かりになる）

### 2) 反映レイヤ（成功時）
- ストレージに保存される形（YAMLのまま保存／JSONへ正規化／DBに分解）
- UI表示（マージ後の値がどう見えるか、重複キーがどう扱われるか）

### 3) サーバログ（可能なら依頼：価値が高い）
~~~~
request_id
endpoint / feature (import|policy|workflow|webhook)
yaml_library (name/version if possible)
load_mode (safe|full|unsafe|custom)
tag_policy (standard-only|allowlist|any)
anchor_limit (count/depth if any)
max_depth / max_bytes / max_docs
merge_key_enabled (yes/no)
duplicate_key_policy (reject|last-wins|first-wins|unknown)
error_class (parse|compose|construct|validate|domain)
reject_reason (rule_id)
~~~~

---

## 検証の進め方（安全に“成立根拠”を固める）
> 危険なペイロードの提示ではなく、差分で境界を確定する。

### ステップ1：入口の同定
- どの機能がYAMLを受け付けるか（管理UI/API/import/連携）
- 認可境界：誰が到達できるか（一般ユーザ/管理者/外部SaaS）

### ステップ2：タグ境界（unsafeかどうか）
- “未知タグ”での挙動差分を観測
- 型解決が見えるなら、それ自体が高リスク（情報露出＋型選択経路）

### ステップ3：アンカー/マージ/重複キー境界
- アンカー/エイリアスが通るか（そして重くならないか）
- `<<` マージが通るか、合成後の最終値がどうなるか
- 重複キーが拒否されるか、上書きされるか

### ステップ4：フォールバックと例外パス
- 構文が少し壊れた時に、別のパーサ/モードに落ちないか
- 例外がスタック/クラス名/ファイルパスを返していないか

---

## 攻撃チェーン（現実寄り：Webでの“使われ方”に接続）
- 入口：import（設定/テンプレ/ワークフロー）やWebhook（外部入力）でYAML受理
- 境界破り：
  - タグで型が作れる → “HTTP fetch型” “テンプレ評価型” “式評価型” のような機能へ到達（SSRF/情報漏えい/権限逸脱）
  - アンカーで巨大展開 → ワーカー枯渇（DoS）
  - マージ/重複キー → 検証回避（禁止項目が混入）
- 影響：管理機能の奪取、内部到達性の獲得、サービス劣化、監査破壊

---

## 防御（設計としての優先順位）
### 1) “安全なローダ”を標準化（最重要）
- YAMLを外部入力として扱うなら、原則：
  - 標準型のみ構築（タグで任意オブジェクトを作らない）
  - カスタムタグが必要なら allowlist + 明示的マッピング
- 例（概念）：safe load / safe constructor を使い、任意型生成を禁止する  
  ※PyYAMLは `safe_load` が標準タグのみを扱う説明がある。  
  ※`yaml.load`はローダ選択によって危険になり得る注意があるため、外部入力に使わない前提を徹底する。

### 2) 参照展開（アンカー/エイリアス）の上限
- max_anchors / max_aliases / max_depth / max_total_nodes / max_bytes
- タイムアウト（変換ジョブ/ワーカー）とレート制限（ユーザ単位）

### 3) マージ/重複キーの扱いを“拒否 or 正規化”で固定
- `<<` を許すなら、**合成後**にスキーマ検証する（pre検証だけにしない）
- 重複キーは原則拒否（last-wins等にしない）
- 正規化（canonical form）を1回作り、検証・署名・保存は必ず同じ正規形に対して行う

### 4) スキーマ検証（型より“構造”を守る）
- 取り込み直後に、許容キー・型・範囲・配列長・文字列長を検証
- 「未知キー」は拒否（allowlist）
- 重要：検証の前に“構築（constructor）”が走る設計は避ける

### 5) エラー露出の抑制
- 例外の詳細（タグ/クラス名/スタック/パス）を返さない
- 監査ログは内部に残すが、利用者へは汎用エラー

---

## 次に試すこと（仮説A/B）
### 仮説A：safe load + 制限あり（比較的健全）
- 次の一手：
  - マージ/重複キー/複数ドキュメントの“検証ズレ”がないかを詰める
  - YAML→JSON正規化があるなら、その正規化前後で検証がズレないかを見る（差分の温床）

### 仮説B：unsafe / 制限なし（高リスク）
- 次の一手：
  - “どの権限で到達できる入口か”を固める（一般ユーザなら優先度最大）
  - 復元後のsink（HTTP fetch/テンプレ/式/FS）を特定し、RCEに短絡せずに **影響（SSRF/設定改ざん/DoS）** を確定して報告に落とす
  - 修正提案は「安全ローダ」「allowlistタグ」「上限」「正規化＋スキーマ検証」に集約する

---

## 04_labs での再現（境界理解用：実装比較で学ぶ）
- 3パターン構成が有効：
  1) 危険：任意タグ許容（unsafe）
  2) 中：標準タグのみ（safe）だが、アンカー/重複キー制限なし
  3) 強：safe + アンカー/深さ/サイズ制限 + 重複キー拒否 + マージ後スキーマ検証
- ログで `load_mode / tag_policy / anchor_limit / duplicate_key_policy` を必ず出す（学習と診断の両方に効く）

---

## コマンド/リクエスト例（例示は最小限：概念だけ）
~~~~
# アンカー/マージの概念例（安全なサイズで）
base: &BASE
  role: user
  flags:
    - a
    - b

cfg:
  <<: *BASE
  role: admin  # 衝突時の優先がどうなるかが“差分”になる
~~~~
- 判断点：
  - `<<` が解釈されるか
  - 衝突時にどちらが採用されるか
  - 合成後に検証されるか（禁止roleが弾かれるか）

---

## 深掘りリンク（最大8）
- `05_input_13_deserialization_01_json（polymorphism_typehint）.md`
- `05_input_13_deserialization_03_xml（object_mapping）.md`
- `05_input_09_ssrf_01_reachability（internal_localhost_metadata）.md`
- `05_input_09_ssrf_06_parser_differential（url_parse_smuggling）.md`
- `05_input_04_nosql_injection_01_mongodb_04_bson_type（型混乱_配列オブジェクト）.md`
- `04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
- `03_authz_01_境界モデル（オブジェクト_ロール_テナント）.md`
