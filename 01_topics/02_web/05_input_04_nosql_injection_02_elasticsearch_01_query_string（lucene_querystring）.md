## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）

- ASVS
  - 入力→実行境界：ユーザ入力が「検索語」ではなく **Luceneクエリ構文（演算子・フィールド指定・グルーピング）** として解釈される境界を閉じているか
  - 認可境界：tenant/org/owner 条件（フィルタ）を検索式と **同じ層で合成** していないか（検索式が優先・上書き・拡張される設計は危険）
  - 例外/エラー：パースエラー、解析エラー（analysis）、正規化差分を外部へ漏らさない（oracle化防止）
  - DoS境界：クエリ複雑度（ネスト/ワイルドカード/曖昧検索等）を制限し、タイムアウト・結果上限・rate limit を設計で担保できているか
  - 監査：query_string の使用、異常な構文（演算子頻出・広範囲検索・高コスト）をログ相関で検知できるか
- WSTG
  - Injection（入力→実行）として、SQLiと同じ流れで「入口→sink（ESクエリ生成点）→差分観測→成立根拠」を取る
  - “検索”は機能として存在しやすいので、攻撃より先に **仕様と受理範囲（allowlist）** を確定する（仕様外の構文が通るなら境界破壊）
- PTES
  - Vulnerability Analysis：検索API/一覧/ログ閲覧/管理UIを中心に、ESのクエリ生成方式（query_string / simple_query_string / match / DSL）を特定
  - Exploitation：影響実証は必要最小限（越境混入・検索範囲拡大の成立を示す）。高負荷試験は避ける
  - Reporting：根本原因を「query_string採用」「フィールドallowlist不在」「認可フィルタ合成の誤り」「複雑度制限不在」に分解して提示
- MITRE ATT&CK
  - TA0001 Initial Access（公開アプリ入口）/ TA0009 Collection（検索で横断収集）/ TA0005 Defense Evasion（エラー統一下でブラインド化）
  - 代表：T1190 Exploit Public-Facing Application（検索入力の実行境界破壊）

# NoSQL Injection（Elasticsearch）：query_string（lucene_querystring）

## 目的（この技術で到達する状態）
- Elasticsearch を利用するWeb/APIで、入力が「文字列」ではなく **Lucene Query String（検索DSLの一種）** として解釈されることで起きる境界破壊を、次の形で評価・説明できる。
  1) 入力点が “検索語” か “検索式（コード）” かを切り分ける  
  2) query_string を採用している場合の **成立根拠（oracle）** を、低侵襲に差分観測で確定する  
  3) 影響を「検索範囲拡大」「認可フィルタ迂回（越境混入）」「DoS（複雑度）」に分解して評価する  
  4) 修正を「エスケープ」ではなく、**query_string回避（simple_query_string / match系）** と **フィールドallowlist + 認可フィルタの別レイヤ適用** に落とす

## 前提（対象・範囲・想定）
- 対象
  - 検索窓（サイト内検索）、一覧フィルタ、監査ログ検索、管理画面検索、サポート用検索、レポート/エクスポートの絞り込み
  - ESの利用形態：直叩き、アプリ経由、Kibana連携、検索SaaS風の構成
- 想定実装
  - “検索語をそのまま query_string に入れる” 実装（最も危険）
  - “高度な検索”としてフィールド指定・演算子を許可する実装（仕様として成立し得るが、設計制約が必須）
- 本ファイルの焦点
  - query_string（Lucene Query String）の **構文が入力から成立する** こと自体を、入力→実行境界として扱う
- 非スコープ（別ファイル）
  - DSL（bool/filter/script 等）、painless、テンプレ（mustache stored template）は別ファイルで扱う

## 概念整理：query_string は「検索語」ではなく「検索式」を受ける
- query_string は、ユーザ入力を“そのまま”解析して検索式として解釈する（演算子、フィールド指定、グルーピング等）
- つまり境界はこうなる
  - 安全側：入力＝検索語（単なる文字列）として扱い、サーバ側で構造を生成する
  - 危険側：入力＝検索式（コード）として扱い、ユーザに“構文”を渡している
- 実務の結論
  - 「自由入力の検索窓」×「query_string採用」は、境界破壊とDoSの温床になりやすい  
    → 原則は **simple_query_string** か **match/multi_match** へ寄せる

## 観測ポイント（入力→組立→実行→反応）

### 1) 入口（input surface）を確定する：どこがES検索へ流れるか
- 典型入口（優先度高）
  - `q=` / `query=` / `keyword=`（単純検索）
  - `filter=` / `where=`（高度検索、JSON文字列のこともある）
  - 管理画面の“詳細検索”（フィールド指定ができるUI）
  - エクスポート/レポートの絞り込み条件（second-order：保存→後で実行）
- 判断（次の一手）
  - 入力点を列挙したら「同じ検索でもモードがあるか（basic/advanced）」を確認し、危険な実装分岐（advancedだけquery_string）を疑う

### 2) sink（検索生成点）を分類する：query_string か、それ以外か
- 同じESでも、採用するクエリ種類でリスクが変わる
  - query_string：構文が強力（危険度高）
  - simple_query_string：危険構文が抑制される（それでも設計制約は必要）
  - match/multi_match：解析はするが“構文”としての自由度は低い（安全側）
- 黒箱での推定指標（過度に推測しない）
  - パースエラー/解析エラーの出方、入力の記号で挙動が揺れるか
  - “検索語”のつもりの入力で、結果の広がり方が不自然に変わるか
- 判断
  - 断定はしないが、差分が安定して出る場合は「query_string相当の構文解釈がある」仮説を立てる

### 3) oracle（差分指標）を固定する：エラーより結果差分
- Boolean oracle（主証拠）
  - 件数、レスポンス長、ページ数、表示要素、特定カテゴリの出現有無
- Error oracle（補助）
  - query parse error / invalid syntax 等が返る場合は、内部実装（query_string採用）の補助証拠
  - ただし “エラーの出方” 自体が情報漏えい（例外モデル）なので、主証拠はBooleanに寄せる
- Time oracle（補助、DoS配慮）
  - 複雑な構文で遅延が出ることはあるが、性能試験に近づく  
    → “長い遅延での検証”は避け、設計上の制約欠如として評価する方向を優先

## 影響の分解（誤解を避ける：検索の仕様と脆弱性を切り分ける）

### 影響1：検索範囲の拡大（仕様外の式が通る）
- 「検索語」だけ許す想定なのに、演算子やフィールド指定が通るなら境界破壊
- 実務的な問題
  - 取得できるデータの範囲が増える（検索結果の“面積”が広がる）
  - 検索の“否定/条件結合”が使えると、想定より簡単に横断探索ができる

### 影響2：認可フィルタ（tenant/org/owner）の適用漏れ・合成誤り（越境混入）
- 典型的な誤り
  - tenant条件を query_string 内に混ぜている（同レイヤ合成）
  - フィルタ（bool.filter）のはずが、query側（should/must）と混ざる
  - “ユーザ入力の検索式”が優先され、固定条件が揺らぐ
- あるべき設計
  - 認可条件は **ユーザ入力とは別レイヤ**（filterコンテキスト）で強制適用し、入力に触らせない

### 影響3：DoS（クエリ複雑度・ワイルドカード・曖昧検索等）
- query_string は表現力が高いぶん、計算量が増えやすい
- あるべき設計
  - timeouts、結果上限、rate limit、クエリ長/複雑度制限、危険機能（leading wildcard等）抑制
- 評価の姿勢（実務）
  - “遅くできる”を証明するより、「制約の欠如」を設計問題として提示する（不用意な負荷検証を避ける）

## 根本原因の分類（報告にそのまま使える形）

### 原因A：自由入力を query_string に直結している（構文注入）
- 症状
  - 特定記号や構文で結果が不自然に揺れる / 解析エラー差分が出る
- 修正（設計）
  - query_string を避け、simple_query_string または match/multi_match へ移行
  - どうしても必要なら、受理するフィールドと構文を大幅に制限（ただし“安全運用”は難度が高い）

### 原因B：フィールドallowlist不在（field指定の自由度が過剰）
- 症状
  - ユーザが任意フィールドに触れられる設計（高度検索UIやパラメータ）
- 修正（設計）
  - サーバ側マッピング（UIの選択肢→内部フィールド）を導入し、入力をフィールド名にしない
  - 返却も source filtering（返してよいフィールドのみ）で縮退

### 原因C：認可フィルタの適用レイヤが誤っている
- 症状
  - tenant条件が入力と同レイヤで混ざっている（上書き・揺らぎ）
- 修正（設計）
  - 認可条件は bool.filter 等のフィルタレイヤで強制し、ユーザ入力は query 部分に限定する
  - “固定条件”はアプリの共通部品で一元適用（実装分岐をなくす）

### 原因D：クエリ複雑度制限不在（DoS設計不備）
- 症状
  - クエリ長/ネスト/記号量で処理が不安定（タイムアウト揺れ、CPUスパイク）
- 修正（設計・運用）
  - クエリ長上限、記号/演算子出現制限、timeout、結果上限、rate limit
  - 監査：高コスト傾向の検知と遮断（WAF/アプリ側）

## 次に試すこと（仮説A/B/C：最小差分で確定）
※ここは“観測設計”の話。危険な具体構文の提示はせず、差分の取り方を固定する。

### 仮説A：query_string 相当の構文解釈がある（境界破壊）
- 条件（観測）
  - “検索語”として想定されない記号・構文で、結果（件数/長さ）が安定して変化する、または解析エラー差分が出る
- 次の一手
  - 差分指標（件数/長さ/ページ数）を固定し、同入力点で再現性を取る
  - basic/advanced の分岐や別エンドポイントで挙動が揺れるかを確認し、実装分岐を原因として切り出す

### 仮説B：フィールド指定の自由度が過剰（allowlist不在）
- 条件（観測）
  - UI/パラメータで“どの項目を検索するか”が自由すぎる、または不正なフィールドでも挙動が一貫しない
- 次の一手
  - 受理されるフィールド集合を観測で推定し（不正値が通る/落ちるの混在）、allowlist欠落として原因固定
  - 返却フィールド（source）も含めて縮退の必要性を報告に入れる

### 仮説C：認可フィルタの適用が揺れている（越境混入リスク）
- 条件（観測）
  - テナント/ロール/ユーザの切替で、本来変わらないはずの検索面積が不自然に変わる
- 次の一手
  - “固定条件がどこで適用されているか（queryかfilterか）” を設計課題として切り出し、共通部品化を修正方針にする

## 防御設計（修正を“設計”として提示する）

### 1) query_string を避ける（最優先）
- 目的が「キーワード検索」なら、match/multi_match（または simple_query_string）へ
- query_string を残す場合は、仕様として“高度検索”を明示し、受理語彙を狭める（ただし運用難度が高い）

### 2) フィールドallowlist（入力をフィールド名にしない）
- UIの選択肢 → サーバ側で内部フィールドへマッピング
- 返却も “返してよいフィールドのみ” に限定（source filtering / view model）

### 3) 認可フィルタは別レイヤで強制（入力と混ぜない）
- tenant/org/owner は bool.filter などで常に付与
- ユーザ入力は query 部分に閉じ込める（同階層合成禁止）

### 4) DoS境界（複雑度制限）
- クエリ長、特殊記号頻度、ネスト深さ、結果上限、タイムアウト、rate limit
- 監査：高コストクエリ傾向の可視化（ログ相関）と遮断（アプリ/WAF）

## 手を動かす検証（Labs連動：境界差分の再現）
- 目的：同一検索UIで「query_string採用」「simple_query_string」「match系」を差し替え、境界差分（構文解釈・DoS・認可適用）を比較できるようにする
- 最小構成（推奨）
  - (1) 安全：match/multi_match + 認可filter強制 + フィールドallowlist
  - (2) 危険：自由入力を query_string へ直結
  - (3) 中間：simple_query_string（構文を抑制）+ 認可filter強制
  - (4) 認可誤り例：tenant条件を query 側に混ぜる（悪い例として比較）
- 証跡
  - HAR：baseline / 差分（件数） / 差分（エラー）
  - サーバログ：trace_id、選択された検索方式（query_string等）、クエリ長、実行時間、ヒット数
  - ES側（Labsのみ）：slowlog、有効なクエリ種別、タイムアウト発生状況

## 例（最小限：設計の違いを理解するための形）
~~~~
# 危険：自由入力を query_string に直結（入力が“検索式”になる）
{ "query": { "query_string": { "query": userInput } } }

# 安全：キーワードは match 系で扱い、構文はユーザに渡さない
{ "query": { "multi_match": { "query": userInput, "fields": allowedFields } } }
~~~~

~~~~
# 危険：認可条件をユーザ入力と同レイヤで合成（揺らぎやすい）
# （固定条件が“検索式”と混ざる設計は避ける）

# 安全：認可は filter レイヤで強制、入力は query へ閉じ込める
{ "query": { "bool": { "filter": [ tenantFilter ], "must": [ userQuery ] } } }
~~~~

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

## 次（作成候補順）
- `01_topics/02_web/05_input_04_nosql_injection_02_elasticsearch_02_dsl（bool_filter_script）.md`
