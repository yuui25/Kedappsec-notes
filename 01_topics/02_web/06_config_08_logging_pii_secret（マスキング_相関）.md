## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：PII/秘密がログに混入すると、ログ基盤が新たな漏えい面になる。相関キー不足は監査を破綻させ、インシデント対応が成立しない。ログ注入（改行/構造破壊）で監査の信頼境界が崩れる。
  - 満たす：最小化（必要最小限）、マスキング（復元不能＋相関可能の使い分け）、相関キー（request_id等）、アクセス制御・保持統制・監査（閲覧ログ）を要件化する。
- WSTG
  - 観点：ログ/エラーによる情報漏えい、ログ注入耐性、監査ログの適切性（過剰/不足）とアクセス制御を評価する。
- PTES
  - 位置づけ：脆弱性分析（情報漏えい面/監査破綻）→ 侵害評価（秘密が取れた場合の被害半径）→ 報告（運用要件：最小化/相関/統制）。
- MITRE ATT&CK
  - Collection/Credential Access/Defense Evasionの前提になり得る（ログが情報源、監査破壊が追跡回避）。ただし成立は環境依存。

---

## タイトル
ログ（PII/Secret：マスキングと相関）：監査のためのログが“漏えい面”と“追跡不能”を同時に作る

---

## 目的（このファイルで到達する状態）
- ログを「残す/残さない」ではなく、**何を残すべきで、何を残すと壊れるか**を境界で説明できる。
- 実務で“すぐ使える”判断ができる。
  - どこにPII/secretが混入しやすいか（URL/ヘッダ/例外/外部連携）
  - マスキングは復元不能か、相関できる形か（目的で使い分け）
  - request_id/trace_idで、LB→Proxy→App→外部APIまで追えるか
  - ログ注入で構造が壊れ、監査が破綻しないか

---

## 扱う範囲（本ファイルの守備範囲）
- アクセスログ/アプリログ/監査ログ/WAF・CDNログ/トレーシングの“設計要件”
- PII/secretの最小化・マスキング・相関
- ログ注入（改行/構造破壊）を監査境界として扱う（CRLF/下流影響と接続）

---

## 前提：ログは“複製される”（転送・集計・可視化）ので、漏えい面になりやすい
### 現実で多いログ経路
- Appログ → 集約（SIEM/APM/クラウドログ）
- WAF/CDNログ → 別基盤（運用チーム/SOC）
- 監査ログ → 長期保管（規制対応）
この時点で、ログは“第三者影響”を持つ資産になっている。

---

## 境界モデル（ログが関与する3つの境界）
- 情報境界：PII/秘密/内部URLがログへ混入すると漏えい面になる
- 監査境界：相関不能・構造破壊で追跡不能になる
- 権限境界：ログ閲覧権限は“攻撃価値が高い権限”になり得る（内部横断）

---

## 混入ポイント（現実で刺さる順）
### 1) URL/Query（最も漏れやすい）
- 認証コード、招待トークン、検索語、presigned URL、エラーパラメータ

### 2) ヘッダ
- Authorization、Cookie、X-Api-Key、Referer（外部遷移で増える）

### 3) 例外（ここが“現実の事故”）
- 例外スタックに環境変数/接続先/設定キーが混ざる
- 外部APIエラーのレスポンスをそのままログに吐く

### 4) 監査ログの“過剰”
- 誰が何をしたかは必要だが、入力値や秘密を丸ごと残すと逆効果

---

## 相関設計（現実で回る最小セット）
- request_id / trace_id：全層で共通（LB/Proxy/App）
- user_id / tenant_id：直接PIIではなく内部ID（必要に応じてハッシュ化）
- action（操作名）/ result（成功/失敗）/ target（対象ID）
- 重要：相関できないと、診断でもインシデントでも結論が出ない

---

## ログ構造の防衛（現実で起きる監査破綻）
- 改行・制御文字で1イベントが分割される
- JSONログが壊れて、検索/相関ができない
- 解析系（SIEM/APM）で正規化され、重要フィールドが欠落する
（下流影響は `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md` と接続）

---

## 観測ポイント（診断での“現実的な見方”）
- 返る相関IDがあるか（ヘッダ/レスポンスボディ）
- 例外時にログが過剰になっていないか（スタック/秘密）
- ログ閲覧権限が広すぎないか（共有ダッシュボード/リンク共有）
- ログ基盤が第三者SaaSなら、転送前に最小化されているか

---

## 結果の意味（この状態なら何が言えるか）
- secretがログに残る：漏えい時の被害が“横展開”に拡大（回収・失効運用が必須）
- 相関キーが弱い：追跡不能で、運用リスクが高い（検知・復旧が遅れる）
- 構造破壊が起きる：監査の信頼境界が崩れる（誤検知/追跡不能）

---

## 攻撃者視点での利用（現実で使われる）
- まず“ログ閲覧”を狙う（クラウド権限・共有ダッシュボード・デバッグUI）
- 次に“ログに秘密を吐かせる”条件を探す（例外誘発、presigned URL、エラー詳細）
- 構造破壊が可能なら、追跡を難化（Defense Evasion）を狙う（成立は下流次第）

---

## 次に試すこと（仮説A/Bで分岐）
### 仮説A：過剰ログが原因（アプリ/ミドルで改善可能）
- 次の一手
  - Authorization/Cookie/Token/PIIのマスキング規約を定義し、共通ミドルで適用
  - 例外ログは“要約＋相関ID”にし、詳細は保護基盤へ
  - request_id/trace_idを必須化し、全層で繋げる

### 仮説B：ログが第三者基盤へ転送される（データ境界が本質）
- 次の一手
  - 転送前に最小化（必要最小限のみ）、PII/secretは原則送らない
  - 閲覧権限・保持期間・監査（閲覧ログ）を要件化
  - 相関のためのハッシュ化（復元不能）を使い分ける

---

## 修正（実務で通る要求）
- ログ＝データ資産として扱う（最小化/保護/監査/保持）
- 相関IDは“必須要件”
- 構造化ログ＋入力正規化（制御文字/改行）で監査破綻を防ぐ

---

## 04_labs（ログ混入と相関：PII/secretを吐かずに追えるを再現）
- 追加候補Lab（例）
  - `04_labs/02_web/06_config/08_logging_pii_secret_masking/`
- Lab設計要件
  - 例外で秘密が混入するケースと、相関IDで追えるケースを比較
  - 目的：マスキングと相関を両立した“運用要件”として言語化できること

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# 重要：ログを見るときの観点は3つだけ
# 1) 秘密/PIIが混入していないか（URL/ヘッダ/例外）
# 2) 相関できるか（request_id/trace_id）
# 3) 構造が壊れないか（改行/制御文字/JSON崩壊）
~~~~

---

## 深掘りリンク（最大8）
- `06_config_11_secrets_rotation_運用（回収_失効）.md`
- `06_config_07_error_pages_詳細表示と環境切替.md`
- `06_config_12_s3_presigned_url_期限と権限境界.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `06_config_03_security_headers（CSP_HSTS_XFO等）.md`
- `06_config_04_csp_実務設計（report-only_違反収集）.md`
- `06_config_10_cdn_waf_運用境界（ルール例外_バイパス）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
