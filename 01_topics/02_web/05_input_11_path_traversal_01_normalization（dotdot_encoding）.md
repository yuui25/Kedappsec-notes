## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - この技術で満たす/破れる点：
    - ユーザ入力（ファイル名/パス/ID）をそのままファイルAPIへ渡す設計は、パストラバーサル（CWE-22）の温床。特に「正規化（canonicalization）前の検証」「デコード順の不一致」「区切り文字の混在」「dot-segment（..）の解釈差」は、allowlist/denylistを容易に破る。
    - “ファイル名メタデータを直接使わない”要件（ASVS 4.0系の代表要求）は、まさに本ファイルの対象（入力→FS境界）を押さえる。  
  - 支える前提：
    - 05_inputは「入力が“別の実行系（FS/プロセス/ブラウザ）”に渡る境界」を扱う。本ファイルはFS境界のうち、正規化（path normalization）が破綻する条件を“成立根拠（差分）”として固める。
- WSTG
  - 該当テスト観点：
    - Directory Traversal / File Include（WSTG-ATHZ-01）を、単なる「../試す」から一段進めて「正規化パイプライン（decode→normalize→join→resolve）のどこがズレるか」を観測で確定する。  
  - どの観測・検証に対応するか：
    - 入力点の特定（param/header/path/cookie/body）→ 正規化の差分（単純../ vs encoded/double-encoded vs separator混在）→ 結果の差分（403/404/200/別ファイル）→ ログで“実際に解決されたパス”を証拠化。
- PTES
  - 位置づけ：
    - Vulnerability Analysis：正規化の設計欠陥（decode回数、区切り文字、OS差、ミドルウェア差）をモデル化する。
    - Exploitation：目的はペイロード網羅ではなく「どの層の正規化が欠け、base directory境界が崩れたか」を再現性で立証する。
    - Reporting：修正は“入力を厳しく”ではなく「安全な参照方式（ID→サーバ引き当て）」「正規化後の実体判定」「base dir拘束」「シンボリックリンク対策」「監査ログ」のセットで提案する。
- MITRE ATT&CK
  - 入口：T1190（公開アプリの脆弱性悪用）
  - 目的への接続：
    - Credential Access：設定/秘密情報ファイルの読取（クラウドキー、DB接続情報、APIキー）
    - Discovery：内部パス構造・デプロイ構成・環境変数の特定
    - Impact/Execution：書込みや実行可能パスに到達できると、RCEや永続化へ連鎖し得る（ただし“成立条件”で切り分ける）。

---

## タイトル
正規化（dotdot / encoding）の破綻で起きる Path Traversal：検証前の「見かけの安全」が崩れる

---

## 目的（このファイルで到達する状態）
- 「../」を試す段階で止まらず、**正規化のどの段が欠けて境界が壊れたか**を説明できる。
- 実務で次を即断できる：
  - 入力点ごとの正規化（URL path / query / body / header）の違い
  - デコード順（1回/複数回）と正規化（dot segment解決、区切り統一）の不一致が起こす差分
  - ベースディレクトリ拘束の“強い実装”と“弱い実装”の見分け
- 次ファイルへ接続できる：
  - `02_join_root（allowlist_basedir）`：base dir拘束とrealpath/シンボリックリンク
  - `03_archive（zip_slip）`：アーカイブ展開時の正規化不備

---

## 用語の固定（このリポジトリでの定義）
- Path Traversal（CWE-22）
  - 入力から構築したパスが、本来許可された親ディレクトリ配下に収まる想定なのに、`..` や区切り等の特殊要素により親ディレクトリ外へ解決されること。
- 正規化（Normalization / Canonicalization）
  - 「同じ場所を指す別表現」を1つの表現に寄せる処理。
  - 本ファイルでは特に、(1) デコード、(2) 区切り文字統一、(3) dot segment（`.`/`..`）解決、(4) ルート・ドライブ・UNC等の扱い、を含む。
- base directory（制限親ディレクトリ）
  - 許可されたファイル参照が収まるべき基準パス。ここから外れる解決が発生した時点で“境界破綻”。

---

## 境界モデル（入力→FS参照の流れを固定する）
### 1) 典型データフロー
- 入口（ユーザ入力）
  - URL path：`/download/<name>` の `<name>`
  - query：`?file=<name>`
  - body：JSON/form/multipart の `file` / `path`
  - header/cookie：`X-File:` / `lang=...` 等（ログ的に見落とされやすい）
- 変換（正規化パイプライン）
  - decode（%xx, +, Unicode正規化など）
  - 文字列連結 / join
  - OSファイルAPIに渡す（open/read/write/stat）
- 結果（ファイルアクセス）
  - 読み取り（最頻）
  - 書き込み（アップロード保存先・ログ出力先）
  - 実行・解釈（テンプレ・設定・スクリプト・プラグイン）

### 2) 信頼境界（ここが“破れる点”）
- アプリが「入力をパスに変換する瞬間」
- ミドルウェア（リバプロ/フレームワーク）が「先にデコードや正規化をする瞬間」
- OSが「最終的に解決する瞬間（dot segment、区切り、ドライブ、UNC、シンボリックリンク等）」

---

## まず押さえる：なぜ“正規化”が本命なのか
- 実装側は多くの場合「禁止文字を除く」「../を含むなら弾く」などの“見かけの検査”を入れる。
- 攻撃側は「同じ意味を別表現で作る」ことで検査をすり抜ける。
  - `..` の表現揺れ（エンコード、混在、二重デコード）
  - 区切りの表現揺れ（`/` と `\`、多重区切り、OS差）
  - 解釈層の差（URLデコードを何回するか、どの層が先に正規化するか）
- よって、診断で重要なのは「禁止表現の網羅」ではなく、**正規化パイプラインの整合性**を差分で立証すること。

---

## 成立条件（差分＝成立根拠）：正規化破綻を“状態”として確定する
> ここが薄いと「../通りました」で終わる。差分で“どこが欠けていたか”まで落とす。

### 状態N0：ファイル参照が入力で選べる
- 例：download/view/include/template/render 等
- 診断の意味：入口の存在（攻撃面）を確定。

### 状態N1：検証が“正規化前の文字列”に対して行われている
- 例：`if "../" in input: reject`、`startswith("/safe/")`、正規表現で弾く
- 診断の意味：decode/normalizeの順序差で回避できる土台がある。

### 状態N2：アプリ/ミドルウェア/OSでデコード・正規化の回数や対象がズレる
- 例：
  - 片方は `%2e%2e%2f` を `../` として解釈するが、片方はそのまま扱う
  - 片方は `\` を区切りとして扱うが、片方は通常文字として扱う
- 診断の意味：同じ入力が別の意味に化ける（再現性が出るほど強い根拠）。

### 状態N3：最終的に base directory 外の実体へ解決される
- ここが“負け条件”。
- 診断の意味：CWE-22として成立。読めた/書けた/存在確認できた等の差分で証拠化。

---

## 入口の分類（どこで正規化が変わるか：現実寄り）
### 1) URL path に混ざる traversal
- ルータ・リバプロが先に正規化しがち（ここが“防ぐ側”にも“ズレ”にもなる）。
- “パスの正規化が早すぎる”と、アプリが想定していない形で別リソースに到達する（アクセス制御の問題へ接続）。

### 2) query / body の traversal
- アプリ側でファイルAPIに渡す直前まで“文字列”のまま残りがち。
- そのぶん、デコード順・連結順・バリデーションが実装依存になり、バグになりやすい。

### 3) 保存先パス（アップロード/エクスポート/ログ）
- 「読み取り」だけでなく「書き込み」になると影響が跳ねる。
- 正規化不備が “任意パス書込み” に繋がると、設定改変・永続化・実行連鎖の可能性が出る（ただし次ファイルで境界条件を詰める）。

---

## 正規化バイパスの考え方（網羅ではなく、体系で攻める）
> ここは“具体payload集”ではなく、差分を出すための設計。

### 軸A：dotdot（..）の表現揺れ
- 直接表現：`..`
- エンコード表現：`%2e%2e`（`..` の別表現）
- 変形：`.` の繰り返しや混在（dot segment解決の実装差を誘発）

### 軸B：区切り（separator）の表現揺れ
- POSIX：`/`
- Windows：`/` と `\` の両方が区切りとして解釈され得る（実装差が事故原因）
- 多重区切り：`//` や `\\`（正規化で潰されるか残るかが差分になる）

### 軸C：デコード回数・順序
- 1回デコードしてから検査 → 2回目デコードで traversal が出現、のような破綻が典型
- “どの層がデコードするか”（リバプロ、フレームワーク、アプリ）を切り分けるのが重要

### 軸D：OS/実行環境差
- 同じアプリでも、worker/バッチ/別言語サービスでファイル解釈が異なることがある（境界が増えるほど事故る）

---

## 観測ポイント（証拠を薄くしない最小セット）
### アプリログ（推奨：実装側に寄せる観測）
- raw_input（受け取った値）
- decoded_input（デコード後）
- normalized_path（dot segment解決・区切り統一後）
- base_dir（基準）
- resolved_path（最終的にファイルAPIへ渡したパス）
- decision（allow/deny + ルールID）
- trace_id / request_id（相関キー）

### ネットワーク/HTTP観測（診断側）
- どの入力点に入ったか（path/query/body/header/cookie）
- どの層で変換されたか（アプリ側レスポンス差分、リダイレクト差分）
- 成功時の“差分”：
  - 期待したファイルと別のファイルが返る
  - エラーが変わる（403→404→200など）※ただし推測で断言しない。ログで裏を取る

---

## 攻撃者視点での利用（現実の連鎖：やり過ぎずに“判断”へ落とす）
- 価値が高い到達先（例）
  - アプリ設定（DB接続、APIキー、SaaS連携鍵）
  - ソース/テンプレ（ロジック・エンドポイント・秘密の扱い）
  - 環境情報（デプロイ方式、パス構造、権限）
- 連鎖の判断
  - “読めるだけ”でも、次の攻め筋（認証回避、内部API、権限伝播、秘密管理）に直結する場合がある
  - “書ける”なら、設定改変・永続化・実行連鎖の可能性が出るが、成立には「保存先」「実行経路」「権限」の条件が追加で必要（本ファイルでは“正規化で外へ出られる”までを確定し、次ファイルで詰める）

---

## 設計・実装の指針（対策を“正規化の一貫性”に落とす）
### 原則1：入力で“パス”を受け取らない（ID参照へ寄せる）
- `/download?id=123` のようにし、サーバ側で `id -> 実ファイル` を引き当てる。
- これが最も強い（正規化バグを土俵から外す）。

### 原則2：受け取るなら「単一パイプライン」で decode→normalize→拘束 を固定する
- decode回数を固定（多重デコードを禁止）
- 区切りを統一（`/` と `\` を同一視するか、OSに合わせて明確に拒否するかを決める）
- dot segment（`.`/`..`）解決を行い、**解決後の実体**で判定する

### 原則3：base directory 拘束は“正規化後の実体”で判定する
- `resolved_path` が `base_dir` 配下にあることを、OSのパスAPIで確認する（文字列前方一致だけで済ませない）
- シンボリックリンク等の“実体化”は次ファイル（join_root）で扱うが、ここで方針として必ず繋げる

### 原則4：ログと拒否理由を“安全に”残す
- 攻撃検知・再現性確認のため、判定のどこで落ちたか（rule_id）と相関キーを残す
- ただし、エラーレスポンスに実パスを出さない（情報漏えいに接続）

---

## 検証の進め方（意味→判断→次の一手）
### ステップ1：入口の棚卸し（入力点×機能）
- download/view/include/template/render/export/upload のいずれかがあれば優先度高
- “ファイル名っぽい値”だけでなく、言語/テーマ/テンプレ名（lang=, theme=）も対象に含める

### ステップ2：正規化の有無を差分で推定
- 目的：禁止表現を探すのではなく「どの層がどう正規化しているか」を推定する
- 観測：
  - 同じ入力点で、表現だけ変えてレスポンス差分が出るか（成功/失敗、エラー種別、サイズ）

### ステップ3：成立根拠を固める（N1→N3の鎖）
- N1（正規化前検証）を示す差分
- N2（解釈ズレ）を示す再現性
- N3（base dir外解決）を示す証拠（ログ推奨、なければ“別ファイル到達”を間接証拠として慎重に扱う）

---

## 仮説A/B（条件で次の手が変わるように書く）
### 仮説A：デコード・正規化が一貫しており、dotdot/encoding では外に出られない
- 期待観測
  - 表現揺れ（encoded/混在）でも挙動が変わらない
  - 正規化後に必ず拒否される（rule_idが一定）
- 次の一手
  - `02_join_root` の観点へ移動：シンボリックリンク/ショートカット/別マウント等で“実体が外に出る”可能性を確認
  - 認可境界（03_authz）へ接続：そもそも“参照してよいファイル”の権限モデルがあるか（IDOR型のファイル参照）

### 仮説B：正規化前検証 or 解釈ズレがあり、dotdot/encoding で境界が崩れる
- 期待観測
  - 表現を変えると拒否/許可が変わる（再現性がある）
  - 同一機能で参照先が変わる／存在判定ができる
- 次の一手
  - 影響の切り分け：読み取りのみか、書き込みまで届くか（アップロード保存先・エクスポート・ログ）
  - 連鎖評価：秘密情報・設定・テンプレ等、二次被害に直結する“高価値ファイル”のクラスを特定（具体ファイル名の列挙でなく、カテゴリで整理）
  - 修正提案：ID参照化 or 正規化後の実体判定＋base dir拘束（次ファイルの対策へ接続）

---

## 手を動かす検証（Labs設計：手順書ではなく設計）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/11_path_traversal_normalization/`
- 設計ゴール
  - 同一機能に対し、(1) 正規化前検証、(2) decode回数差、(3) separator混在、を切り替えられる最小アプリを用意し、
  - `raw_input -> decoded -> normalized -> resolved_path -> decision` をログで一貫して観測できる状態にする。
- 最低限の観測（必須）
  - request_id、入力点（path/query/body/header）、正規化各段の値、最終解決パス、判定ルールID

~~~~
# 観測ログの最小フィールド例（設計用）
# - request_id
# - input_channel: path|query|body|header|cookie
# - raw_input
# - decoded_input
# - normalized_input
# - base_dir
# - resolved_path
# - decision: allow|deny
# - rule_id
~~~~

---

## 深掘りリンク（最大8）
- `05_input_11_path_traversal_02_join_root（allowlist_basedir）.md`
- `05_input_11_path_traversal_03_archive（zip_slip）.md`
- `05_input_12_file_upload_02_storage_path（bucket_acl_traversal）.md`
- `03_authz_08_file_access_ダウンロード認可（署名URL）.md`
- `06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
- `04_api_08_file_export_エクスポート境界（CSV_PDF）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
