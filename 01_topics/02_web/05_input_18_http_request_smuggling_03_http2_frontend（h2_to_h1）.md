## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：HTTP/2（H2）のフロント（CDN/WAF/LB/Reverse Proxy）が、バックエンドにHTTP/1.1（H1）で転送する“変換境界（H2→H1）”で、(1) リクエスト境界（request boundary）、(2) ルーティング境界（Host/:authority、path）、(3) hop-by-hop正規化、(4) ログ/監査の相関が崩れる。結果として、フロントの検査/制御（WAF/ACL/認証前処理）を迂回する“見えないリクエスト”や誤ルーティングが成立し得る。
  - 満たす：H2を終端する層で厳格に正規化・拒否（曖昧さ排除）、H2→H1変換で危険な表現を生成しない（TE/CL、重複CL、改行、疑似ヘッダ順序違反など）。異常時はコネクションを破棄しプールへ戻さない。フロント/バックのrequest_id相関を必須にする。
- WSTG
  - H2特有の観点：H2はフレーム化されるため「H1の“チャンク終端/CL解釈”そのもの」は直接は起きないが、H2→H1変換で“再びH1の曖昧さ”が発生する。よってテストは「H2で受け付ける入力のうち、H1へ変換した際に曖昧/不正/異常なH1表現が生まれないか」を観測で確定する。
- PTES
  - 脆弱性分析：スタック分解（クライアント↔フロントはH2、フロント↔バックはH1 など）を行い、“境界がどこにあるか”を確定してから検証する。
  - 侵害評価：成立の芯は(1) 変換境界での解釈差（boundary/routingの破壊）を観測で確定し、(2) 高価値分岐（認可・ルーティング・キャッシュ・監査）への到達性で実害を評価する。
- MITRE ATT&CK
  - Initial Access：T1190（公開アプリの脆弱性悪用）
  - Defense Evasion：フロント検査を“別リクエスト”化/誤ルーティング化して回避し得る（条件付き）
  - Impact：バックコネクション汚染・キュー滞留等のサービス劣化へ波及（条件付き）

---

## タイトル
HTTP/2フロントのRequest Smuggling：H2は安全そうに見えるが、H2→H1変換が“曖昧なH1”を再生成して境界が壊れる

---

## 目的（このファイルで到達する状態）
- HTTP/2フロント（H2終端）を含む環境で、次を「観測に基づく成立根拠」として説明できる。
  1) どの構成でリスクが増えるか（H2→H1変換、複数プロキシ、多段LB）
  2) H2特有の“壊れ方”を分類できる（境界破壊／ルーティング破壊／正規化破壊）
  3) どう観測して確定するか（stream、レスポンス対応、front/backログ相関）
  4) 侵害評価を“高価値分岐”で確定できる（認可・ルーティング・キャッシュ・監査）
  5) 修正を“設計要件”として提示できる（拒否・正規化・変換規則・コネクション管理）

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：HTTP/2フロント（CDN/WAF/LB/Reverse Proxy）がHTTP/1.1バックへ転送する際に起きる “H2→H1変換境界” の問題
  - Request boundary（追加リクエスト/デシンク）に繋がる変換不整合
  - Routing boundary（:authority/Host、:path）に繋がる誤ルーティング
  - Hop-by-hop/ヘッダ正規化差によるWAF/ACL迂回の条件
- 扱わない（ただし接続する）
  - H1同士のTE.CL/CL.TE：`05_input_18_http_request_smuggling_01_te_cl` / `02_cl_te`
  - 観測シグナル集約：`05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
  - キャッシュ汚染の詳細：`05_input_19_cache_poisoning_*`

---

## 前提：HTTP/2は“境界が明確”だが、変換で再び曖昧になる
### H2が本来持つ性質（誤解しやすい点）
- H2はフレーム（HEADERS/DATA）でメッセージが区切られ、ストリーム単位で「ここまでが1リクエスト」が明確になりやすい。
- そのため「H1のCL/TE曖昧性」は、H2そのものでは起きにくい。

### それでも事故が起きる理由（本ファイルの核）
- 多くの実運用で、フロントはH2を終端し、バックへH1で再送する（H2→H1変換）。
- この“変換”が、
  - 危険なH1ヘッダ（重複CL、TE+CL、改行等）を生成する
  - ルーティングに使う値（:authority/Host、:path）を不一致にする
  - フロント側の正規化とバック側の解釈が食い違う
と、H1の世界に曖昧性が復活し、smuggling/desyncや誤ルーティングが成立する。

---

## 境界モデル（H2→H1変換は「2種類の境界」を壊し得る）
### 1) リクエスト境界（request boundary）
- “どこまでが1リクエストか”が、フロントとバックでズレる（結果：desync/追加リクエスト）

### 2) ルーティング境界（routing boundary）
- “どのサービス/ホスト/テナントへ送るか”が、フロントとバックでズレる（結果：誤ルーティング/境界横断）

この2つは別問題に見えるが、実務上は同じ要因（正規化差・変換差）から同時に起きることがある。

---

## H2→H1で起きる問題の分類（差分＝成立根拠として使う）
> ここは「手口」ではなく「成立条件（どの差分が根拠か）」の整理。

### 類型A：H2で受けたヘッダが、H1側で“危険な組合せ”になる
- 例：重複Content-Length、曖昧な長さ決定、hop-by-hopの混在
- 何が危険か
  - バックが“別の長さ決定”で読み、H1型smuggling（TE.CL / CL.TE）の入口条件を満たす可能性がある
- 成立根拠（観測）
  - フロントが受けたH2リクエスト（HEADERS/DATA）と、バックへ出たH1リクエスト（実ログ/pcap/上流ログ）で、ヘッダ構造が変化している（生成/重複/順序）ことが確認できる

### 類型B：:authority と Host の不一致（または正規化差）で誤ルーティング
- H2では :authority が“権威”になりやすいが、H1では Host がルーティングの鍵になる。
- 変換で
  - :authority → Host の写像が曖昧
  - Hostが複数になった（重複Host）
  - 大文字小文字・末尾ドット・ポート表記・IDN/Punycodeなどの正規化差
があると、フロントとバックで「どのホスト扱いか」がズレる。
- 実害の方向
  - マルチテナント/マルチサービス環境で、意図しないバックへ到達し得る（境界横断）
- 成立根拠（観測）
  - フロントログ上のルーティング先（upstream）が、バックログのHost/サービスと一致しない
  - 同一入力で upstream が揺れる（正規化差のシグナル）

### 類型C：:path / クエリの正規化差（デコード順序差）で境界が割れる
- フロントでURLデコード/正規化（%xx、重複スラッシュ、ドットセグメント、Unicode正規化等）を行い、
  - WAF/ACLは“正規化後”で判定
  - バックは“別の順序/別規則”で解釈
すると、同じ入力が別の資源を指す（パス正規化差）ことがある。
- これは狭義のsmuggling（request boundary）ではなくても、
  - “フロント検査を通ったのにバックで別物になる”
という意味で同じ危険（境界破壊）を持つ。
- 成立根拠（観測）
  - フロントが記録する正規化済みパスと、バックが処理したパスが一致しない（ログ/トレース）

### 類型D：HTTP/2終端の例外処理でコネクション管理が破綻（汚染/混線）
- 変換中にエラー（ヘッダサイズ超過、異常フレーム、途中キャンセル等）が起きたとき、
  - バック側のH1コネクションを“中途半端な状態”でプールへ戻す
と、後続の正規リクエストが混線し得る。
- 成立根拠（観測）
  - 特定の異常入力の後、通常リクエストが不安定化（タイムアウト/502増）
  - バック側の同一コネクションで request boundary が乱れる兆候（pcap/ログ）

---

## 観測ポイント（H2特有：streamと相関が鍵）
### 1) H2側の観測（ストリーム単位）
- stream_id（同時多重でresponse対応が崩れやすいので必須）
- HEADERSとDATAの順序、END_STREAM/END_HEADERS
- エラーの種類：RST_STREAM、GOAWAY、PROTOCOL_ERROR等（実装依存だが“層”の手がかり）

### 2) 変換後（H1側）の観測（可能なら）
- バックへ出たH1の生ログ/pcap（最強の根拠）
- 代替：バックアクセスログで Host/path/method と request_id の件数・順序を確認

### 3) 相関（front/backで一致させる）
- request_id / traceparent などを front→back に伝播させる設計があると、所見化が強い
- なければ、少なくとも timestamp + client tuple + connection/stream の相関で“件数不一致”を示す

---

## 検証設計（安全第一：H2→H1変換境界の“差分”を特定する）
> 目的は「成立根拠（差分）」の確定。過剰な再現や第三者影響（キャッシュ汚染等）は避ける。

### ステップ0：スタック確定（H2はどこで終端しているか）
- 入口（CDN/WAF/LB）でH2終端しているのか
- その後段（Reverse Proxy）でも再終端しているのか（多段）
- バックへはH1か、H2を維持しているか（H2 end-to-end ならこの類型は減る）

### ステップ1：H2で到達できる入力面を棚卸し（高価値分岐に直結する箇所）
- 管理系/内部系の path-based ACL がある
- Hostベースのマルチサービス
- WAFが特定パス/特定パラメータのみ厳格
- 認証/認可がフロント依存（危険）かバックで完結（相対的に安全）か

### ステップ2：変換差の候補を“観測で切り分ける”
- 目的別に観測する（分類A〜D）
  - A（ヘッダ生成差）：H2入力とバックH1のヘッダ差を取る
  - B（authority/Host差）：ルーティング先（upstream）とバックHostログ差を取る
  - C（path正規化差）：front/backで処理されたパス差を取る
  - D（例外/汚染）：異常時にコネクション破棄されているか（後続影響）を見る

### ステップ3：成立したら“実害の分岐”へ最短で寄せる（ただし安全条件を守る）
- 認可境界（03_authz）に届くか
- ルーティング境界（別Host/別テナント）に届くか
- 監査・検知が破綻しているか
- キャッシュ影響は、明確な許可/隔離条件がない限り深化しない（事故になりやすい）

---

## 成立根拠の書き方（薄くしない：状態＋差分＋影響半径）
### 1) 状態（何が壊れたか）
- request boundary が崩れた（desync兆候/確定）
- routing boundary が崩れた（誤ルーティング/揺れ）
- 正規化差によりフロント判定とバック処理が不一致

### 2) 差分（なぜそう言えるか：観測）
- frontログとbackログで、件数/順序/Host/pathが不一致
- H2入力（stream単位）とバックH1（生ログ/pcap）でヘッダ構造が変化
- 異常時にバックコネクションが破棄されず、後続へ影響（汚染兆候）

### 3) 影響半径（どこまで波及するか）
- ルーティング：同一フロント配下の別サービスへ波及するか
- 認可：フロント依存制御の迂回可能性があるか
- 監査：調査不能（追跡性破綻）になっていないか

---

## 防御（設計要件：H2→H1変換境界を“固定化”する）
### 1) H2終端で“厳格に拒否・正規化”する
- 疑似ヘッダ（:method/:path/:authority/:scheme）の妥当性と順序を厳格に検証
- 禁止/制限すべき表現（重複/異常ヘッダ、曖昧なHost/authority表現、過大ヘッダ等）を最前段で拒否
- 例外処理（PROTOCOL_ERROR等）時の挙動を設計として固定（バックコネクション破棄）

### 2) H2→H1変換で“危険なH1を生成しない”
- 変換規則を明文化（:authority→Hostの単一写像、正規化の順序、ヘッダの単一化）
- hop-by-hopヘッダの剥離・統一
- Content-Lengthの単一化（重複CL禁止）・曖昧性の排除
- 不整合を見つけたら 4xxで早期終了し、バックへ到達させない

### 3) コネクション管理（汚染を次へ持ち越さない）
- 変換エラー・上流切断・タイムアウト時は、バック側コネクションを破棄してプールへ戻さない
- “安全に壊せる”を性能設計に組み込む（事故の再現性を潰す）

### 4) 相関・監査（front/backで同一request_id）
- 変換境界で request_id を付与し、バックまで伝播
- 件数不一致・順序崩れ・upstream揺れを検知できる監視（運用要件）

---

## 次に試すこと（仮説A/B：現実寄せ）
### 仮説A：マルチサービス/マルチテナントでルーティング境界が揺れる
- 次の一手
  - :authority/Hostとupstream（どのバックへ行ったか）をログで突合
  - 同一入力で揺れるなら、正規化差の“どの表現”で揺れるかを特定し、拒否/正規化要件に落とす
  - 誤ルーティングが認可境界（03_authz）へ波及するか評価する（別テナント到達は最優先）

### 仮説B：desync兆候はあるが、バックH1の生ログが取れない
- 次の一手
  - `05_input_18_http_request_smuggling_04_observable_signals` の枠で、タイミング/エラー層/件数不一致を積み上げて“状態”として所見化
  - 追加で、運用に「最小限の相関ログ（request_id伝播）」を依頼できるなら、最短で根拠を強化する

---

## 04_labs（学習用：H2→H1変換境界を可視化する）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/18_http2_frontend_h2_to_h1_boundary/`
- Lab設計要件
  - 構成：
    - フロント：H2終端→H1でバックへ転送する中継（等価挙動）
    - バック：H1サーバ（アクセスログでHost/path/methodを記録）
  - 観測点：
    - H2側：stream_id、HEADERS/DATA、エラー種別
    - H1側：受信したリクエスト行・ヘッダ（可能ならpcap）
    - 相関：request_id（フロントで付与→バックへ付与）
  - 成功条件：
    - “同じ入力が、frontとbackで異なる解釈になる”状態を観測で示し、どの正規化差が原因か説明できる

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# H2→H1境界で重要なのは「H2入力」と「H1へ変換された結果」の差分。
# - H2はstream単位で観測する（response対応崩れの切り分けに必須）
# - 可能ならバックに届いたH1をログ/pcapで取得する（成立根拠が最強）
# - 取れない場合でも、front/backログの件数・順序・Host/pathの不一致で“状態”を確定する
~~~~

---

## 深掘りリンク（最大8）
- `05_input_18_http_request_smuggling_01_te_cl（proxy_desync）.md`
- `05_input_18_http_request_smuggling_02_cl_te（proxy_desync）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_11_path_traversal_01_normalization（dotdot_encoding）.md`
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
