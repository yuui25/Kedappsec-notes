## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：入力検証（出力/ヘッダ生成を含む）、セキュア通信、エラー処理/ログ、キャッシュ/ヘッダ設計
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：ヘッダへ未検証入力が混入し、**下流（CDN/Proxy/ブラウザ/ログ基盤）が境界（CRLF）を再解釈**すると、アプリ単体の安全策を迂回してヘッダ改ざん・誤配布・ログ汚染が起きる。
    - 満たす：アプリ・リバプロ・CDN・ログ基盤で **制御文字拒否/正規化を一貫**させ、キャッシュ/ログを“境界装置”として設計・監視できる状態にする。
- WSTG：
  - 該当カテゴリ/テスト観点：レスポンス分割（HTTP Response Splitting）、ヘッダインジェクション、キャッシュ関連の誤動作、ログ/監視の信頼性
  - このファイルでの焦点：**分割が成立した後**に「どの中継点へ波及するか」「どこで証跡が残るか」を観測と相関で固める。
- PTES：
  - 該当フェーズ：脆弱性分析 → 侵害評価（影響半径の確定）→ 報告（再発防止の設計要件）
  - 前後フェーズとの繋がり（1行）：`05_input_20_crlf_injection_01_response_splitting` で成立根拠を固め、ここで **下流の境界装置（proxy/cache/log）への波及**を評価して実害と対策要件を確定する。
- MITRE ATT&CK：
  - 該当戦術：Initial Access / Defense Evasion / Impact（条件付き）
  - 攻撃者の目的：アプリの手前（CDN/Proxy）で“配布・観測・監査”を壊し、誤配布（キャッシュ）や監視回避（ログ汚染）を狙う。

---

## タイトル
CRLF Injection（Downstream）：Proxy/Cache/Logが“境界（CRLF）”を再解釈する場所で、アプリの防御が空転する

---

## 目的（この技術で到達する状態）
- Response Splittingの成立可否だけで止めず、**下流（CDN/Reverse Proxy/共有キャッシュ/ログ基盤）まで含む“実害”**を境界で評価できる。
  - どの下流コンポーネントが影響を受けるか（資産境界）
  - どの変換/正規化/再構築点が成立条件か（信頼境界）
  - どの境界が破れると重大度が跳ね上がるか（権限境界：ユーザ/テナント/管理/配布）
  - 証跡（proxyログ/キャッシュログ/監視ログ）を相関して「どこで割れたか」を説明できる
  - 修正を“アプリの入力検証”だけに閉じず、**エッジ〜ログまでの一貫要件**に落とせる

---

## 前提（対象・範囲・想定）
- 対象：
  - 1) リバースプロキシ/CDN配下のWebアプリ（典型：CDN → WAF → Reverse Proxy → App）
  - 2) ログ/監視が別基盤へ転送される環境（例：アクセスログ→集約、WAFログ→SIEM）
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - CDN/Proxyが「圧縮」「キャッシュ」「リダイレクト」「エラー生成」「ヘッダ追加」を行う（=再構築点がある）
- できること/やらないこと（安全に検証する範囲）：
  - やる：成立点の“観測”と“相関”（小さな差分で証跡を取る）
  - やらない：第三者影響が出る可能性がある検証（共有キャッシュの汚染拡散等）を、合意なしに増やさない
- 依存する前提知識（必要最小限）：
  - HTTPレスポンスの構造（ヘッダ行/空行/ボディ）
  - キャッシュ階層の概念（CDN/Proxy/ブラウザ）とキー（Vary等）
  - ログが“真実”ではなく“入力”で壊れ得ること（監査の信頼境界）

---

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - 1) 受信レスポンスのヘッダ形状（ヘッダ増減・重複・空行・境界系ヘッダ）
  - 2) 中継点が付与する情報（キャッシュ状態、経路情報、変換情報：出る範囲で）
  - 3) 下流ログ（proxy/cdn/waf/app/log集約）の“行構造”と“相関キー”
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：
    - どの層が自社管理（App/Proxy）で、どこからが第三者（CDN/WAF/ログSaaS）か
  - 信頼境界（外部連携・第三者・越境ポイント）：
    - “ヘッダ反映値”が App → Proxy → CDN → Browser へ渡る経路
    - ログ転送（エージェント/ストリーム）により、**入力が別システムへ伝播**する経路
  - 権限境界（権限の切替/伝播/委任）：
    - キャッシュにより「認証/認可の後段」がバイパスされる境界（=配布境界）
    - ログが監査・検知の根拠になる境界（=検知境界）
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - 変化点A：レスポンスヘッダ行数/同名ヘッダ数/ヘッダ終端（空行）位置
  - 変化点B：キャッシュ状態（hit/miss/age等、出る範囲）
  - 変化点C：ログの“1リクエスト=1行”前提が崩れる兆候（改行混入/JSON崩壊/フィールドずれ）
  - 変化点D：中継点の生成レスポンス（エラー/リダイレクト/変換）が起点になっている兆候

---

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が“確定”できるか：
  - 「境界文字が下流で再解釈され、ヘッダ/ログ/キャッシュのいずれかが“期待しない形”になる」こと（=下流影響の成立）
  - どの層（CDN/Proxy/Origin/Log pipeline）が再解釈点か（ログ相関が取れる場合）
- 何が“推定”できるか（推定の根拠/前提）：
  - 配布範囲（共有キャッシュか/キーに何が含まれるか）※ただし `05_input_19_cache_poisoning_*` の手順で補強が必要
  - ログ汚染がSIEMや検知ルールへ与える影響（実装・パーサ依存）
- 何は“言えない”か（不足情報・観測限界）：
  - “第三者へ配布された”断定（実害の断定）は、キャッシュログ/キー/serve証拠がない限り言えない
  - “検知回避が成功する”断定は、実際のパーサ・検知基盤・相関ロジックが分からない限り言えない
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：アプリで拒否され下流影響なし（ヘッダ形状・ログ行構造が保たれる）
  - パターンB：アプリは拒否するが、下流が独自生成レスポンスで反映してしまう（エッジ起点）
  - パターンC：ヘッダ改ざんは起きるが、キャッシュは効かない（影響は単発・局所）
  - パターンD：ヘッダ改ざん＋キャッシュ格納条件が変わる（Poisoningに接続し得る）

---

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す“狙い目”：
  - 中継点が「キャッシュ」「リダイレクト」「エラー生成」「ヘッダ追加」をしている＝再解釈点が多い
  - ログが外部基盤へ転送されている＝“入力が拡散する”ため、監査/検知を壊す余地が増える
- 優先度の付け方（時間制約がある場合の順序）：
  1) 共有キャッシュが絡む（影響半径が広い）可能性がある経路（CDN配下のHTML/3xx/4xx/5xx）
  2) “境界ヘッダ”に到達する経路（Location / Set-Cookie / Cache-Control / CORS / Content-Disposition）
  3) ログ基盤のパースが壊れる兆候がある経路（構造化ログ・JSONログ・SIEM転送）
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：Proxy/Cacheを巻き込んだ誤配布（Cache-Control等の境界ヘッダが影響する場合）
  - 攻め筋2：ログ汚染（Log Poisoning）による監査の信頼性破壊（検知・追跡の困難化）
  - 攻め筋3：エラー/リダイレクトの下流生成を起点にした“アプリ防御の空転”（境界が別層にある）
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - CDNログが取れない場合：ブラウザ観測（ヘッダ形状/時間差）とOriginログで“層差”を取る
  - ログ基盤が第三者SaaSの場合：パース仕様が不明＝断定を避け、**行構造の破壊/相関不能**という事実で所見化する

---

## 次に試すこと（仮説A/Bの分岐と検証）
> ここが最重要。条件が違うと次の手が変わる形で書く。

- 仮説A：影響はProxy/Cacheで顕在化している（エッジ起点）
  - 成立条件：
    - 中継点がレスポンスを生成/改変しており（リダイレクト、エラー、圧縮、キャッシュ等）、
    - その生成/改変処理が“反映値”を信頼してしまう
  - 次の検証：
    - Origin直（可能なら）とエッジ経由で同一リクエストのレスポンス形状を比較し、どの層で形状が変わるかを確定
    - エッジのキャッシュ状態（hit/miss、age等）と同時に、レスポンスが“格納され得る”条件（Cache-Control/Vary）を観測
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功：エッジ経由のみヘッダ形状が崩れる/追加される、またはキャッシュ関連シグナルが変化する
    - 失敗：Origin直と差がない（下流では正規化/拒否されている可能性が高い）

- 仮説B：影響はログ基盤（収集/整形/転送）で顕在化している（監査境界が壊れる）
  - 成立条件：
    - ログが“行区切り”や“構造化（JSON/CSV）”で扱われ、
    - 入力がログ項目（URL/UA/Referer/エラー文言/ヘッダ値等）へ反映される
  - 次の検証：
    - アクセスログ・アプリログ・WAFログの同一リクエストを相関し、「1リクエスト=1イベント」の前提が崩れていないか（改行混入/欠落/フィールドずれ）を確認
    - ログ集約後（SIEM等）での見え方が変わるなら、転送/パーサ層が再解釈点
  - 期待する観測：
    - 成功：特定入力のときだけログが分割/欠損/相関不能になる（request_id等で追えない）
    - 失敗：ログは正規化され保持される（少なくとも“ログ汚染”は成立しにくい）

- 仮説C：影響はキャッシュ配布（第三者影響）へ波及し得る
  - 成立条件：
    - (1) レスポンス形状が変わり、(2) キャッシュ格納条件が満たされ、(3) 共有キャッシュで再利用される
  - 次の検証：
    - ここから先は `05_input_19_cache_poisoning_03_poisoned_object` の“Store/Serve/Radius”で評価する（検証回数を増やさない）
  - 期待する観測：
    - 成功：store/serveの証跡（ヒット、Age増加、ログ相関）が取れる
    - 失敗：キャッシュ不可（no-store/private）で止まる、またはキーにより分離される

---

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - `04_labs/02_web/05_input/20_crlf_injection_02_downstream_proxy_log_cache/`（新規作成候補）
- 参照ファイル：
  - `05_input_20_crlf_injection_01_response_splitting（header_body）.md`
  - `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- 取得する証跡（目的ベースで最小限）：
  - クライアント観測：HTTPレスポンス（ヘッダ形状）、タイミング差
  - Proxy/CDN観測：hit/miss、生成レスポンス（エラー/リダイレクト）、可能ならキー情報
  - ログ観測：アクセスログ（生ログ）、集約後ログ（SIEM側）、相関キー（request_id等）
- 観測の取り方（どの視点で差分を見るか）：
  - 視点1：Origin直 vs エッジ経由（層差）
  - 視点2：同一URLで入力差分1軸（再現性）
  - 視点3：レスポンス形状 vs ログ行構造（配布と監査の2軸）

---

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は“手段”であり“結論”ではない。必ず「何を観測している例か」を添える。

~~~~
# 例：目的は「層差（Origin直/Proxy経由）」と「レスポンス形状（ヘッダ/空行）」の比較。
# - 同一リクエストを2経路で取得し、ヘッダ数・同名ヘッダ・境界系ヘッダ（CL/TE/Location/Set-Cookie等）を比較する。
# - ログ側は request_id 等で相関し、「1リクエスト=1行」が崩れる兆候（改行、フィールドずれ）を探す。

# 例：アクセスログの観測観点（形式は環境依存）
# - request_id / remote_addr / host / request_uri / status / bytes / referer / ua
# - ヘッダ反映点があるなら、その値がログ項目へ入っていないか（=ログ汚染の入口）
~~~~

- この例で観測していること：
  - どの層でレスポンス形状が変わるか（再解釈点の特定）
  - ログが“構造”を保っているか（監査境界の健全性）
- 出力のどこを見るか（注目点）：
  - レスポンス：ヘッダ増減、同名ヘッダの重複、境界系ヘッダの不整合
  - ログ：改行混入、欠落、相関不能（request_id不一致）
- この例が使えないケース（前提が崩れるケース）：
  - Origin直到達が不可能（CDN必須）で層差が取れない
  - ログが完全に正規化され、入力が生ログに残らない（ただし“正規化される事実”自体は防御根拠になる）

---

## 参考（必要最小限）
- HTTP Semantics / Message Format（RFC 9110 / RFC 9112）
- OWASP：HTTP Response Splitting / CRLF Injection（概念整理）
- ベンダ固有（CDN/Proxy/WAF/ログSaaS）の「正規化」「キャッシュキー」「ログフォーマット」仕様（対象環境の一次情報を優先）

---

## リポジトリ内リンク（最大3つまで）
- 関連 topics：
  - `05_input_20_crlf_injection_01_response_splitting（header_body）.md`
  - `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- 関連 playbooks：
  - `02_playbooks/02_web_recon_入口→境界→検証方針.md`
- 関連 labs / cases：
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
