## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回）

- ASVS：
  - 目的：SQLi（CWE-89）を「入力→SQL構文」越境として防ぐ（主に検証・サニタイズ・エンコード／安全なクエリ機構／エラーハンドリング／最小権限）
  - このファイルで扱う管理策：
    - パラメータ化（プレースホルダ）を“万能薬”にせず、**動的SQL組立（ORDER/LIMIT/IN/識別子/断片）**の境界を別枠で制御する
    - DBコネクタ設定（例：multi-statements）を“境界条件”として固定し、攻撃面を縮退させる
    - 例外・エラー差分を「存在オラクル／型オラクル／実装漏えい」にしない（観測点の縮退）
- WSTG：
  - WSTG-INPV-05（Testing for SQL Injection）を中核に、入力点ごとのコンテキスト（文字列/数値/識別子/式）を確定し、差分観測で成立根拠を固める
- PTES：
  - Vulnerability Analysis：入力点→SQL境界の同定、方言差分の当て込み、再現性のある最小差分PoC
  - Exploitation：契約範囲内で影響（読み取り/改ざん/認可迂回）を“必要最小限”で実証（過剰なデータ抽出は避ける）
  - Reporting：根本原因（動的組立・コネクタ設定・ORM誤用）と修正指針（設計変更）をセットで提示
- MITRE ATT&CK：
  - TA0001 Initial Access / TA0009 Collection / TA0006 Credential Access（アプリDBに資格情報がある場合）/ TA0005 Defense Evasion（エラー差分を利用した低ノイズ探索）
  - 代表例：T1190 Exploit Public-Facing Application（SQLiは典型的な入口）

# SQL Injection（MySQL）：境界_プレースホルダ_動的組立

## 目的（この技術で到達する状態）

- MySQL を使うWeb/APIで、SQLiを「入力→SQL実行」越境として**境界モデル化**し、次を“再現性”をもってできる状態になる。
  1) プレースホルダ（Prepared Statement）で守れている範囲／守れていない範囲を切り分ける  
  2) 守れていない典型である **動的SQL組立（ORDER/LIMIT/IN/識別子/断片）** を、黒箱でも差分観測で特定する  
  3) MySQL 方言（Oracle/PostgreSQL/MSSQLとの差分）を「成立根拠」として整理し、誤検知・見落としを減らす  
  4) 修正を「エスケープ強化」ではなく、**設計（組立禁止・allowlist・クエリ生成器）**に落とす

## 前提（対象・範囲・想定）

- 対象：
  - 典型：Webフォーム／REST／GraphQL／管理UI／検索・フィルタ・ソート・ページングがある画面
  - DB：MySQL / MariaDB（方言・機能差はあるが、まずMySQL基準で整理する）
- 想定される実装：
  - ドライバ：JDBC、PHP mysqli/PDO、Node mysql/mysql2、Go database/sql、Python MySQLdb 等
  - ORM/Query Builder：Sequelize/TypeORM/Prisma/Knex、Hibernate（方言はMySQL）等
- スコープ（本ファイルの焦点）：
  - **プレースホルダの境界**：値のバインドは安全でも、SQL“構文”側に入力が混ざると破綻する
  - **動的組立**：ORDER BY / LIMIT / テーブル名・カラム名 / INリスト / 条件断片（WHERE句の部分）など
  - **コネクタ設定**：複文（multi-statements）やエミュレートドプリペア（client-side prepare）が境界を崩す
- 非スコープ（ただし“影響”として言及はする）：
  - 大量データ抽出の手順化、破壊的検証（本リポジトリは「意味→判断→次の一手」優先）

## 観測ポイント（何を見ているか：プロトコル/データ/境界）

### 1) まず切るべき境界：値（data）と構文（code）のどちらに入っているか

- 値（data）に入る（本来安全にできる領域）
  - 例：WHERE name = ?、WHERE id = ?、INSERT values (?)、LIKE ?（%を含めて値として渡す）
  - 正攻法：プレースホルダ + 型（数値/文字/日付）で縛る
- 構文（code）に入る（プレースホルダで守れない・守りにくい領域）
  - 例：ORDER BY {user_input}、LIMIT {user_input}、IN ({csv})、WHERE {fragment}、SELECT {columns}
  - 正攻法：**allowlist（選択肢）**＋サーバ側でマッピング（列名や方向を“入力値そのもの”で使わない）

> 重要：SQLi の実務的な半分以上は「値のエスケープ漏れ」ではなく、**構文側の動的組立**か、**ORMのraw断片**で発生する。

### 2) MySQL特有の“差分＝成立根拠”（他方言との比較で見落としを減らす）

#### 2.1 コメント構文（観測で方言を当てる／成立条件の根拠）
- MySQL：
  - `-- `（**後ろにスペース必須**になりやすい実装が多い）
  - `#`（MySQLでよく出る。Oracle/PostgreSQLでは一般的ではない）
  - `/* ... */`（共通だが、方言で許容差がある）
- 差分の意味：
  - 「コメントで後続を無効化できるか」は、**入力が構文に混ざっている**強い証拠になる
  - `#`が効くならMySQL（またはMySQL互換）である可能性が上がる

#### 2.2 識別子のクォート
- MySQL：バッククォート `` `col` `` が頻出
- Oracle/PostgreSQL：主にダブルクォート `"col"`（意味は“大小区別の識別子”）
- 差分の意味：
  - ORDER BY / SELECT列の“列名注入”は、識別子クォートの差分がそのまま成立条件になる
  - 例：バッククォートがエラー文に出る／アプリがバッククォートで組立している → MySQL方言の強い根拠

#### 2.3 文字列エスケープとSQL MODE（成立条件が“設定”で変わる）
- MySQLは `\` エスケープや SQL MODE（例：ANSI_QUOTES / NO_BACKSLASH_ESCAPES 等）で挙動が変わりやすい
- 差分の意味：
  - 「同じ入力でも環境で成立/不成立が揺れる」＝**実装依存の境界**（再現性の担保が必要）
  - WAFやミドルで正規化が入ると、さらに差分が増える（“観測点”が増える）

#### 2.4 連結（concat）の方言差
- Oracle：`||` が文字列連結の主役
- MySQL：一般には `CONCAT(a,b)` が主役（`||` はSQL MODE等で意味が変わることがある）
- 差分の意味：
  - 連結を前提とした検証は、**Oracle向けの当て込みがMySQLで外れる**（誤検知や手戻りの原因）

#### 2.5 複文（stacked queries）成立の“境界条件”
- MSSQL：バッチ境界（; や GO 等）で複文が成立しやすい文化がある
- MySQL：複文は**ドライバ設定**に依存（例：Nodeの `multipleStatements`、PHP PDOの属性、JDBCのallowMultiQueries等）
- 差分の意味：
  - 「複文が通る/通らない」は MySQLi の影響度を大きく変えるが、**脆弱性の有無（SQL構文化）とは別軸**
  - まずは“構文化”を立証し、その後に“複文可否（設定）”を追加で判定する

### 3) 黒箱で動的組立を見抜く観測（UI/HTTPからの境界推定）

#### 3.1 “ソート/フィルタ/ページング”は動的組立の温床
- 典型的に入力が構文側へ入りやすいパラメータ：
  - sort / order / direction / columns / fields / q / filter / where / ids / limit / offset / pageSize
- 観測の要点：
  - 値が増えるとSQL実行計画・レスポンス時間が変わる（ただし時間差はノイズが大きいので単独証拠にしない）
  - エラーが出るなら、**同じエンドポイントで“1変数だけ”揺らして差分**を取る

#### 3.2 “INリスト”と“可変条件”の組立臭
- INリスト：
  - 安全：`IN (?, ?, ?)` のように要素数分プレースホルダが増える（黒箱では直接見えない）
  - 危険：`IN (${csv})` のようにCSV文字列を組立している（数が増えるほどエラー差分が出やすい）
- 可変条件（WHERE断片）：
  - ORMの `raw` / `literal` / `where: sequelize.literal(...)` 等が入ると、入力が断片化して混ざる

#### 3.3 エラーは「漏えい」と「オラクル」の両面で観測点
- 観測するもの（最小）：
  - HTTPステータス、エラーコード、メッセージの有無、レスポンスサイズ、レスポンス時間
  - 同一入力を繰り返した時の揺れ（再現性）
- MySQLらしさのヒント（ただし決め打ちしない）：
  - 文言に “MySQL”, “MariaDB”, “You have an error in your SQL syntax” 等が出るケース
  - ただしフレームワークがメッセージを置換するので、**差分観測が本体**

### 4) プレースホルダの“安全神話”を壊す観測（守れていない箇所を見つける）

- 守れている：値はバインドされ、クォートや演算子として解釈されない
- 守れていない（MySQLで頻出）：
  1) **プレースホルダにできない構文要素**（列名・テーブル名・ソート方向・演算子・関数名）を入力で渡している
  2) “LIKEの%”や“INリスト”などの都合で、SQL文字列側で連結している
  3) エミュレートドプリペア等で、結局クライアント側で文字列展開している（設定依存）
  4) “安全なクエリ＋危険な断片”の混在（WHERE断片、ORDER断片）

## 結果の意味（その出力が示す状態：何が言える/言えない）

### 1) 「SQLiがある」を言える条件（最小差分での確定）

- 次が揃うと、黒箱でも“構文化”を主張しやすい：
  - 同一エンドポイントで、1つの入力だけを変える
  - その入力の変化に対し、**SQLパーサ由来の差分**（構文エラー／型エラー／演算子解釈差／コメントによる後続無効化差）が再現する
  - さらに、入力位置（文字列/数値/識別子/断片）を推定できる

> 逆に、単発の500や単発の遅延だけでは主張しない（ネットワーク、バックエンド混雑、アプリ例外が混ざる）。

### 2) 「MySQL方言」を言える条件（断定ではなく根拠の積み上げ）

- `#` コメントやバッククォート、MySQL特有の文言など、**複数の根拠が一致**したときに初めて「MySQL（互換）」を主張する
- ただし、アプリ層でエラーメッセージが加工されると“方言当て”は難しい  
  → 方言当ては目的ではなく、**検証の当て込み（成立根拠）**に使う

### 3) 「プレースホルダがあるから安全」を否定できる条件

- 観測上、値のバインドっぽい挙動でも、次が見えたら危険領域が残る：
  - sort/direction/fields/limit 等が効いている（＝構文側が動いている）
  - 一部入力だけが“別扱い”になり、エラー差分が出る（＝断片が混ざっている）
  - 例外が“SQL構文”に寄る（＝文字列連結でSQLを組立している可能性）

### 4) 何が言えないか（レポートで線を引く）

- 言えない（または追加検証が必要）：
  - “データが抜ける”断定（影響は契約・権限・DB権限で大きく変わる）
  - “複文が可能”断定（MySQLはドライバ設定に依存）
  - “DBがMySQL”断定（互換DB/抽象化/エラー隠蔽がある）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）

> 本章は「悪用手順」を書くのではなく、ペンテストの意思決定（優先順位付けと、次に何を確かめるべきか）を明文化する。

### 1) 優先度が上がる“入口”（MySQLで実務的に刺さりやすい）

- 管理画面の検索/一覧（sort/filter/page）
- 複雑なレポート・エクスポート（列選択、並べ替え、集計条件）
- マルチテナント（tenant_id / org_id）で、条件断片が増える箇所
- “柔軟検索”を謳う機能（where=... のような DSL を受ける設計）

理由：
- これらは「仕様上、SQL構文を動的にする誘惑」が強い
- その結果、プレースホルダで守れない領域（識別子/断片）に入力が入りやすい

### 2) MySQLにおける“成立根拠”の作り方（差分を設計する）

- まず狙うのは「構文が壊れる/変わる」差分（低ノイズ）
  - 文字列コンテキスト：クォートの整合、エスケープの有無
  - 数値コンテキスト：数値以外の扱い（型エラー/暗黙変換）
  - 識別子コンテキスト：バッククォート等で崩れ方が変わる
  - 断片コンテキスト：演算子やAND/ORの解釈差が出る
- 次に狙うのは「実行が変わる」差分（時間・内容差）
  - ただし時間差はノイズが大きいので、**最小遅延・複数回一致**を原則とする

### 3) 方言差分を“検証設計”に使う（Oracle/PostgreSQL/MSSQLとの比較）

- Oracleとの差分（成立根拠として使う）：
  - 連結：Oracleは `||` が中心、MySQLは `CONCAT()` が中心
  - ダミーテーブル：Oracleは DUAL、MySQLは必須ではない
  - したがって、Oracleの当て込みで効いたテストがMySQLで外れるのは自然  
    → “外れた＝安全”ではない（方言差を疑う）
- PostgreSQLとの差分：
  - Postgreは `::` 型キャストや `pg_sleep` などが象徴
  - MySQLは暗黙変換が多く、型エラーの出方が違う（成立根拠の取り方が違う）
- MSSQLとの差分：
  - MSSQLはバッチ境界の文化が強いが、MySQLは**ドライバ設定**が支配的
  - よって “複文での影響拡大” は最後に確認（先に構文化を確定）

### 4) 防御側の観点（攻撃者が嫌がる設計に落とす）

- 動的組立を許すなら、入力は“SQL文字列”ではなく“選択肢”に落とす（allowlist）
- 例：
  - sort=createdAt → `ORDER BY created_at`
  - direction=desc|asc の2択
  - limit は上限固定（max 100 等）
  - fields は許可列の集合からサーバ側で組立（入力値を列名として使わない）
- そして“設定境界”を閉じる：
  - MySQLドライバの multi-statements を無効
  - ORMの raw/literal を禁止 or 封じ込め（レビュー対象に）

## 次に試すこと（仮説A/Bの分岐と検証）

### 全体方針：小さく確かめ、境界を固定し、根本原因まで落とす

- 1回で“完全証明”しない。  
  「この入力はSQL“値”に入る」/「この入力はSQL“構文”に入る」をまず確定し、その後に影響へ進む。

### 仮説A：動的組立（構文側）に入力が混ざっている

#### A-1) ソート/ページングを起点に“構文コンテキスト”を確定する
- 対象パラメータ：sort / order / dir / limit / offset / fields / columns
- 観測設計：
  - 正常値（想定どおり動く）をベースラインにする
  - 1項目ずつ変え、次を記録：
    - ステータス、レスポンスサイズ、エラー文言の有無、レスポンスタイム
- 期待する根拠（例）：
  - sortの値が変わると結果順が変わる → **ORDER BYが動的**
  - limitが大きいと遅い／小さいと速い → **LIMITが動的**（ただしノイズ注意）
  - 不正な列名で“SQL由来のエラー差分” → **列名がそのまま入っている可能性**

#### A-2) “allowlist不在”を疑う指標（設計起因の脆弱性）
- sort=任意文字列でも受理される
- fields=任意の列名が通る（あるいは通ったり落ちたりする）
- where=のような自由入力DSLがある
- GraphQLのorderBy等で、列名がユーザ指定になっている

#### A-3) レポートに落とす根本原因（修正可能な形）
- “SQLi”を一言で終わらせず、どの境界が破れているかを書く：
  - 例：ORDER BY の識別子（列名）を入力値で組立している（プレースホルダ不可領域）
  - 例：INリストをCSV文字列連結で組立している（可変プレースホルダ未使用）
  - 例：ORMの raw 断片に入力が流入している（literal/fragment）

### 仮説B：値はプレースホルダで守れている（ただし“穴”が残る可能性）

#### B-1) プレースホルダが効いている時の観測（安全側の根拠）
- 入力に“構文っぽい文字”を含めても、構文エラー差分が出ない
- エラーが出るとしても、アプリ側のバリデーション（400等）で止まる
- 同じ入力変化で結果が“論理的に”変わる（検索語の一致など）だけで、異常差分がない

#### B-2) それでも残りがちな穴（MySQLで頻出）
- LIKE検索で `%{q}%` をSQL文字列側で連結している（値境界のはずが崩れる）
- INリストの要素数が可変で、文字列連結している
- LIMIT/OFFSET を文字列連結している（数値だから安全、が崩れる）
- JSON検索や正規表現検索で、式（関数引数）が断片化している

#### B-3) “修正済みの確認”まで含めた検証
- 修正後は、同じ観測設計で差分が消えることを確認する
- さらに設定境界（multi-statements無効、ORM raw禁止）も固定したかを確認する

### 仮説C：複文（stacked queries）が成立する（影響拡大の別軸）

- MySQLはドライバ設定で成立するため、主張には根拠が必要：
  - 例：アプリが `multipleStatements` 相当を有効化している、など（可能なら設定根拠）
- 黒箱での注意：
  - “複文を試す”検証は影響が大きくなりやすい  
    → 契約範囲と安全性（破壊的操作の回避）を優先し、**必要最小限**にする

### 具体例（最小限の例示：意味→判断→次の一手）

> ここでは「どの形が危険か」を理解するための“形”だけを示す。実際の送信は必ず許可された検証環境・契約範囲で行う。

~~~~
# 危険：動的ORDER BY（列名はプレースホルダ化できない）
SELECT * FROM items ORDER BY {sort} {dir} LIMIT ?

# 安全：入力は選択肢→サーバ側で列名にマップ
sort=createdAt|price|name のように受け、サーバで
createdAt -> created_at
price     -> price
name      -> name
に変換してSQL文字列を生成する（入力値をそのまま入れない）
~~~~

~~~~
# 危険：INリストをCSVで連結
SELECT * FROM items WHERE id IN ({csv_ids})

# 安全：要素数分プレースホルダを展開
SELECT * FROM items WHERE id IN (?, ?, ?, ...)
~~~~

~~~~
# 危険：LIKEの%をSQL文字列側で連結（断片化）
... WHERE name LIKE '%" + q + "%'

# 安全：%を含めて値としてバインド
... WHERE name LIKE ?
param = "%" + q + "%"
~~~~

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回）

- ASVS：
  - V5（Validation / Sanitization / Encoding）を中心に、SQLiを“入力→実行”越境として防ぐ
  - 追加で重要：エラー処理（情報漏えい防止）、ログ（相関ID）、最小権限（DBユーザ権限）
- WSTG：
  - WSTG-INPV-05（SQL Injection）：
    - 入力点ごとにコンテキストを確定（文字列/数値/識別子/断片）
    - MySQL方言（コメント/識別子クォート/SQL MODE/複文設定）を“成立根拠”として使う
- PTES：
  - Vulnerability Analysis：動的組立の同定、方言差分での当て込み、差分観測での立証
  - Exploitation：影響実証は必要最小限（過剰抽出・破壊的検証を避ける）
  - Reporting：根本原因（動的組立・ORM raw・ドライバ設定）と再発防止（allowlist/設計）を明記
- MITRE ATT&CK：
  - T1190（公開アプリの脆弱性悪用）に接続
  - Discovery/Collectionへ連鎖し得るが、レポートは“到達可能性”と“前提（権限・設定）”を分離して記述する

## 参考（必要最小限）

- OWASP Web Security Testing Guide - Testing for SQL Injection  
  https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection
- OWASP Cheat Sheet Series - SQL Injection Prevention Cheat Sheet  
  https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
- OWASP Top 10 2021 - A03 Injection（背景整理）  
  https://owasp.org/Top10/2021/A03_2021-Injection/
- IPA（参考：プレースホルダ/動的組立のリスク整理に有用）  
  https://www.ipa.go.jp/security/vuln/ps6vr70000011hc4-att/000017321.pdf
