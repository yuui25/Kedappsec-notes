## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - この技術で満たす/破れる点：重要操作の再認証（step-up）要件、認証強度（AAL相当）の引き上げ、セッションの“認証強度”属性付与と失効、再認証のCSRF耐性（13と同型）、再認証トークン/チャレンジのスコープ管理
  - 支える前提：ログインが堅牢でも、重要操作が“古いセッションのまま”通ると実害が最大化する（侵害後の被害抑止の中心）
- WSTG：
  - 該当テスト観点：Authentication Testing / Session Management（Re-authentication for Sensitive Actions、CSRF、Session Timeout）
  - どの観測に対応するか：重要操作の境界列挙→step-up要求→チャレンジ→完了→強度付与→期限切れ/失効を観測する
- PTES：
  - 該当フェーズ：Vulnerability Analysis（境界欠落/例外パスの抽出）、Exploitation（許可範囲での最小検証：テストアカウント）
  - 前後フェーズとの繋がり（1行）：13（state/CSRF）と同じ“状態遷移”の安全性を使い、15（同時セッション）と結合して「侵害セッションが重要操作まで到達できるか」を評価する
- MITRE ATT&CK：
  - 戦術：Privilege Escalation / Defense Evasion / Impact
  - 目的：既存セッション（盗用/放置端末）で重要操作（MFA解除、メール変更、送金等）を通す、または再認証境界を迂回して被害を最大化（※手順ではなく成立条件の判断）

## タイトル
step-up_再認証境界（重要操作_再確認）

## 目的（この技術で到達する状態）
- “重要操作” を体系的に列挙し、どの操作が step-up（再認証）で守られるべきか、現状の境界がどこにあるかを証跡つきで説明できる
- step-up を「単にパスワードを再入力させるUI」ではなく、認証強度（AAL相当）・セッション属性・期限・失効・例外パスまで含む設計として評価できる
- エンジニアが直すべき点を「何をトリガに」「どのチャレンジで」「どこに強度を保存し」「いつ失効させるか」まで落とし込める
- 後続（17 refresh rotation、18 token binding、19 passkeys、20 magic-link）へ、再認証境界が“トークン/端末/検知”とどう結合するべきかの入力を渡せる

## 前提（対象・範囲・想定）
- 対象：再認証が必要になり得る“重要操作”全般（サービス種別により差がある）
  - アカウント防御系：パスワード変更、メール/電話変更、MFA登録/解除、回復コード再発行、セキュリティ設定変更
  - 資産・権限系：支払い手段追加/削除、送金/購入/退会、権限付与、APIトークン発行、組織設定変更
  - セッション系：全端末ログアウト、端末信頼解除、セッション失効（15と接続）
- 想定する境界：
  - RP単体、またはSSO（IdP）連携。step-upがRP側/IdP側のどちらで実施されるかが分かれる
  - フロント（UI）とバック（API）が分離しており、“API直叩き” が例外パスになりやすい
- 安全な範囲（最小検証の基本方針）：
  - テストアカウントで、重要操作を実際に変更しない範囲の観測（可能なら “確認画面まで” で切り分け）
  - 例外パス検出は、UIとAPIの差分観測で行う（過度な試行はしない）
  - 本番相当での変更を伴う検証は、許可と巻き戻し手順（監査含む）が前提

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
### 1) step-up を「境界モデル」として定義する（何を満たすと通るのか）
step-upは一般に以下の要素で成立する。観測は要素ごとに分解する。
- トリガ（Trigger）：
  - どの操作で step-up が要求されるか（操作の種類/リスク/金額/権限）
  - どの条件で省略されるか（信頼端末、直近の再認証、同一セッション内の猶予）
- チャレンジ（Challenge）：
  - 再入力（パスワード）/OTP/Push承認/パスキー/WebAuthn/セキュリティキー
  - SSOの場合は IdP 側で追加認証（MFA要求やAAL引き上げ）
- 付与（Grant）：
  - “このセッションは強度が上がった” をどこに記録するか（サーバセッション属性、別トークン、クレーム）
- 期限（TTL）：
  - 強度付与はどれだけの時間/操作回数で有効か（数分、1操作のみ等）
- 失効（Revocation）：
  - ログアウト/全端末ログアウト/パスワード変更で消えるか
  - セッション更新（再ログイン）で引き継がれないか（引き継ぐなら条件と監査が必要）

### 2) “重要操作リスト” を作る（ペネトレで漏れやすい）
重要操作はプロダクトごとに違うが、ペネトレ視点で漏れやすいカテゴリを固定して列挙する。
- アカウント保護（ATO拡大）：
  - MFA解除/追加、回復情報変更、回復コード再発行、メール変更、端末信頼設定
- 権限/組織（権限境界）：
  - ロール変更、メンバー招待、所有者移譲、APIキー発行、Webhook設定
- 金銭/契約（実害）：
  - 支払い方法、請求先、購入、返金、退会
- データ取り出し（情報漏洩）：
  - データエクスポート、バックアップDL、ログDL
- セキュリティ設定（防御解除）：
  - 監査ログ削除、通知オフ、ログイン通知無効化

観測の第一歩は「機能→操作→API」を対応付けて、step-upが掛かる境界を探すこと。

### 3) UIだけで判断しない：API/モバイル/バッチが例外パスになりやすい
- よくある破綻
  - UIでは step-up するが、同じ操作のAPIエンドポイントは step-up なしで通る
  - モバイルAPIだけ“信頼端末扱い”で省略される
  - GraphQL/バッチ系エンドポイントが step-up 判定を経由しない
- 観測の作法
  - “同一操作” のUI経由とAPI直叩きの差分を、HARとAPIログで証跡化する
  - 入口が複数ある場合（web/mobile/api）、15（concurrency）と同じく例外パスを探す

### 4) step-up の状態管理：セッション属性か、別トークンか
- パターンA：サーバセッションに `auth_level=2` のような属性を付与
  - 観測焦点：属性付与のタイミング、TTL、ログアウト/失効で消えるか
- パターンB：step-up専用トークン（短命・単回）を発行し、重要操作で提示させる
  - 観測焦点：スコープ（どの操作に使えるか）、単回性、盗用耐性（18と接続）
- パターンC：IdP発行トークンのクレームで強度を表現（acr/amr等）
  - 観測焦点：RPがクレームを検証しているか、強度不足で重要操作が通らないか

重要：強度を“UI側のフラグ”だけで持つ設計は危険（API直叩きで崩れる）。

### 5) 再認証のCSRF/取り違え耐性：13のstate設計がそのまま必要
- step-up は “未認証→認証済み” に近い状態遷移をもう一度起こすため、13と同型のリスクがある
- 観測焦点
  - step-up開始/完了にCSRFトークンやtransaction stateがあるか
  - リダイレクトやreturn_to（重要操作の戻り先）が安全に束縛されているか
  - step-up完了が別タブ/別操作に取り違えられないか（トランザクション束縛）

### 6) 通知/監査：step-upは“防御の起点”なのでログが必須
- 観測対象
  - step-up成功/失敗ログ（user_id、device_id、ip、ua、操作種別）
  - 重要操作の監査ログ（誰が何を変更したか）に step-up の有無が紐付くか
  - 通知（メール/プッシュ）に “重要操作前の再認証” が記録されるか（要件次第）
- ペネトレでの価値
  - 防御設計の妥当性（強制されているか）だけでなく、侵害時のトリアージ可能性を評価できる

### 7) stepup_key_boundary（後工程に渡す正規化キー）
- 推奨キー：stepup_key_boundary
  - stepup_key_boundary = <operation_class>(acct|auth|priv|money|export|security) + <entrypoint>(ui|api|mobile|mixed) + <trigger>(always|risk|none|unknown) + <challenge>(pwd|otp|push|webauthn|idp_mfa|unknown) + <grant_store>(server_attr|token|idp_claim|ui_only|unknown) + <ttl_hint> + <revoke_rules>(logout|pwd_change|all_devices|none|unknown) + <confidence>
- 記録の最小フィールド（推奨）
  - operation（具体操作名）
  - operation_class
  - entrypoint（UI/API等）
  - challenge_type / provider（RP/IdPどちら）
  - grant_store / ttl_hint
  - bypass_candidate（例外パスの兆候）
  - audit_log_link（監査ログの有無/相関キー）
  - evidence（HAR、Cookie差分、設定断片、監査ログ）
  - action_priority（P0/P1/P2）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定できる）：
  - 重要操作に step-up が掛かる/掛からないの境界（操作一覧×入口一覧）
  - step-up の方式（challenge）と、強度付与（grant_store）およびTTL/失効ルールの有無
  - UIとAPIで一貫しているか（例外パスの有無）
  - 監査ログに step-up と重要操作が紐付くか（運用として検知/追跡可能か）
- 推定（根拠付きで言える）：
  - grant_storeがUIのみ、またはTTL/失効が弱い場合、侵害セッションで重要操作が通る可能性が高い
  - SSOで強度がIdP側にあっても、RPが検証しないと意味がない（責任分界の穴）
- 言えない（この段階では断定しない）：
  - 実侵害での横展開（盗用/中間者等）※ただし18/17へ接続して次の検証計画を立てられる

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- 優先度（P0/P1/P2）
  - P0：
    - 重要操作（MFA解除/メール変更/送金/権限変更等）が step-up なしで通る
    - UIは step-up するが、同操作のAPIが step-up を要求しない（例外パス確定）
    - step-up完了後の強度付与が長すぎる/失効しない（盗用セッションで“ずっと重要操作OK”）
  - P1：
    - step-up はあるが、トリガが曖昧（リスク判定が弱い）、TTLが長い、監査が薄い
    - SSO環境で強度はIdPに依存しているが、RPの検証が不明/不整合
  - P2：
    - 防御はあるがUX過多/誤検知（過剰step-up）で運用上の改善余地
- “成立条件”としての整理（技術者が直すべき対象）
  - 重要操作の全入口（UI/API/mobile）で統一して強制する
  - grant_storeをサーバ側で管理し、TTLと失効ルールを明確化する
  - step-upのトランザクション束縛（CSRF/取り違え）を13と同等に担保する
  - 監査ログ（step-upと操作）を相関可能にする

## 次に試すこと（仮説A/Bの分岐と検証）
- 仮説A：重要操作に step-up が欠落している（または一部だけ）
  - 次の検証（低アクティブ）：
    - 重要操作候補を3〜5件選び、UIで操作すると step-up が要求されるかを観測
    - 同じ操作のAPIエンドポイントをHARから特定し、step-up無しで到達できる兆候がないか（要求パラメータとレスポンスで判断）
  - 判断：
    - 欠落/例外パスあり：P0（重要操作境界の設計欠落）
- 仮説B：step-up はあるが、状態管理（grant_store/TTL/失効）が弱い
  - 次の検証：
    - step-up完了後に付与されるcookie/トークン/属性の変化を観測（Set-Cookie、レスポンス差、一覧/監査ログ）
    - TTLの兆候（時間経過で再step-up要求が出るか）を少数回で確認
    - ログアウト/全端末logout/パスワード変更後に、step-up強度が確実に失効するか（15/14と接続）
  - 判断：
    - 失効しない/長すぎる：P0〜P1
- 仮説C：再認証フローが13同型のCSRF/取り違え耐性を欠く
  - 次の検証：
    - step-up開始/完了にCSRFトークンやtransaction stateがあるか
    - return_toが安全に束縛されているか（allowlist/署名等の兆候）
  - 判断：
    - ない/弱い：P1〜P0（重要操作の状態遷移が第三者起点で混入し得る）
- 仮説D：SSOで強度を表現しているが、RPが検証していない
  - 次の検証：
    - IdP側でMFA要求が発生する条件と、RP側の重要操作要求が連動しているかを観測
    - 可能ならトークンクレーム（acr/amr）とRP側の判断ログを相関する（設定断片/ログが取れる範囲）
  - 判断：
    - 連動なし：P1（責任分界の穴。RP側での強度検証が必要）

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - `04_labs/02_web/02_authn/16_step-up_reauth/`
    - 構成案：
      - RP：重要操作API（メール変更/MFA解除/権限変更のダミー）を用意し、step-upの有無を切替できる
      - step-up方式：パスワード再入力 + OIDC(IdP)MFA の2系統を再現（責任分界の観測）
      - 監査ログ：stepup_success、stepup_fail、sensitive_action_attempt、sensitive_action_success を必ず出す
- 取得する証跡（深く探れる前提：HTTP＋周辺ログ）
  - HTTP：HAR（重要操作→step-up要求→完了→操作再試行）
  - Cookie/Token差分：step-up完了前後のSet-Cookie、token refreshの有無
  - アプリログ：step-upトランザクションID、TTL、grant_store属性、失効イベント
  - IdPログ（SSO時）：MFA要求、acr/amr、セッション強度
  - 監査ログ：操作とstep-upが同一相関キーで結べるか
- 観測の設計（例外パス検出）
  - UI操作→API呼出を必ず対応付け、API側で step-up チェックがあるかを確認する（フロント限定防御を排除）
  - 同時セッション（15）を使い、別端末の古いセッションが step-up を要求されるか（侵害時想定の入力）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
~~~~
# 例：重要操作とstep-up（擬似）
POST /account/email/change           { new_email: ... }          # 重要操作
# => 401/403 ではなく「step-up required」を返す設計が望ましい（境界の明示）
POST /reauth/start                   { action: "email_change" }  # 再認証開始（transaction発行）
POST /reauth/verify                  { transaction: "...", otp_or_pwd: "..." }
POST /account/email/change           { new_email: ... }          # 再試行で成功

# 観測すること（擬似）
- step-up required の返し方（ステータス/エラーコード）
- transaction の束縛（CSRF/取り違え耐性）
- step-up完了後に付与される強度（cookie/属性）とTTL/失効
~~~~
- この例で観測していること：
  - 重要操作が “強度不足” で止まり、再認証完了後だけ通る境界が成立しているか
- 出力のどこを見るか（注目点）：
  - API側の強制有無（UI限定でない）、transactionの扱い、Set-Cookie差分、監査ログの相関
- この例が使えないケース（前提が崩れるケース）：
  - 重要操作がサーバ側で一括ゲートされず、各APIで実装がバラバラ（→操作一覧を増やし、例外パス検出を主眼にする）

## 参考（必要最小限）
- OWASP ASVS（再認証、重要操作境界、セッション属性/失効）
- OWASP WSTG（Re-authentication / CSRF / Session management）
- OIDCのacr/amr、step-up認証（RP/IdP責任分界の設計原則）

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/02_authn_13_login_csrf_認証CSRFとstate設計.md`
- `01_topics/02_web/02_authn_15_session_concurrency（多端末_同時ログイン制御）.md`
- `01_topics/02_web/02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`
