## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：暗号を「使っている」だけでは防御にならない。プリミティブ選択（hash/KDF/MAC/sign/encrypt）と境界（何を守るか、何を信じるか、鍵を誰が持つか）がズレると、(1) パスワードが復元可能、(2) トークンが偽造可能、(3) 機微データが復号される、(4) 署名の検証不備で成りすまし、(5) 鍵漏えいが即全損、(6) ログに秘密が流出、が現実に起きる。
  - 満たす：ASVSの暗号要求は「アルゴリズム名」ではなく、(a) 適材適所（hash vs encrypt）、(b) KDF（パスワード/鍵導出）の要件、(c) 署名/検証の正しさ（aud/iss/鍵選択/ローテーション）、(d) 鍵管理（保管・ローテーション・最小権限）、(e) 乱数/nonce/IV/salt の管理、まで含めて境界として設計・実装すること。
- WSTG
  - 観点：WSTGでは暗号実装の誤用（弱いハッシュ、固定鍵、IV/nonce再利用、署名検証不備、古いTLS/不適切な暗号スイート等）を“観測可能な症状”から追う。API/トークン/クッキー/署名付きURL/Webhook署名など「Webで起きる暗号の接続点」を対象に、入力と境界（どこで検証し、何を信じ、何を残すか）を確定して評価する。
- PTES
  - 位置づけ：暗号は「破る」より「誤用を突く」領域。PTESでは、(1) 設計レビュー（用途とプリミティブの整合）、(2) 実装レビュー（ライブラリ利用・検証点・鍵管理）、(3) 実証（偽造/再利用/復元可能性が“現実的”か）、の順で結論を固める。報告は“暗号の講義”で終わらせず、境界・影響半径・是正優先度を明確化する。
- MITRE ATT&CK
  - 接続：鍵/トークン/セッションの窃取（Credential Access）、APIキー漏えい、設定ミスによる秘密流出（ログ/設定）、暗号検証の不備によるなりすまし（Defense Evasion ではなく「認証・認可の迂回」）、および侵害後の継続（トークン再利用）に繋がる。
  - 本ファイルは攻撃手順ではなく、攻撃者が「狙う資産（鍵・トークン・署名検証点）」と、防御側が「境界として固める設計」を接続する。

---

## タイトル
Cryptography 境界（hash / KDF / sign / encrypt）
「何を守りたいか」からプリミティブを選び、鍵・検証・失効・ログまでを“運用できる境界”に落とす

---

## 目的（このファイルで到達する状態）
- Web実装で頻出の暗号用途（パスワード、トークン、署名、機微DB、署名付きURL、Webhook）について、
  1) どのプリミティブを使うべきか（hash/KDF/MAC/sign/encrypt）
  2) どこで検証するべきか（Edge/BFF/API/Worker）
  3) 鍵・salt・nonce/IV・乱数をどう扱うべきか
  4) 失効・ローテーション・監査ログをどう組み込むべきか
  を、境界モデルとして説明できる。
- 診断・レビューでは、暗号“アルゴリズム名当て”ではなく、
  - 「用途のズレ（hashで隠したつもり、encryptすべきだった等）」
  - 「検証点の欠落（署名しているが検証していない/条件が甘い）」
  - 「鍵運用の欠陥（固定鍵、共有鍵、ローテーション不能、ログ混入）」
  - 「乱数/nonce/IV/saltの誤用」
  を最短で見つけ、次の一手（是正案）へ落とせる。

---

## 扱う範囲（スコープ）
- 扱う
  - hash（ハッシュ）とKDF（パスワードハッシュ/鍵導出）
  - sign/MAC（署名・完全性）とencrypt（機密性）
  - nonce/IV/salt/乱数、鍵管理（保管・ローテ・権限分離）、検証点（aud/iss/kid等）
  - Webに典型の“暗号の接続点”（JWT/JWS、Cookie、署名付きURL、Webhook署名、DB暗号化）
- 扱わない（接続先）
  - TLSの詳細は `01_topics/01_asm-osint/02_tls_証明書・CT・外部依存推定.md` 側に寄せる
  - Secrets管理の一般は `01_topics/02_web/06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
  - セッション/トークン設計の全体は `02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`

---

## 境界モデル：暗号は「目的」と「運用」がズレた瞬間に崩れる
### 1) 暗号で守る4種類の性質
- 機密性（Confidentiality）
  - 第三者に見えない：encrypt（暗号化）が担当
- 完全性（Integrity）
  - 改ざんされていない：MAC（HMAC等）/署名（公開鍵署名）が担当
- 正当性（Authenticity）
  - 正しい主体が作った：署名/MACが担当（鍵の持ち主が主体）
- 耐再現性（Replay resistance）
  - 使い回しが効かない：nonce/exp/jti/one-time-use/チャレンジが担当

### 2) “境界”として見るべき3点
- 何を信じるか（Trust）
  - 署名されたclaimsでも、用途（aud）や発行者（iss）や鍵選択（kid）を誤ると信頼は崩れる
- 何を守るか（Asset）
  - パスワード、トークン、鍵、個人情報、機密設定、署名検証点
- どう運用するか（Ops）
  - 鍵の保管・ローテーション・失効・監査ログ・アクセス制御
  - “運用できない暗号”は、実運用で例外が積み上がり破綻する

---

## まず結論：用途→プリミティブ対応表（迷いをなくす）
### 1) hash（ハッシュ）
- 目的：復元不能の要約、同一性比較、改ざん検出の部品（ただし単体では“鍵なし”）
- 使いどころ
  - パスワード保存の“素材”としては不可（必ずKDFへ）
  - “トークンの生値をログやDBに残したくない”場合の参照（ハッシュ化して突合）
- 使ってはいけない誤用
  - 「hashしたから暗号化した」扱い（機密性は得られない）
  - 速いハッシュでパスワード保存（総当たりに弱い）

### 2) KDF（Key Derivation Function / Password Hash）
- 目的：パスワードや低エントロピーの秘密から、総当たりに強い形で保存/導出する
- 使いどころ
  - パスワードハッシュ（推奨：Argon2 / bcrypt / scrypt、要件次第でPBKDF2）
  - “秘密鍵をパスワードから作る”場合の導出（ただし設計的に避けられるなら避ける）
- 必須要素
  - salt（ユニーク）と適切なコスト（time/memory）
  - パラメータの記録（後から上げられる形）

### 3) MAC（HMAC 等：共有鍵の完全性）
- 目的：改ざん検知と正当性（鍵共有している主体のみ生成可能）
- 使いどころ
  - Webhook署名（送信側と受信側で秘密共有）
  - 署名付きURL/署名付きCookie（ただし運用要件次第）
- 注意
  - 鍵漏えい＝偽造可能（影響半径が大きいので鍵運用が主戦場）

### 4) sign（公開鍵署名：非対称鍵）
- 目的：改ざん検知と正当性（秘密鍵で署名、公開鍵で検証）
- 使いどころ
  - IdP発行トークン（OIDC/SAML署名）
  - サービス間で「検証者が多い」「秘密を配れない」場合
- 注意
  - 鍵選択（kid）・鍵配布（JWKS）・ローテーションの設計が必須

### 5) encrypt（暗号化）
- 目的：機密性（読めない）＋（推奨は）完全性（AEADで同時に確保）
- 使いどころ
  - DBの機微カラム暗号化（アプリ層/DB層/Envelope）
  - トークンを“見せたくない”場合（JWE等。ただし設計コストが高い）
- 注意
  - 「暗号化したが改ざん検知がない」は危険（原則AEAD）
  - nonce/IV再利用は破滅的になり得るため、生成と管理が最重要

---

## 乱数・salt・nonce/IV：暗号の“土台”が壊れる典型
### 1) salt（KDF/パスワードハッシュ）
- 目的
  - 同じパスワードでもハッシュが同じにならない（レインボーテーブル耐性）
  - ユーザ単位の総当たりを分散させる
- 要件
  - ユニーク（ユーザごと）
  - 秘密ではない（隠す必要はない）
- よくある失敗
  - 固定salt、短すぎるsalt、saltがない

### 2) nonce/IV（暗号化・AEAD）
- 目的
  - 同じ平文でも暗号文が変わる（パターン漏えい防止）
  - AEADではnonce再利用が致命傷になる場合がある
- 要件
  - “同一鍵”で再利用しない（方式の要件に従う）
  - 生成をアプリ任せにするなら、衝突しない設計（カウンタ/乱数/組合せ）を持つ
- よくある失敗
  - 固定IV、短いIV、同一nonce再利用、再試行でnonce使い回し

### 3) 乱数（トークン、リセット、署名付きURL）
- 目的
  - 推測不能性（予測されると“暗号を使っていても終わる”）
- 要件
  - CSPRNG（暗号学的に安全な乱数）
  - 期限（exp）と一回性（jti/DBで消し込み）の組み合わせ
- よくある失敗
  - 時刻や連番由来、短いトークン、期限なし、再利用可能

---

## Webで頻出の“暗号の接続点”別：設計の定石と境界
### 1) パスワード保存（hashではなくKDF）
- 定石
  - パスワードは“復元不能”が要件：KDF（password hash）を使う
  - saltはユニーク、コストは現実的に高く（運用可能な範囲で）
  - パラメータを将来上げられる（ログイン時に再ハッシュ移行など）
- 境界（どこで何を信じるか）
  - 入力値の比較は定数時間比較（タイミング差の最小化）
  - ログ/監視にパスワード・ハッシュ原文・リセットトークンを出さない
- 代表的な失敗
  - SHA系で保存、固定salt、コストが低すぎ、平文ログ混入

### 2) パスワードリセット・回復（tokenの設計）
- 定石
  - “短寿命 + 一回性 + スコープ限定（この操作だけ）”
  - tokenの生値をDBに保存しない（保存するならtoken_hash）
  - 使用後は即失効（ワンタイム）
- 境界
  - “回復”は認証より弱くなりやすい：本人確認と失効が最重要
  - 監査ログ（誰に発行したか、IP/UA、成功/失敗）を残す

### 3) セッションCookie（署名/暗号化の誤用に注意）
- パターンA：サーバ側セッション（推奨になりやすい）
  - CookieはランダムなセッションIDのみ（中身はサーバ）
  - 暗号はCookieに詰めない設計で回避できる
- パターンB：ステートレスCookie（中身を持つ）
  - “改ざん検知（MAC/署名）”が必須
  - 機微情報を入れるなら暗号化（ただし鍵運用が重くなる）
- 境界
  - cookieの属性（Secure/HttpOnly/SameSite等）と一体で成立
  - セッション再利用（replay）検知は別ファイル側と接続：`13_session_replay_再利用と検知（ua_ip_binding）.md`

### 4) JWT/JWS（signの典型：検証が設計の本体）
- 定石（検証点の必須）
  - 署名検証：アルゴリズム固定、鍵選択の制御
  - クレーム検証：iss/aud/exp/nbf/i-at（必要なら）/nonce（文脈次第）
  - スコープ検証：scope/role/tenant等を“どこまで信じるか”を固定
- 境界（ありがちな崩れ）
  - “署名は検証しているがaudを見ていない” → 別用途トークンの流用
  - “issが曖昧” → 別発行者を受理
  - “kidを盲信” → 鍵選択が攻撃者入力になる（運用・実装次第で危険）
  - “失効戦略がない” → 漏えい時の影響が長い

### 5) Webhook署名（MAC/HMACが典型）
- 定石
  - 署名は“ボディ全体 + タイムスタンプ + リプレイ耐性”が基本
  - 受信側は “許容時刻差（clock skew）” を持ちながら一回性を担保（event_id等）
  - 共有鍵は最小権限・ローテーション可能に
- 境界
  - 署名検証を“受信直後”に行い、検証前に副作用を起こさない
  - 失敗時のログは機微を残さず、相関IDで追えるようにする（`11_logging_tracing_相関IDと証跡設計.md`）

### 6) 署名付きURL（download/upload、期限付きアクセス）
- 定石
  - 期限（exp）＋スコープ（path/object）＋メソッド（GET/PUT）を署名対象に含める
  - 署名の検証点を統一（CDN/アプリ/ストレージ）
- 境界
  - “署名はあるが対象が広い（prefix全体等）” → 逸脱利用の余地
  - “期限が長い” → 漏えい時の被害が大きい
  - “ログにURLを丸ごと残す” → 署名/トークンが漏れる（二次被害）

### 7) DB機微カラム暗号化（encrypt：運用が本体）
- 方式選択（境界の置き方）
  - アプリ層暗号化：アプリが鍵を持つ（権限境界が明確、実装コストあり）
  - DB機能暗号化：DBが鍵を持つ（運用容易だが権限分離に注意）
  - Envelope暗号化：データ鍵（DEK）をKMSで保護（鍵ローテが扱いやすい）
- 境界
  - 検索・ソート・部分一致が必要なら、暗号化方式と要件が衝突する（安易に“検索も暗号化も”を同時に満たそうとすると危険な設計に寄る）
  - 鍵アクセス権＝機微閲覧権。監査・最小権限・分離が必要

---

## 鍵管理（Key Management）：暗号の強度は“鍵の運用”で決まる
### 1) 鍵の所在（どこに置くか）
- 望ましい方向
  - コードに埋めない
  - 設定ファイル平文を避ける（少なくともアクセス制御・監査を前提）
  - KMS/HSM等で保護し、利用権限を最小化
- 境界（実務の落とし穴）
  - “アプリが復号できる”＝“侵害時に復号される”
  - よって、侵害時の影響半径をどう抑えるか（キー分割、テナント別鍵、用途別鍵）が設計要件になる

### 2) 用途別鍵（Key Separation）
- 1本の鍵で全部やらない
  - パスワードハッシュ（KDF）と、HMAC署名と、暗号化は別鍵・別用途
- 理由
  - 漏えい時の影響半径が小さくなる
  - ローテーションがやりやすい（用途単位で回せる）

### 3) ローテーション（Rotation）を“最初から”設計する
- 署名鍵（sign/MAC）
  - 複数鍵の同時受理（検証は旧鍵もOK）→ 発行は新鍵のみ → 期限後に旧鍵破棄
- 暗号化鍵（encrypt）
  - 既存データの再暗号化が必要になる可能性（運用コスト）
  - Envelope暗号化で負担を軽減する設計が現実的になりやすい
- 境界
  - “ローテができない暗号”は、漏えい時に全データ/全トークンが全損になりやすい

### 4) 鍵ID（kid）と鍵選択
- 方針
  - kidは便利だが、入力に引っ張られると危険になり得る
  - 信頼できる鍵セット（許可リスト）からしか選ばない
- 運用
  - kidの命名規則（用途/環境/発行者/世代）を固定し、ログに“どの鍵で検証したか”を残す（機微そのものは残さない）

---

## 診断・レビューの観測ポイント（意味→判断→次の一手）
### 1) “用途とプリミティブが合っているか”
- 観測
  - パスワード保存にhashを使っていないか
  - 機密データをMACだけで守っていないか（読めてしまう）
  - 暗号化しているが改ざん検知がない（AEADでない等）
- 判断
  - 目的（機密性/完全性/正当性/耐再現性）に対し不足がある
- 次の一手
  - 目的を再定義し、プリミティブを差し替える（例：hash→KDF、encrypt→AEAD、MAC追加など）

### 2) “検証点が正しいか”（署名している≠検証している）
- 観測
  - 署名検証がどこで行われるか（入口/各サービス/一部だけ）
  - iss/aud/exp等が検証されているか（受理条件の明文化）
- 判断
  - 検証不足は“偽造ではなく流用”で破られやすい（境界の崩壊）
- 次の一手
  - 検証チェックリストを固定し、判定点（Policy/Guard）へ寄せる

### 3) “乱数・salt・nonce/IVが適切か”
- 観測
  - saltがユニークか、KDFのコストが十分か
  - nonce/IVが固定・再利用されていないか
  - トークンが短すぎないか、期限があるか、一回性があるか
- 判断
  - 土台が崩れると暗号の種類を変えても意味がない
- 次の一手
  - 生成をライブラリ標準に寄せ、アプリ独自生成を減らす（設計の簡素化）

### 4) “鍵運用が成立しているか”
- 観測
  - 鍵がどこにあるか（コード/設定/Secrets/KMS）
  - ローテーションできるか（複数鍵受理、鍵世代管理）
  - 監査ログ（鍵利用の痕跡）があるか
- 判断
  - 鍵漏えい時の影響半径と復旧可能性（回せるか）が決まる
- 次の一手
  - 用途別鍵＋ローテーション計画＋最小権限（アクセス制御）を設計要件に入れる

### 5) “ログに秘密が出ていないか”（暗号の逆流）
- 観測
  - Authorization、署名付きURL、Webhook署名、リセットトークン、暗号文/平文の出力
- 判断
  - ログが“攻撃者の宝庫”になっていると、暗号境界が別経路で崩れる
- 次の一手
  - マスキング/ハッシュ参照/JTI等へ置換し、`11_logging_tracing_相関IDと証跡設計.md` の方針に統合

---

## よくある失敗パターン（実務で刺さるもの）
1) “hash＝暗号化”と誤認し、機密情報をハッシュで隠そうとする
2) パスワードを高速ハッシュで保存（総当たりに弱い）
3) KDFのsaltが固定、コストが低い、パラメータが保存されず将来上げられない
4) 署名はあるが aud/iss/exp の検証が甘く、用途違いトークンが通る
5) kid/鍵選択が入力に引っ張られ、許可されない鍵で検証される余地がある
6) 暗号化しているが改ざん検知がなく、復号後の処理が危険（AEAD不使用）
7) nonce/IVの再利用（再試行や並列処理で起きやすい）
8) 固定鍵・共有鍵で全環境/全顧客を守り、漏えい時に全損
9) ログ/例外/デバッグにトークンや秘密が混入（暗号の努力が無効化）
10) 失効・ローテーションの設計がなく、漏えい時に止められない

---

## 次に試すこと（仮説A/Bで迷わない）
### 仮説A：用途の選択ミス（hash/KDF/sign/encryptの取り違え）
- 次の一手
  - 守りたい性質（機密性/完全性/正当性/耐再現性）を明文化し、プリミティブを再配置
  - 例：パスワード→KDF、機密DB→AEAD、Webhook→HMAC、IdP→署名検証厳格化

### 仮説B：検証点の欠落（署名しているが境界で検証していない/条件が甘い）
- 次の一手
  - 入口（Gateway/BFF/API）での検証責務を固定
  - クレーム検証（iss/aud/exp等）と鍵許可リストを仕様化
  - 監査ログに「検証成功/失敗」「理由（要約）」を残す（機微は残さない）

### 仮説C：鍵運用が弱い（固定鍵、ローテ不能、漏えい時に止められない）
- 次の一手
  - 用途別鍵、環境別鍵、可能ならテナント別鍵へ分離
  - ローテーション計画（多鍵受理→移行→旧鍵破棄）
  - KMS等の導入、最小権限、監査ログの整備

### 仮説D：乱数/nonce/IV/salt が弱い（構造的に破綻）
- 次の一手
  - アプリ独自生成を減らし、標準ライブラリへ寄せる
  - 方式要件に沿ってnonce再利用が起きない設計（並列/再試行を含めて）へ修正
  - トークンは短寿命＋一回性＋スコープ限定へ

---

## 04_labs（手を動かして“境界のズレ”を再現・理解する）
- Lab候補（例）
  - `04_labs/02_web/14_crypto_01_password_hashing_kdf_parameters/`
  - `04_labs/02_web/14_crypto_02_signature_verification_claims_boundary/`
  - `04_labs/02_web/14_crypto_03_webhook_hmac_timestamp_replay/`
  - `04_labs/02_web/14_crypto_04_aead_nonce_iv_management_parallel_retry/`
  - `04_labs/02_web/14_crypto_05_key_rotation_multi_key_acceptance/`
- Lab設計要件（手順書ではなく設計）
  - “同じ機能”を、誤用パターン/正しいパターンで比較できる（差分が腹落ちする）
  - 相関IDと監査ログで、検証点・鍵世代・拒否理由が追える
  - 例外/ログに秘密が出ない設計も同時に確認できる（運用境界）

---

## コマンド/例（例示は最小限：意味→判断→次の一手を優先）
~~~~
# 目的：
# - 「暗号を使っている」ではなく「境界として成立している」を確認する
# - どのプリミティブで何を守り、どこで検証し、鍵をどう回すかまでを仕様化する

# 典型の“仕様として固定すべき項目”（例）
# - password: KDF=Argon2id/bcrypt/scrypt/PBKDF2, salt unique, params stored, upgrade plan
# - token(JWS): alg fixed, key allowlist, iss/aud/exp required, clock-skew policy
# - webhook(HMAC): body+timestamp signed, replay protection, secret rotation
# - encrypt(AEAD): nonce/IV policy, key separation, envelope encryption, rotation approach
# - logging: secrets redaction, token hashing (jti/hashed), audit decision+reason+trace_id
~~~~

---

## 深掘りリンク（最大8）
- `01_topics/02_web/02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`
- `01_topics/02_web/02_authn_10_password_reset_回復経路（token_失効_多要素）.md`
- `01_topics/02_web/02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`
- `01_topics/02_web/02_authn_18_token_binding（DPoP_mTLS）観測.md`
- `01_topics/02_web/04_api_04_webhook_受信側の信頼境界（署名_再送）.md`
- `01_topics/02_web/06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
- `01_topics/02_web/11_logging_tracing_相関IDと証跡設計.md`
- `01_topics/02_web/13_session_replay_再利用と検知（ua_ip_binding）.md`
