## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）

- ASVS
  - 満たす/破れる点（このファイルの主眼）
    - 入力を「型」と「許可語彙（allowlist）」で拘束できているか（NoSQLは“文字列のエスケープ”より“オブジェクト構造の拘束”が本体）
    - “クエリ構造”と“値”の境界が守られているか（入力がクエリ演算子 `$ne/$gt/$regex` を形成できると境界が破れる）
    - 認可（tenant/org 条件、所有者条件）の付与が「クエリ改変」で崩れないか（BOLA/越境混入と直結）
    - 例外/エラーモデルを統一し、差分（oracle）を潰せているか（キャスト/正規表現エラー/型不一致など）
    - ログ/監査で異常クエリ（演算子出現、正規表現、スキャン傾向）を検知できるか
- WSTG
  - Injection testing（入力→実行境界）の一種として、SQLiと同じ手順で「入力点列挙→sink（クエリ生成点）→差分観測→成立根拠」を取る
  - “パラメータ改ざん”ではなく「構造改ざん（JSON/フォームのネスト）」が核である点を明示し、観測点（リクエスト形式/Content-Type/バリデータ）を押さえる
- PTES
  - Vulnerability Analysis：入力点（query/body/form）→Mongoクエリ生成点→差分観測で最小PoC→越境混入（認可境界）まで評価
  - Exploitation：影響実証は必要最小限（ログイン回避・他人データ参照の“成立”まで。大量抽出や高負荷は避ける）
  - Reporting：根本原因を「型/スキーマ不在」「演算子allowlist不在」「クエリビルダ誤用」「テナント条件付与の欠陥」に分解して提示
- MITRE ATT&CK
  - TA0001 Initial Access（公開アプリ入口）/ TA0009 Collection（検索APIからのデータ収集）/ TA0006 Credential Access（ユーザDBやAPIキー格納がある場合）/ TA0005 Defense Evasion（エラー統一下でブラインド化）
  - 代表：T1190 Exploit Public-Facing Application（NoSQLiも入口になり得る）

# NoSQL Injection（MongoDB）：Operator Injection（$ne / $gt / $regex）

## 目的（この技術で到達する状態）
- MongoDB を使うWeb/APIで、入力が **“クエリ構造（演算子）”** を形成できてしまう境界破壊（NoSQLi）を、次の形で回せる状態になる。
  1) 入力点を「値」ではなく「クエリ構造」へ昇格できる条件（成立根拠）を特定する  
  2) `$ne/$gt/$regex` を代表とする **Operator Injection** を、黒箱でも差分観測で確定する  
  3) 認可境界（tenant/org/owner 条件）が **クエリ改変で崩れる** パスを評価できる（BOLAと接続）  
  4) 修正を「フィルタ強化」ではなく、**型拘束・allowlist・クエリ生成の設計**に落とせる

## 前提（対象・範囲・想定）
- 対象
  - Node/Express、Java/Spring、Python、Go などで MongoDB（または互換）を利用する検索・ログイン・一覧API
  - REST/GraphQL を問わず「条件検索」「柔軟フィルタ」「一覧ソート」がある箇所
- 注入が成立しやすい典型
  - JSON をそのままDBクエリに渡す設計（bodyの一部が find の条件になる等）
  - form-urlencoded / multipart の “ネスト表現” をオブジェクトに復元している（`a[b]=...` → `{a:{b:...}}`）
  - “汎用フィルタ”として `filter=` や `where=` のJSON文字列を受け、パースしてクエリにマージしている
- 本ファイルの焦点
  - `$ne/$gt/$regex` を「成立根拠（oracle）」として、Operator Injection の境界モデルを作る
  - `$where`（JS評価）や集約パイプライン等は別ファイルで扱う（このファイルでは扱わない）

## 観測ポイント（何を見ているか：入力→クエリ構造→実行→反応）

### 1) 最重要の境界：入力は “値” か “クエリオブジェクト” か
- 値（data）として扱われる（安全側へ寄せやすい）
  - 例：`{ username: "alice" }`（文字列）としてのみ扱う
- クエリオブジェクト（code）として扱われる（危険側）
  - 例：`{ username: { $ne: null } }` のように、入力が `$ne` を形成できる
- 観測の狙い
  - **同じフィールド**に対し、入力形式だけ変えて “条件解釈が変わる” かを差分で見る  
  - これが見えれば「エスケープ不足」ではなく「構造注入」であることを説明できる

### 2) 入口の特定：Operator が入り込む入力形式を押さえる
- Content-Type / 入力形式ごとに “構造注入” の入り方が違う
  - JSON（application/json）
    - bodyがオブジェクトなので、構造注入が最も自然に成立しやすい
  - form-urlencoded（application/x-www-form-urlencoded）
    - `a[b]=x` を `{a:{b:"x"}}` に復元するミドルウェア設定があると、演算子が入り込む
  - query string（URL）
    - 同様にネスト復元や型変換があると成立し得る
- 判断（次の一手）
  - まず「どのContent-Typeで解釈が変わるか」を確定し、以降の差分観測をその形式に固定する

### 3) 差分（oracle）として使う観測指標を固定する
Operator Injection は “SQL構文エラー” のように露骨なエラーが出ないことが多い。よって差分指標を固定する。

- Boolean oracle（推奨）
  - 結果件数、レスポンス長、ページネーション、表示要素数、特定レコードの有無
- Error oracle（補助）
  - 型不一致、正規表現エラーなどが返る場合は「DB到達」の補助証拠に使う（主証拠はBoolean）
- Time oracle（原則は補助）
  - 正規表現は負荷差分を作り得るが、DoSに近づくため**長い遅延での検証は避ける**

### 4) 認可境界との結合点：NoSQLi は “検索条件＝権限条件” を壊しやすい
- よくある設計
  - `tenant_id = currentTenant` の条件を必ず付ける
  - `owner_id = currentUser` の条件を必ず付ける
- Operator Injection が危険な理由
  - フィルタ統合（merge）が雑だと、ユーザ入力が権限条件と“同じ階層”に混ざる
  - 条件が上書き/無効化/回避される（特に「汎用filter」設計で起きやすい）
- 観測の要点
  - “他人データが見える” の断定ではなく、**権限条件がクエリ構造として揺らぐ** 証拠（差分）を取る

## 結果の意味（その出力が示す状態：何が言える/言えない）

### 言える（確定できる）
- 入力が “値” を超えて “Mongoクエリ構造（演算子）” を形成できる（境界破壊）
- その成立経路（JSON直渡し / ネスト復元 / filter JSONパース / マージ処理）がどれか
- 差分（oracle）がどこに出るか（件数/長さ/エラー/時間）と再現性
- 認可境界（tenant/org/owner 条件）に接続し得る入口か（設計上の危険性）

### 断定しない（追加根拠が必要）
- DB種類の断定（互換実装・抽象化がある）
- “データが全て抜ける” の断定（権限・投影・API制限・監査で変わる）
- “高負荷攻撃が可能” の断定（負荷検証は契約と安全配慮が必要）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・想定パス）
※悪用手順の提供ではなく、ペンテストの優先順位・仮説の立て方として整理する。

### 優先度が上がる入口（実務）
- ログイン/本人確認に近い照合
  - “一致判定”がOperatorで崩れると、認証・アカウント列挙の問題へ繋がる
- 検索API（q/filter/where）
  - “柔軟検索”を謳うほど、filter JSON を受けてマージしがち
- 管理画面の一覧・エクスポート
  - 条件が複雑で、サーバ側も動的にマージしがち（越境混入が起きやすい）

### MSSQL/SQLiとの違い（判断のブレを潰す）
- SQLi：文字列がSQL構文になる（構文エラーが証拠になりやすい）
- Mongo Operator Injection：入力がクエリ“オブジェクト”になる（構造の差分が証拠）
  - よって、エラー誘発より **構造差分（Boolean）** に寄せるのが基本

## 次に試すこと（仮説A/B/C：最小差分で確定）

### 仮説A：入力がクエリオブジェクトとして解釈されている（Operator Injection）
- 条件（観測）
  - “同じフィールド”に対し、入力形式の違いで結果が変わる（件数/長さが安定して変化）
- 次の一手（安全・低侵襲）
  - 入口（JSON / formネスト / filter JSON）を確定し、その形式に固定して横展開（同種パラメータを洗う）
  - 認可境界に関わるフィールド（tenant/org/owner）と同列に扱われている入力がないかを確認する（BOLA接続）

### 仮説B：入力は値だが、filter の “マージ処理” で演算子が混入している
- 条件（観測）
  - 単純入力では差分が出ないが、filter/where のような“汎用条件”で差分が出る
- 次の一手
  - マージ位置（どのキーが受け入れられるか）を差分で特定し、allowlist欠落として原因を固定する
  - 修正は「禁止ワード」ではなく「受理する演算子/フィールドの allowlist」と「型検証」に落とす

### 仮説C：正規表現が “検索機能として” 受理され、想定外の範囲や負荷が出る（$regex）
- 条件（観測）
  - 検索語が “文字列一致” ではなく “パターン” として扱われる兆候がある（結果集合が広がる等）
- 次の一手
  - まずは機能仕様としての正規表現受理の有無を確定（仕様なら制約・上限・タイムアウト・index設計へ）
  - セキュリティ観点では、正規表現受理が “権限条件” と同居していないか（越境混入）を優先して確認する

## 手を動かす検証（Labs連動：観測→解釈→利用を再現）
- 目的：Operator Injection を「入口の違い」「マージ処理」「認可条件との同居」で再現し、差分観測の型を身体化する
- 最小構成（推奨）
  - エンドポイント3種（同じUIでも可）
    1) 安全：値を型拘束し、演算子を受け取らない（スキーマ検証あり）
    2) 脆弱：bodyをそのまま find 条件へ渡す（演算子が混入）
    3) 脆弱：filter JSON をパースして既定条件へマージ（上書き/同居の危険）
  - 認可条件：`tenant_id` を常に付与する実装を置き、マージの仕方で崩れる/崩れないを比較できるようにする
- 取る証跡（最小）
  - HAR（baseline / 差分true / 差分false）
  - サーバログ（trace_id、受理した入力の型、組み立てたクエリ構造の要約※機微はマスク）
  - Mongoクエリログ（Labsのみ）：実際に `$ne/$gt/$regex` がクエリに入ったか

## 例（最小限：設計の違いを理解するための形）
> ここでは「危険な形／安全な形」を“境界モデル”として示す。実際の送信は許可された検証環境・契約範囲で行う。

~~~~
# 危険：入力をクエリ条件としてそのまま渡す（構造注入の余地）
find( req.body )

# 安全：受け入れるフィールド・型を固定し、値だけを取り出す
const { username } = req.body
assert(typeof username === "string")
find({ username: username })
~~~~

~~~~
# 危険：汎用filterをパースしてマージ（allowlist不在だと演算子が混入）
base = { tenant_id: currentTenant }
userFilter = JSON.parse(req.query.filter)
query = { ...base, ...userFilter }   # ←同階層マージが危険

# 安全：受理するフィールド/演算子を明示し、型も拘束（“構造”を入力にさせない）
- field allowlist（例：name, status, createdAt）
- op allowlist（例：eq, lt, gt のようなアプリ独自DSL）
- value は型変換してから使用
~~~~

~~~~
# 危険：formネスト復元で operator キーがオブジェクトになる（境界破壊）
username[$ne]=x   ->  { username: { $ne: "x" } }

# 安全：ネスト復元を無制限にせず、型検証で弾く（usernameは常にstring）
username: object は 400 で拒否、ログに trace_id と共に記録
~~~~

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

## 次（作成候補順）
- `01_topics/02_web/05_input_04_nosql_injection_01_mongodb_02_where_eval（$where_js）.md`
