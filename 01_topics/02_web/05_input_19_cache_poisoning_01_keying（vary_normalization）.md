フォルダ名: `01_topics/02_web/`
ファイル名: `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
STEP名: `WEB05-INPUT-19-01 Cache Poisoning（Keying）：Vary/正規化/多段キャッシュの差分で“境界がキャッシュに吸われる”状態を証跡で確定する`

```md
## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：キャッシュは「同一キー→同一レスポンス」という“境界装置”。Keying/正規化が壊れると、認証・認可が正しくても **(1) 別ユーザ/別テナントのレスポンス混線**、**(2) 誤った内容の配布（Poisoned配信）**、**(3) 監査・再現性の破綻** が起きる。
  - 満たす：キャッシュ可否（Cache-Control等）・キー構成（Host/Path/Query/Header）・正規化（canonicalization）・例外（bypass条件）を **設計として固定**。多段（CDN→Proxy→Origin）でルールを揃える。ユーザ依存レスポンスは原則キャッシュしない/キーにユーザ境界を入れる。異常系（エラー/リダイレクト/変換）でキャッシュしない。ヒット/ミスと生成元を追跡できるログ相関を必須化。
- WSTG
  - 該当観点：キャッシュは“中継点”を含む入力処理。テストは **(1) キャッシュ可能性**、**(2) キー推定（何がキーに入るか）**、**(3) 正規化差の検出（同一視/別扱いのズレ）**、**(4) 影響（混線/汚染/漏えい）の切り分け** を観測で行う。
- PTES
  - 位置づけ：Recon/分析でキャッシュ階層とキー仮説を作り、検証は **少数試行＋証跡重視**（第三者影響の抑制）。侵害評価は「高価値分岐（認可/テナント/管理/配布物）」に届くかで確定する。
- MITRE ATT&CK
  - T1190（公開アプリの脆弱性悪用）に接続し得るが、本ファイルの焦点は **成立根拠（観測）**。
  - Defense Evasion：エッジ層の挙動（キャッシュ）でフロント/バックの見え方が変わり、検知・再現が困難化し得る。
  - Collection / Impact：混線（漏えい）・誤配布（影響）に接続（ただし根拠の積み上げが前提）。

---

## タイトル
Cache Poisoning（Keying）：Varyと正規化差でキャッシュキーが崩れると、ユーザ/テナント境界が“キャッシュ側で”破壊される

---

## 目的（このファイルで到達する状態）
- 「キャッシュがあるか/効いているか」を超えて、**キャッシュキー＝境界定義** を特定し、壊れ方を根拠付きで説明できる。
  1) どの階層がキャッシュしているか（ブラウザ/CDN/Reverse Proxy/アプリ内）
  2) キーが何で構成されているか（Host/Path/Query/Header/Cookie 等）
  3) 正規化（canonicalization）がどの層でどう行われているか
  4) Keyingが壊れる条件（衝突/分裂）を “観測シグナル→確定証跡” で固める
  5) 実害評価を「境界（ユーザ/テナント/機能）」で切り分け、修正要件へ落とす

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う（Keying / Vary / Normalization）
  - キーの推定（何がキーに入る/入らない）
  - Varyの意味、誤用、現実の“無視されるVary”問題
  - 正規化差（Host/Path/Query/Header）の分類と、衝突/分裂のモデル
  - 多段キャッシュでの「層間不一致」が生む失敗パターン
- 扱わない（次ファイルへ接続）
  - unkeyed input の具体パターン：`05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
  - poisoned object（格納済みの誤レスポンス配布）：`05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`

---

## 前提：キャッシュは“性能”ではなく“境界装置”
### キャッシュが作る境界
- キャッシュは「リクエスト→レスポンス」を保存し、以後は **生成元（Origin）に届く前に** 応答する。
- つまり、アプリの認証/認可がどれだけ厳密でも、キャッシュが誤って同一視した瞬間に
  - 別ユーザ向けのレスポンスが返る（ユーザ境界破壊）
  - 別テナント向けのレスポンスが返る（テナント境界破壊）
  - フロントの制御（WAF/ACL）と違うものが配布される（制御境界破壊）
が起きる。

### だからKeyingが最優先
- Cache Poisoning を「入力で汚染できるか（unkeyed）」から入ると事故りやすい。
- 先に Keying（何を同一とみなすか）を固めると、
  - どの差分が安全か
  - どの差分が第三者影響になるか
を設計できる。

---

## キャッシュ階層モデル（多段が前提：層ごとにキーが違う）
### 1) ブラウザ/クライアントキャッシュ
- Cache-Control、Service Worker、アプリ内キャッシュ（SPAのメモリ/IndexedDB等）
- “見かけ上キャッシュ”でも、実はクライアント側の可能性がある（切り分けが必要）

### 2) CDN（Edge）
- 典型：静的アセット、HTMLの短時間キャッシュ、APIの部分キャッシュ
- CDNは独自キー（device/geo/headers）を持つことが多い（Varyと一致しない場合がある）

### 3) Reverse Proxy / API Gateway
- Nginx/Varnish/Envoy等でキャッシュ
- 組織内で“例外設定”が入りやすい（/apiだけキャッシュ、特定ヘッダでbypass等）

### 4) アプリ内キャッシュ（サーバ側）
- ここでのKeyingはアプリ実装（キー生成関数）依存
- ただし本トピックは“中継点キャッシュ”を中心に扱う（アプリ内は補助）

---

## キャッシュ可否（Cacheability）を“設計として”読む
> ここが曖昧だと、Keying推定が全部ブレる。

### 1) キャッシュされやすい条件（一般形）
- GET/HEAD かつ Cache-Control が public / max-age 等
- 逆に no-store / private / Authorization などで抑止されることが多い

### 2) 現実の落とし穴（“キャッシュされないはず”がされる）
- 認証済みでもEdgeでHTMLが短時間キャッシュされる（最適化設定）
- エラー（404/500）やリダイレクト（301/302）がキャッシュされる設定
- “特定ヘッダがあるとキャッシュ” “特定Cookieがあるとキャッシュ回避” のような運用ルール（設計が複雑化）

### 3) まず取るべき証跡（必須）
- レスポンスの Cache-Control / Expires / Pragma
- Vary の有無と内容
- キャッシュ関与の兆候ヘッダ（Age / Via / cache-status / X-Cache 等：出る範囲のみ）
- 1回目/2回目の応答時間差（Hit/Miss推定）
- 可能なら：CDN/Proxyログ（hit/miss、キー、bypass理由）

---

## Keying（キー）を分解する：何が“同一”の判定に入るか
### 1) キーの典型構成要素（順に重要度が高い）
- scheme（http/https）
- authority（Host、ポート、SNI、:authority↔Host）
- path（正規化の影響大）
- query（順序/重複/エンコードで破綻しやすい）
- headers（Varyで宣言されるもの、または暗黙に使われるもの）
- cookies / authorization（原則キャッシュ抑止だが、例外設計が混線を作る）
- method（多くはGET/HEADのみだが、例外があるなら重大）

### 2) Keyingの“壊れ方”は2種類しかない
- 衝突（Collision）：別物が同一キーになる → 混線/漏えい/誤配布（危険）
- 分裂（Fragmentation）：同一が別キーになる → 効率低下→例外運用→安全策剥離（間接的に危険）

この2つを常に意識し、「どの差分が衝突を生むか」を探す。

---

## Vary：キーを“宣言”するが、現実では信用しすぎない
### 1) Varyの役割
- 「このレスポンスはこのリクエストヘッダに依存する」
- 依存するなら、そのヘッダ値ごとに別キャッシュ（別キー）が必要

### 2) 代表的なVary（設計の意味）
- Vary: Accept-Encoding
  - 圧縮形式でレスポンスが変わる（gzip/br）
- Vary: Accept-Language
  - 言語でレスポンスが変わる（混線するとUXだけでなく、文言差分でリンク/遷移が変わることもある）
- Vary: Origin
  - CORS系のレスポンス差（誤ると情報露出や誤許可につながる）
- Vary: Authorization / Cookie（※運用難易度が高い）
  - “ユーザ依存レスポンスをキャッシュする”という強い意思表示。設計と監視がない限り事故りやすい。

### 3) よくある破綻（設計の失敗パターン）
- 本当に依存しているのに Vary がない（＝衝突リスク）
- Varyがあるのに、実際の中継点が無視/上書き/独自キー（＝設計と実装の乖離）
- Varyを増やしすぎて運用が破綻 → bypass例外が増える → 例外が攻撃面になる

---

## 正規化（Normalization）：ここがKeying破壊の主戦場
> “何を同一視するか”のルールが層ごとにズレると、衝突/分裂が起きる。

### A) Host/Authority 正規化（マルチテナントで致命傷）
- 正規化の論点
  - 大文字小文字
  - 末尾ドット（example.com.）
  - ポート表記（:443 等）
  - IDN（Unicode）↔Punycode
  - 複数Hostヘッダ/authorityとHostの不一致（H2→H1境界）
- 典型事故
  - CDNは正規化して同一視、Originは別扱い（または逆）
  - 結果：別ホスト（別テナント）なのに同一キーへ衝突

### B) Path 正規化（WAF/ACL/Cache/Originで差が出る）
- 正規化の論点
  - // の縮退、/./、/../
  - 末尾スラッシュ
  - 大文字小文字（サーバ/フレームワーク依存）
  - URLデコード順序（%2f 等の扱い）
  - セミコロン以降（path-param）などの扱い差
- 典型事故
  - WAFは正規化後で許可/拒否、Cacheは別規則でキー化、Originはさらに別規則で解釈
  - 結果：検査を通った別表現が“同一キー”として配布される

### C) Query 正規化（最も差分が出やすい）
- 正規化の論点
  - パラメータ順序（a=1&b=2 vs b=2&a=1）
  - 重複キー（a=1&a=2）をどう扱うか（先勝ち/後勝ち/配列化）
  - 空値（a=）と欠如（aなし）
  - 区切り（& と ;）
  - + と %20 の扱い、デコード順序
- 典型事故
  - Cacheは順序を無視して同一キー、Originは順序/重複を意味として扱う
  - 結果：別条件のレスポンスが同一キーに衝突（混線）

### D) Header 正規化（Varyと独自キーのズレ）
- 正規化の論点
  - ヘッダ名大小
  - 重複ヘッダの結合規則（カンマ結合/上書き）
  - 空白・折り返し等（旧式の扱いは製品差）
- 典型事故
  - CDNは特定ヘッダを“暗黙にキーへ含める”が、Varyには出ない
  - 逆にVaryにあるのにCDNが実際はキーに入れていない
  - 結果：観測と現実がズレ、誤った判断で検証が事故る

---

## Keying推定の実務手順（攻撃寄りだが事故らせない“観測優先”）
> ここでは「再現用の危険な手順」ではなく、**キーを推定するための差分設計**を示す。

### 1) “ベースライン”を固定（毎回同じ入力を再現できる状態）
- 対象エンドポイントは、できるだけ
  - 認証不要（または自分のみに影響する環境）
  - 動的要素が少ない
  - レスポンスが安定（日時・ランダムが少ない）
を選ぶ。ここを誤ると、全部が揺れてKeyingが見えなくなる。

### 2) Hit/Miss を観測で判定（断定しない）
- 1回目/2回目の応答時間差
- Age等のヘッダ
- 可能ならキャッシュログ（hit/miss）
- この3点のうち2点以上で同じ結論が出るまで、判断を保留する（推測で進めない）

### 3) 差分は“1軸ずつ”変える（キー推定の基本）
- Hostだけ変える、Pathだけ変える、Query順序だけ変える、Header（Accept-Language等）だけ変える
- 変化の結果を「Hit/Miss」「レスポンス差」「ログ差」で記録し、キーに入っている/いないを推定する

### 4) 正規化差は “層間差” を取りに行く
- 同じ入力でも
  - フロントログ上の正規化後URI
  - Originが受け取ったHost/path/query
  - キャッシュキー（取れるなら）
が一致しない場合、そこが衝突/分裂の起点になる

---

## 観測シグナル（Keying領域に特化：何を見たら次に何を取るか）
### シグナル1：同じURLなのに、2回目が急に速い/遅い
- 解釈：キャッシュ関与の可能性
- 次の一手：Age等のヘッダ・ログで層を確定（CDNかProxyか）

### シグナル2：Query順序/エンコード差でヒットが揺れる
- 解釈：Query正規化がキーに影響している（または逆に無視して衝突している）
- 次の一手：Origin側が受け取るQueryの形（ログ）を確認し、CacheとOriginの解釈差を特定

### シグナル3：Host表現差で挙動が揺れる
- 解釈：authority/Host正規化差、マルチテナント境界のリスク
- 次の一手：upstream先・SNI/Hostの取り扱い、テナント識別子がキーに入っているかを評価（最優先で重大）

### シグナル4：Varyにないヘッダでレスポンスが変わる
- 解釈：Vary不足（衝突リスク）または中継点が独自キー
- 次の一手：キャッシュ層ログで実際のキー要素（device/geo/headers）を確認できるなら取る

---

## 典型的な“危険な境界”チェック（実害評価の軸）
Keyingが壊れているとき、どの境界が巻き込まれるかで重大性が決まる。

### 1) ユーザ境界（認証済み/個人化）
- レスポンスがユーザに依存するのに、キャッシュ可能/キー設計が不十分
- 影響：情報漏えい、他者の画面表示（操作確定は別途）

### 2) テナント境界（B2B：org/subdomain）
- テナント識別がHost/path/queryに埋め込まれている場合、正規化差で衝突すると致命的
- 影響：別組織データの露出、監査破綻

### 3) 機能境界（管理/設定/エクスポート）
- /admin、設定画面、出力（CSV/PDF）など
- 影響：誤った内容の配布、管理画面断片の露出など（条件次第）

---

## 防御（設計要件：Keyingを“仕様”に落とす）
### 1) 「キャッシュしてよいもの」を明確化（デフォルト拒否）
- ユーザ依存、権限依存、テナント依存、CSRFトークンを含む、機微情報を含むレスポンスは原則キャッシュしない
- 例外でキャッシュするなら、キーに境界要素を含める（テナント/言語/圧縮等）＋監査ログ必須

### 2) 正規化規則を固定（層間一致）
- Host/Path/Queryの canonicalization を統一し、CDN/Proxy/Originで差が出ないようにする
- H2→H1変換境界（:authority↔Host）の規則も仕様化（別ファイルへ接続）

### 3) Vary運用のガードレール
- Vary不足は“衝突”を作る（危険）、Vary過多は“運用崩壊→例外増”を作る（危険）
- どのヘッダで表現が変わるかを明文化し、Varyと実装キーが一致するように監査する

### 4) ログ相関（再発防止の中核）
- キャッシュ層：hit/miss、キー（またはキー構成要素）、bypass理由を記録
- Origin：受け取ったHost/path/query、request_id
- これがないと、事故後に“なぜ混線したか”が追えない

---

## 04_labs（Keying/正規化差を“事故らず”理解する）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/19_cache_poisoning_01_keying_vary_normalization/`
- Lab設計要件
  - 構成：CDN相当（またはReverse Proxyキャッシュ）→Origin
  - 変数（意図的に差を作る）
    - Query順序の扱い（並べ替える/しない）
    - Path正規化（//縮退、末尾/、デコード順序）
    - Host正規化（末尾ドット、大小）
    - Vary有無（Accept-Language/Encoding）
  - 観測点
    - proxy：cache key / hit-miss / bypass理由
    - origin：受信したhost/path/query
    - client：ヘッダ（Vary/Age等）と応答時間
  - 成功条件
    - 衝突/分裂のどちらが起きたかをログで説明できる
    - “どの層の正規化差”が原因かを言語化できる

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# この領域は「入力を増やすほど第三者影響のリスク」が上がる。
# 目的は Keying（何がキーに入るか）と Normalization（同一視/別扱い）を、観測で固めること。
# - ベースライン固定
# - 差分は1軸ずつ
# - Hit/Missは複数証拠で判定
# - 可能なら cacheログとoriginログで相関
~~~~

---

## 深掘りリンク（最大8）
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_11_path_traversal_01_normalization（dotdot_encoding）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
```
