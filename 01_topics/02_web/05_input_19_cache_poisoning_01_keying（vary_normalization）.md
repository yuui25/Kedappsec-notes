## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：キャッシュは「同一キー＝同一レスポンス」という前提で成立する。Keying（キー設計）や正規化（canonicalization）が不適切だと、(1) 本来別物のリクエストが同一キーに衝突、(2) 本来同一のリクエストが別キーに分裂、が起きる。前者はキャッシュ汚染・情報漏えい・権限境界崩壊に直結する。
  - 満たす：キャッシュ可否・キー構成・正規化規則（Host/Path/Query/Header/Encoding 等）を設計として固定し、Varyを正しく運用する。ユーザ依存レスポンスは原則キャッシュしない（またはキーにユーザ境界を含める）。多段キャッシュ（CDN→Reverse Proxy→アプリ）間で正規化ルールを揃える。ログ相関でキャッシュヒット/ミスと生成元を追跡できるようにする。
- WSTG
  - 該当テスト観点：キャッシュは「入力→出力」の一形態だが、単体アプリではなく“中継点（CDN/Proxy）”を含む。テストは (1) キャッシュ可能性の判定、(2) キー推定（何がキーに入っているか）、(3) 正規化差の検出（同一視/別扱い）、(4) 影響（混線・汚染・漏えい）の切り分け、を観測で行う。
- PTES
  - 位置づけ：脆弱性分析〜侵害評価の橋渡し。まず「キャッシュが効いている」「キーがこう見える」を観測で固め、次に“高価値の分岐”（認可・セッション・テナント・管理機能・配信物）に当たるかで実害評価を決める。第三者影響が出やすいので、少数試行・隔離環境・証跡重視が必須。
- MITRE ATT&CK
  - T1190（公開アプリ脆弱性悪用）の入口になり得る。
  - Defense Evasion：エッジ層での監査/検査の外側にある挙動（キャッシュ）を利用し、検知や再現を困難化し得る。
  - Collection / Impact：ユーザ間混線（情報漏えい）、不正コンテンツ配布（影響）に接続（ただし成立条件の証拠化が前提）。

---

## タイトル
Cache Poisoning（Keying）：Vary と正規化差でキャッシュキーが壊れると、境界（ユーザ/テナント/機能）が混線する

---

## 目的（このファイルで到達する状態）
- キャッシュの「キー設計（Keying）」を、攻撃者視点の意思決定に使える。
  1) このレスポンスはキャッシュされ得るか（キャッシュ可能性）
  2) キーは何で構成されるか（Host/Path/Query/Header…）
  3) 正規化差はどこにあるか（同一視/別扱いのズレ）
  4) 影響は何か（混線/汚染/漏えい/権限境界破壊）
  5) どう検証して成立根拠を取るか（ヘッダ・タイミング・ログ相関）
- 以降の分割ファイル（unkeyed / poisoned_object）へ“確実に繋がる入口”になる。

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：Cache Poisoning のうち「Keying（キー）」と「Vary」「正規化（Normalization）」に関する境界モデルと観測
  - キーに何が入るか／入らないかの推定
  - Vary の意味と運用上の失敗パターン（設計の破綻）
  - 正規化差（CDN/Proxy/Origin の canonicalization 不一致）による衝突・分裂
- 扱わない（別ファイルに接続）
  - unkeyed input の具体類型（ヘッダ/パラメータ）での汚染成立：`05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
  - poisoned object（格納済みレスポンスの悪用・拡散）：`05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`

---

## 前提：キャッシュは「境界を作る装置」でもある
- キャッシュは性能装置だが、同時に “誰に何を返すか” を決める境界装置でもある。
- キャッシュキーは「境界の定義そのもの」。
  - ユーザ境界（ログイン差）
  - テナント境界（org_id / subdomain）
  - 機能境界（/admin / api / assets）
  - 表現境界（言語・圧縮・デバイス）
- ここが壊れると、アプリの認証/認可が正しくても「違う人のレスポンスが返る」形で破綻する。

---

## 境界モデル（Keying：キャッシュが“同一”とみなす範囲）
### 1) キャッシュ階層（多段が基本）
- ブラウザ/アプリ内キャッシュ
- CDN（Edge）
- Reverse Proxy（例：LB/ゲートウェイ）
- アプリ内キャッシュ（アプリ/フレームワーク/中間層）
- 重要：層ごとに「キー」「正規化」「キャッシュ可否」が違う。多段のどこで破綻しているかが所見の芯。

### 2) キー構成要素（典型の分解）
- スキーム（http/https）
- Host（:authority / Host、ポート、末尾ドット等）
- Path（正規化：//、/./、/../、大文字小文字等）
- Query（順序、重複、デコード、空値、区切り）
- Header（Varyで列挙されるもの、または暗黙に使われるもの）
- Cookie（通常はキャッシュ抑止に使われるが、誤設計で混線の原因になる）
- Method（GET/HEADが中心だが、例外は存在）
- ここから先の思考：どの要素が “境界として必要” なのにキーに含まれていないか（＝混線余地）。

---

## Vary の意味（Keyingを“宣言”するヘッダ）
### 1) Varyは「このレスポンスはこのリクエストヘッダに依存する」を表す
- 正しく運用できていれば、表現差（言語、圧縮、コンテンツタイプ等）で別キーになる。
- ただし、Varyは“万能”ではない。
  - 実際の中継点がVaryを尊重しない/上書きする/独自ルールを持つ場合がある
  - Varyを増やし過ぎるとキャッシュ効率が崩壊し、運用が別の方向へ歪む（結果、例外設定が生まれやすい）

### 2) Vary運用が壊れる典型（設計としての失敗）
- ユーザ依存レスポンスなのに、Vary: Cookie / Authorization が付かない（またはキャッシュ層が無視）
- 表現依存（例：Accept-Language）なのに Vary が付かず、別言語が混線
- Vary: * の誤用/濫用（実装・中継点によって挙動が荒れる）
- “本当に依存するヘッダ” と “中継点がキーに入れているヘッダ” が一致しない

---

## 正規化（Normalization）：同一視/別扱いのルールがズレると壊れる
Keyingの事故は、単に「キーに入れ忘れ」だけではない。
“同じはず”のものが別扱い、または“別物”が同一扱いになる正規化差が本丸になる。

### 1) 正規化の対象（代表カテゴリ）
- Host
  - 大文字小文字、末尾ドット、ポート表記、IDN/Punycode、複数Host、:authority↔Host
- Path
  - // の縮退、/./、/../、URLデコード順序、セミコロン以降、末尾スラッシュ、大小文字（サーバ依存）
- Query
  - パラメータ順序、重複キー、空値、区切り（; と &）、デコード順序、+ と %20
- Header
  - ヘッダ名の大小、重複ヘッダの結合規則、空白正規化、折り返し（旧式）など
- 重要：フロント（CDN/Proxy）とバック（アプリ）で正規化順序が違うと、(1) WAF/ACL と (2) キャッシュ と (3) アプリ処理が別物を見てしまう。

### 2) 正規化差が生む2種類の壊れ方
- 衝突（Collision）
  - 本来別のリクエストが “同じキー” とみなされ、別人/別条件のレスポンスが返る（危険度が高い）
- 分裂（Fragmentation）
  - 本来同一のリクエストが “別キー” になり、キャッシュ効率が崩れ、運用が例外だらけになる（結果として安全策が剥がれやすい）

---

## 観測ポイント（Keying推定：ここが薄いと次ファイルが回らない）
> ここでは「ペイロード」よりも「何を見ればキーが分かるか」を固定する。

### 1) レスポンスヘッダから分かること（出る範囲だけ）
- Cache-Control / Expires / Pragma
  - キャッシュ可能性（public/private/no-store 等）
- Vary
  - キーに入る“べき”ヘッダの宣言（ただし実装が尊重するとは限らない）
- Age / Via / X-Cache / cache-status / server-timing（cache）
  - ヒット/ミスの兆候、どの層が返したかの推定（製品依存）
- ETag / Last-Modified
  - 再検証挙動（304）とオブジェクト同一性の推定（ただしキーそのものではない）

### 2) タイミング差分（Hit/Miss推定）
- 同一条件で2回目が顕著に速い → キャッシュヒットの可能性
- 微差入力で急に遅くなる/速くなる → キーがその差分を見ている可能性

### 3) 変化させる軸（キーの“構成要素”を推定するための最小差分セット）
- Host系：サブドメイン、ポート、末尾ドット、大小（許容される範囲で）
- Path系：末尾スラッシュ、//、%2f 等のデコード差（安全な範囲で）
- Query系：順序入替、空値、重複、エンコード差
- Header系：Accept-Encoding / Accept-Language / User-Agent（CDNが使いがち）
- Cookie系：Cookie有無（多くはキャッシュ抑止に働くが、例外が危険）

---

## 攻撃者視点での利用（現実寄せ：Keyingが壊れると何が起きるか）
> ここでは「成立したら何ができるか」を“境界の破壊”として整理する（断定しない）。

### 1) ユーザ混線（最優先で疑う実害）
- ログイン状態や個人化がキーに入っていない、または正規化差で衝突すると、
  - 別ユーザのレスポンスが返る（情報漏えい）
  - CSRF不要で“見えてはいけない画面”が見える（ただし操作確定は別問題）
に繋がり得る。

### 2) テナント混線（B2Bで致命的）
- Host/subdomain/org_id がキー設計に適切に入っていない/正規化差で衝突すると、
  - 別テナントのレスポンスが返る
  - テナント境界の監査が破綻
が起き得る（重大性が跳ね上がる）。

### 3) フロント制御（WAF/ACL）との不一致
- WAF/ACLが“正規化後”で判定し、キャッシュが“正規化前/別規則”でキーを作ると、
  - 検査を通った内容がキャッシュされ、別条件で配布される
という歪みが出る。

### 4) 次ファイルへの接続（本当に攻撃になるのはここから）
- Keyingが推定できたら、次は
  - unkeyed input（キーに入らないがレスポンスに影響）を探す
  - poisoned object（格納された汚染レスポンスの拡散）を評価する
へ進む。Keyingが曖昧なままだと検証が事故る（第三者影響）ので、先にKeyingを固める。

---

## 次に試すこと（仮説A/B：判断→分岐）
### 仮説A：キャッシュは効いているが、キーが“表現差（言語/圧縮/UA）”程度しか見ていない
- 期待される状態
  - Vary: Accept-Encoding / Accept-Language が効いている
  - Host/Path/Queryは素直にキー化される
- 次の一手
  - まずはキー推定を確定（どの軸でHit/Missが変わるか）
  - その後、`02_unkeyed` で「レスポンスに影響するがキーに入らない入力」を狙う（事故を起こさずに成立根拠を取る）

### 仮説B：正規化差があり、“別物が同一キー扱い”の衝突が疑われる
- 兆候
  - Query順序/エンコード微差でヒットが揺れる
  - Host/Pathの表現差で upstream が揺れる（多段構成）
- 次の一手
  - front/backで「何を同一視しているか」をログ相関で確定（可能なら最優先）
  - 同一視されるなら、その衝突点がユーザ境界/テナント境界に触れるかを評価する（ただし第三者影響が出る検証は制約を守る）
  - 必要なら `04_observable_signals` の枠（タイミング/層/ログ相関）で“状態”として固める

---

## 手を動かす検証（設計：安全に成立根拠を取る）
### 検証の安全策（必須）
- 少数回で止める（キャッシュは第三者影響が出やすい）
- できれば隔離環境（Lab）で再現してから実環境へ
- “混線したように見える”だけで断定しない（ログ/ヘッダ/相関で根拠化）

### 証跡（最低ライン）
- リクエスト（差分が分かる形：URL/ヘッダ）
- レスポンスヘッダ（Cache-Control/Vary/Age等）
- 時系列（1回目/2回目/微差入力の比較）
- 可能なら front/backログ（cache hit/miss、upstream先、request_id）

---

## 04_labs（Keyingと正規化差を“観測で理解”する）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/19_cache_poisoning_keying_vary_normalization/`
- Lab設計要件（手順書ではなく設計）
  - 構成：CDN相当（またはReverse Proxy）→アプリ
  - 変数：
    - Varyあり/なし
    - 正規化ルール差（Path/Query/Hostの正規化順序を変える）
  - 観測点：
    - レスポンスヘッダ（Vary/Age 等）
    - 2回目の応答時間（Hit/Miss）
    - proxyログ（cache key、hit/miss、upstream）
    - アプリログ（受け取ったHost/path/query）
  - 成功条件：
    - “どの要素がキーに入っているか”を差分で説明できる
    - “正規化差で衝突/分裂が起きる”をログで証明できる

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# この領域は「試す入力」を増やすほど事故りやすい。
# 目的は、(1) キャッシュ可能性、(2) キー構成、(3) 正規化差 を観測で固めること。
# - 1回目/2回目の差（時間・ヘッダ）
# - Vary と cache系ヘッダ
# - 可能なら proxyログの cache-key / hit-miss
~~~~

---

## 深掘りリンク（最大8）
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
- `05_input_11_path_traversal_01_normalization（dotdot_encoding）.md`
- `06_config_03_セキュリティヘッダ（CSP_HSTS_Frame_Referrer）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
