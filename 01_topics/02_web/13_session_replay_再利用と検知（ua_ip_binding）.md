## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：セッションID（Cookie等）やセッショントークンが第三者に取得されると、同じトークンを提示するだけで“認証済み状態”が再利用され得る（＝Session Hijacking/Replay）。このとき「失効」「再認証」「バインディング（IP/UA等）」「監査ログ」の設計が弱いと、MFAを含めて迂回される可能性がある。:contentReference[oaicite:0]{index=0}
  - 満たす：ASVSのセッション管理（V3）では、(1) セッション生成/更新/失効、(2) Cookie属性、(3) セッションバインディング、(4) ログアウト/タイムアウト、(5) トークンベースの管理などを一貫設計する。特に“セッションバインディング要求（V3.2）”を、誤検知と実運用の折り合い込みで実装する。:contentReference[oaicite:1]{index=1}
- WSTG
  - 観点：WSTGのセッション管理テスト（Session Management Testing）には、セッションハイジャック、並行セッション、ログアウト、タイムアウト等の観点が含まれ、セッション再利用の成立条件（どの属性で縛る/縛らない、どこで検知する）を“観測で確定”するのが主眼。:contentReference[oaicite:2]{index=2}
- PTES
  - 位置づけ：Exploitationで“再利用できる状態”が見えると、侵害後の継続（再訪問）や横展開（同一セッション文脈での高権限操作）に直結する。Reportingでは、攻撃可能性の指摘に止めず「検知・封じ込め・誤検知抑制」まで落とす（ログ相関、段階制御、失効戦略、例外設計）。
- MITRE ATT&CK
  - セッションクッキーの窃取・再利用は、認証済みの状態を資格情報なしで再現できる行為として整理されている（Web Session Cookie関連）。これにより一部のMFAが迂回され得るため、セッション再利用の検知・失効が重要になる。:contentReference[oaicite:3]{index=3}

---

## タイトル
Session Replay（再利用）と検知：UA/IP binding を“境界”として成立させる

---

## 目的（このファイルで到達する状態）
- 「セッションが盗まれる/再利用される」問題を、**再現可能な境界モデル**として説明できる。
- UA/IP binding を“万能策”として扱わず、以下を切り分けて設計・診断できる。
  1) どのトークンが再利用対象か（Cookieセッション / Bearer / 内部トークン / Job文脈）
  2) どこで検知するか（Edge/BFF/API/Policy/監査ログ）
  3) 何で縛るか（UA/IP/Accept-Language/Device/証明書等）
  4) どう反応するか（継続許可/step-up/強制ログアウト/アラート）
  5) 誤検知・UX事故をどう抑えるか（NAT/モバイル/プライバシー機能/ローミング）
- “次の一手”をA/B分岐で出せる（検知が弱いのか、失効が弱いのか、バインディングが強すぎるのか）。

---

## 扱う範囲（スコープ）
- 扱う
  - セッション再利用（Session Replay/Hijacking）の成立条件と検知
  - UA/IP binding（強制バインディング/ソフトバインディング/リスクスコア）の設計
  - 失効・タイムアウト・並行セッション・step-up と組み合わせた“運用可能”な防御
  - 監査ログ/相関IDを用いた「追跡・封じ込め」の設計
- 扱わない（接続先）
  - Cookie属性の詳細：`02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
  - セッションライフサイクル全体：`02_authn_02_session_lifecycle（更新_失効_固定化_ローテーション）.md`
  - 端末紐付け全般：`02_authn_08_device_binding（端末紐付け_IP_UA_fingerprint）.md`
  - Token Binding（DPoP/mTLS等）：`02_authn_18_token_binding（DPoP_mTLS）観測.md`
  - ログ/相関設計：`11_logging_tracing_相関IDと証跡設計.md`

---

## 境界モデル：Session Replay は「再利用可能な“認証済み素材”」がどこまで通るか
### 1) 資産境界（何が盗まれて何が再利用されるか）
- CookieベースのセッションID（典型）
  - 盗まれたセッションIDを提示するだけで、同一ユーザとして振る舞える可能性がある（＝セッションハイジャック）。:contentReference[oaicite:4]{index=4}
- Bearerトークン（Access token等）
  - トークンがそのまま認証素材として扱われる場合、リプレイ耐性は（署名よりも）“提示者が本人か”の問題になる
- 内部トークン/ヘッダ（Gateway→サービス）
  - 内部境界が破られると影響半径が大きい（「内部のみ信頼」を崩されると全サービスに波及）
- 非同期（Job/Queue）
  - “投入時に認証済み”でも、実行時に権限・セッションが有効とは限らない（時間境界）

### 2) 信頼境界（何を“同一セッションの本人性”として信じるか）
- 強い（ただし実装コスト）
  - mTLS/DPoP等の暗号学的バインディング（提示者を証明）
- 中程度（設計次第）
  - device_id（アプリ発行の端末識別子）、セッションに紐付くサーバ側状態（リスク情報）
- 弱い（誤検知・回避が起きやすい）
  - IP（NAT/ローミング/IPv6プレフィックス変動）
  - User-Agent（ブラウザ更新、同一UAの衝突、偽装）
  - Accept-Language 等（環境差で揺れる）

### 3) 権限境界（“再利用”を許すと何が起きるか）
- 認証済み状態の再利用は、MFAを含む“本人確認ステップ”を既に通過した状態を再現し得るため、重要操作（送金・権限付与・連携追加等）でのstep-up/再認証が重要になる。:contentReference[oaicite:5]{index=5}

---

## UA/IP binding の設計：強制バインディングではなく“検知と段階制御”に落とす
### 1) まず決める：バインディングは「阻止」か「検知」か
- 阻止（hard binding）
  - 一致しない場合、即セッション無効化/拒否
  - 強いが、誤検知の損失が大きい（正規ユーザ巻き込み）
- 検知（soft binding）
  - 変更を検出し、(1) step-up、(2) 追加確認、(3) 監査ログ/アラート、(4) 高リスク操作のみ拒否、など段階制御
  - 現実のネットワーク変動・端末変動を吸収しやすい

結論：Web一般では soft binding を基本にし、重要操作だけ hard に寄せる（境界を“操作”で切る）。

### 2) OWASPの観点（何を保存し、どう異常検知に使うか）
- セッション確立時に、IP/UA/Accept-Language/日時などをサーバ側に保存し、著しい変化を検知することでセッションハイジャック検知に繋げる、という整理がある。:contentReference[oaicite:6]{index=6}
- ただし「変化＝攻撃」と直結させると事故が出るため、変化の扱い（許容/段階/例外）を仕様化する。

### 3) 具体の“縛り方”（UA/IPをそのまま一致判定しない）
- IPの扱い（誤検知が起きやすい）
  - NAT（多数ユーザが同一IP）やモバイルローミングでIPは容易に変わる
  - 推奨設計（例）
    - “完全一致”ではなく、短時間の変動を許容する
    - IPv4は/24程度、IPv6は/56〜/64程度のプレフィックス一致など「粗い近似＋監査」に寄せる（環境により調整）
    - 変更時は即拒否ではなく「リスク増加」として扱い、重要操作にだけ効かせる
- User-Agentの扱い（偽装と衝突の両面）
  - UAは同一端末でも更新で変わる。逆に攻撃者が合わせることも可能
  - 推奨設計（例）
    - UA全文一致ではなく、主要要素（ブラウザファミリ/OS/メジャーバージョン）に正規化
    - “同一端末での微差”は許容し、ファミリが変わる（例：Chrome→Safari）など大差を高リスクとする
- Accept-Language 等の補助シグナル
  - 単体では弱いが、UA/IPと組み合わせると“変化の整合性”が取れる
  - 例：IPが変わったがUA/言語/デバイスが同じ → 低〜中リスク、IPもUAも変わった → 高リスク

---

## 観測ポイント（診断・設計レビューで最初に確定する）
### 1) どのイベントで“セッション本人性”を評価しているか
- 通常リクエスト（GET/画面遷移）で都度チェックしているか
- 重要操作（権限付与/決済/連携追加/エクスポート）だけでチェックしているか
- ログイン直後・トークン更新時・セッション更新時にチェックしているか

### 2) どのHopで評価しているか（Edge/BFF/API/Policy）
- Edge
  - IPベースの粗い検知はできるが、user_idや操作の意味を理解しにくい
- API/Policy（推奨）
  - user_id/tenant_id/action を含めて“意味のある検知”ができ、監査ログと繋がる
- 非同期（Job）
  - “実行時”に再評価するのか（権限/セッション有効性）、投入時スナップショットにするのか（要件次第）

### 3) どのデータを保存し、どこに残すか（ログ/DB/監査）
- セッション状態（サーバ側）
  - baseline：初回の ip_norm / ua_norm / accept_lang / device_id / created_at
  - rolling：直近N回の観測値（変化の履歴が追えると誤検知を減らせる）
- 監査ログ（必須）
  - “疑わしいセッション”として判定した事実（risk_score、理由、対応アクション）を記録し、相関IDで追えるようにする

---

## 結果の意味（状態として説明する：設計/診断の判定を迷わせない）
### 状態A：バインディングなし（再利用は“止める手段がない”）
- 意味
  - セッションIDが取得された場合、提示だけで成立し得る
- 次の一手
  - 失効戦略（短寿命/ローテーション/ログアウト無効化）と、soft binding（検知＋step-up）を最短で導入する

### 状態B：IP/UAを“厳格一致”で強制（硬すぎて運用事故になりやすい）
- 意味
  - 攻撃には強いが、正規ユーザのネットワーク変動でログアウト頻発、サポート負荷増
- 次の一手
  - 重要操作のみ強制、通常操作はsoftへ。IPは正規化（prefix/AS/地域）して“差分”で扱う

### 状態C：soft binding（検知＋段階制御）があり、重要操作でstep-up
- 意味
  - 再利用は一定確率で検知され、被害が重要操作で抑制されやすい
- 次の一手
  - “反応”が適切か（即失効か、step-upか、通知か、SOC連携か）を運用要件で詰める
  - 監査ログの粒度（誰が/どの条件で/何をしたか）を強化する

### 状態D：検知はあるがログ/相関が弱く、調査ができない
- 意味
  - ブロックしても根拠が説明できず、誤検知か攻撃かの切り分けができない
- 次の一手
  - `11_logging_tracing_相関IDと証跡設計.md` の最小セット（trace_id/decision/reason）に合わせて整備

### 状態E：暗号学的バインディング（DPoP/mTLS等）まで到達
- 意味
  - “盗まれたトークンのリプレイ”が構造的に難しくなる（実装品質は別途必要）
- 次の一手
  - 運用（鍵配布/端末管理）と例外（ブラウザ/SDK混在）を含めて、適用範囲を段階導入する

---

## 攻撃者視点での利用（成立条件を“意思決定”に変える）
- セッションクッキー/セッションIDが再利用できると、資格情報なしで認証済みとしてアクセスできる（Web Session Cookieの再利用は公的にも整理されている）。:contentReference[oaicite:7]{index=7}
- 逆に言えば、攻撃者が嫌がるのは次の2点：
  1) “同じトークンを提示しても”本人性が一致せず、重要操作で止まる（step-up/再認証）
  2) 使った瞬間に検知され、セッション失効＋アラートで封じ込められる（相関ID・監査ログが整備されている）

---

## 次に試すこと（仮説A/B：原因別に最短で潰す）
### 仮説A：そもそも再利用検知がない（または見えていない）
- 次の一手
  - セッション作成時に baseline（ip/ua/lang/date等）を保存し、変化検知を追加する（soft bindingで開始）。:contentReference[oaicite:8]{index=8}
  - 重要操作に step-up を要求し、認証済みセッションでも追加確認を入れる（MFA/再ログイン）。:contentReference[oaicite:9]{index=9}
  - 監査ログに decision/reason を必須化（「なぜ疑わしいと判断したか」が残らないと運用できない）

### 仮説B：検知はあるが“硬すぎて誤検知”が多い（UX事故）
- 次の一手
  - IP/UAの正規化（全文一致から卒業）と、段階制御（通常操作は許容、重要操作だけ強制）へ移行
  - “変更が正当なケース”を先に列挙し、救済導線を仕様化（ユーザ通知、再認証、サポートの最小対応）

### 仮説C：検知はあるが“反応”が弱い（気づくだけで止められない）
- 次の一手
  - 反応を3段階で固定
    - 低：ログ＋通知（本人に「新しい環境からの利用」）
    - 中：step-up（重要操作ブロック/再認証要求）
    - 高：セッション即失効＋全端末ログアウト（条件は厳格に）
  - Rate-limit と連携（疑わしいセッションの試行回数を抑制）：`12_rate-limit_設計（API_key_user_ip）.md`

### 仮説D：盗用後の失効が効かない（セッション/トークン寿命が長すぎる）
- 次の一手
  - セッション寿命（idle/absolute）とローテーションを見直し、盗用時の影響時間を短くする
  - refresh rotation / reuse検知（別ファイル側）と整合させる：`02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`

---

## 04_labs（手を動かす：自分のセッションで“再利用と検知”を安全に観測する）
- Lab候補（例）
  - `04_labs/02_web/13_session_replay_01_soft_binding_risk_scoring/`
  - `04_labs/02_web/13_session_replay_02_step_up_on_sensitive_actions/`
  - `04_labs/02_web/13_session_replay_03_audit_logs_for_suspicious_session/`
- Lab設計要件（手順書ではなく設計）
  - 同一ユーザの“正当な変化”（モバイル回線、VPN、ブラウザ更新）と、“疑わしい変化”（UA大差＋IP大差）を再現できる
  - 入口〜API〜重要操作まで、どの地点で検知され、どう反応するか（許容/step-up/失効）をログと相関IDで追える
  - 監査ログに decision/reason が残り、誤検知と攻撃の切り分けができる

---

## コマンド/例（例示は最小限：意味→判断→次の一手を優先）
~~~~
# 目的：
# - UA/IP “一致判定”ではなく、正規化＋差分検知＋段階制御に落とす
# - 判定結果（risk/decision/reason）を監査ログに残し、相関IDで追えるようにする

# サーバ側で持つイメージ（擬似データ）
# session_id:
#   user_id: ...
#   tenant_id: ...
#   baseline:
#     ip_prefix: ...
#     ua_family: ...
#     accept_language: ...
#     created_at: ...
#   last_seen:
#     ip_prefix: ...
#     ua_family: ...
#     seen_at: ...
#   risk_state: low|medium|high
#   response_policy: allow|step_up|required_reauth|revoke
~~~~

---

## 深掘りリンク（最大8）
- `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
- `01_topics/02_web/02_authn_02_session_lifecycle（更新_失効_固定化_ローテーション）.md`
- `01_topics/02_web/02_authn_08_device_binding（端末紐付け_IP_UA_fingerprint）.md`
- `01_topics/02_web/02_authn_16_step-up_再認証境界（重要操作_再確認）.md`
- `01_topics/02_web/02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`
- `01_topics/02_web/02_authn_18_token_binding（DPoP_mTLS）観測.md`
- `01_topics/02_web/11_logging_tracing_相関IDと証跡設計.md`
- `01_topics/02_web/12_rate-limit_設計（API_key_user_ip）.md`
