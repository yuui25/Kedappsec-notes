## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - この技術で満たす/破れる点：
    - 破れる：入力が「キーとして構造に入る」ことで、**認可判定・テンプレ評価・実行APIのオプション**など“意味のある分岐点（sink）”が外部入力により間接的に操作される。
    - 満たす：allowlist（キー/構造）＋安全なmerge/set＋共有オブジェクト不使用＋`hasOwnProperty`等の境界固定により、汚染がセキュリティ判断点へ届かない。
- WSTG
  - 該当テスト観点：
    - 入力検証だけでなく、「サーバ側の状態遷移・認可・テンプレ処理」に対し、**同一リクエストで“結果だけ変わる”差分**を作り、汚染が“判断点”に到達しているかを検証する。
- PTES
  - 位置づけ：
    - 脆弱性分析〜侵害評価の“核心”。`05_input_14_prototype_pollution_01_sources` で source（到達経路）を固めた後、ここで sink（影響点）を確定して、報告を「成立根拠（到達）＋影響（分岐）」として完成させる。
- MITRE ATT&CK
  - T1190（公開アプリ脆弱性悪用）を入口に、sink次第で目的が分岐する。
    - 認可：Privilege Escalation / Defense Evasion（権限判定の迂回）
    - テンプレ：Execution（スクリプト実行に接続する場合）
    - RCE：Execution（サーバ実行）＋Lateral Movement / Credential Accessへ連鎖し得る（ただし成立条件が厳しいため、条件を分解して評価）

---

## タイトル
Prototype Pollution の sink を分解する
認可（authz）・テンプレ・実行（RCE）へ“効く”条件を、分岐点として確定する

---

## 目的（このファイルで到達する状態）
- Prototype Pollution の評価を「sourceがある」から「実害がある」へ進めるために、次を説明できる。
  1) どの“判断点（sink）”が汚染に影響されるか（認可/テンプレ/実行）
  2) 影響が出る成立条件（データフロー、共有性、参照方法、列挙方法）を分解できる
  3) 侵害評価を、RCE偏重ではなく「最短の実害（権限逸脱/情報漏えい/DoS）」で確定できる
- 報告に落とす形（必須）：
  - 「危険キーが到達する経路（source）」＋「影響する分岐点（sink）」＋「分岐が変わる観測結果」＋「修正の設計要件」

---

## 扱う範囲（このファイルの守備範囲）
- 本ファイル：sink（影響点）の分類と、成立条件の詰め方
  - 認可（AuthZ）sink：ロール/テナント/オブジェクトスコープ/feature flag/ガード分岐
  - テンプレ sink：テンプレ変数解決、エスケープ/サニタイズ分岐、ヘルパ/フィルタ解決
  - RCE sink：危険API（プロセス起動、テンプレ評価、動的ロード等）の“オプション/引数”が汚染の影響を受けるケース
- 直接は扱わない：
  - source（parse/merge/set）の作り方は `05_input_14_prototype_pollution_01_sources` に委譲
  - “具体的な攻撃文字列”の列挙（本プロジェクトは境界と成立根拠を優先）
- 接続先：
  - `05_input_14_prototype_pollution_01_sources（merge_parse）.md`
  - `03_authz_01_境界モデル（オブジェクト_ロール_テナント）.md`
  - `05_input_01_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `05_input_06_xss_*`（クライアント側へ落ちる場合）
  - `04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 境界モデル（sink＝“意味のある分岐”）
Prototype Pollution の影響評価は「汚染できるか」ではなく「汚染が **どこで参照されるか**」で決まる。

### 1) 最小データフロー（source→sink）
外部入力（query/body/form/ws/import）
→ parse（構造化）
→ merge/set（既存オブジェクトへ取り込み）
→ 共有/再利用（config / req-context / template-context / policy / cache）
→ 参照点（if判定、テンプレ評価、危険API呼び出し）
→ 影響（権限逸脱、情報漏えい、DoS、実行）

### 2) sinkが成立する“4条件”（差分＝成立根拠）
- 条件A：汚染が「参照されるオブジェクト」に入っている（共有オブジェクト、または参照元が同一）
- 条件B：参照が「プロトタイプ連鎖を辿る」形で行われる（単純な `obj.key`、`in`、列挙など）
- 条件C：判定ロジックが「存在/真偽」に依存している（存在すればOK、真ならOK、デフォルトがfalse/undefined）
- 条件D：参照後に “高価値の処理” が起きる（認可決定、テンプレ変数解決、危険APIの引数/オプション反映）

※この4条件を、観測（レスポンス差分・ログ・副作用）で固めるのが本ファイルの主眼。

---

## sink 1：認可（AuthZ）に効くパターン（最優先で狙う：現実的）
RCEより、まず認可sinkを狙う。理由は「成立条件が単純で、影響が明確で、再現が安定」だから。

### A. “フラグ/ロール”参照の単純分岐
#### 典型形（設計上の匂い）
- `if (user.isAdmin) ...`
- `if (ctx.role === 'admin') ...`
- `if (featureFlags.xxx) ...`

#### 何が起きるか（意味）
- デフォルトでは未定義/falseで通らないはずの分岐が、汚染により“真”として評価され、ガードをすり抜ける。

#### 観測ポイント（差分で確定）
- 同一セッション/同一ユーザで、特定エンドポイントの挙動が「許可/拒否」で変わる
- エラー種別が変わる（401/403→200、または画面遷移）

#### 次の一手（成立後）
- “権限が上がったように見える”だけで止めず、
  - どの操作が可能になったか（変更・閲覧・実行）
  - その操作が「別ID/別テナント」に波及するか
  を `03_authz_*` の境界モデルで詰める。

---

### B. “オブジェクトスコープ”に効く（IDOR/BOLAの増幅）
#### 典型形
- フィルタ条件（tenantId/orgId/userId）の注入・上書き
- “アクセス可能範囲”を表す条件オブジェクト（policy/context）への混入

#### 何が起きるか（意味）
- 本来は `WHERE tenant_id = X` のように縛るべきスコープが、汚染により“条件が外れる/別値になる/未適用になる”。

#### 観測ポイント
- 一覧/検索の件数が増える
- 他テナントの識別子が混入する
- レスポンス構造が変わる（返るフィールドが増える等）

#### 次の一手
- 影響の“半径”を確定：閲覧のみか、更新/削除/承認など重要操作に到達するか
- 監査ログ上の principal/tenant がどう記録されるか（検知可能性）

---

### C. “存在判定”が弱い（allowlistがプロトタイプを拾う）
#### 典型形
- 入力フィールドの allowlist を「`key in obj`」や「列挙」で判定している匂い
- `for ... in` でプロパティを列挙し、継承プロパティまで含めてしまう匂い

#### 何が起きるか
- “本来許可していないキー”が許可される／検証がすり抜ける
- mass-assignment と組み合わさると、権限系フィールドの混入を許す

#### 観測ポイント
- 許可されないはずのフィールドが保存・反映される
- バリデーションのエラーが出なくなる

---

### D. “共有コンテキスト”汚染（1回の汚染が複数リクエストに効く）
#### 典型形
- グローバルconfig、テンプレ共通context、キャッシュ、アプリ起動時に作ったdefaultsなどに merge している匂い

#### 何が起きるか
- 影響が“自分のリクエストだけ”ではなく、“他ユーザ/他リクエスト”に拡散し得る（重大度が跳ね上がる）

#### 観測ポイント
- 時間差で他操作に影響が出る
- 別エンドポイントで同じ分岐が変わる

---

## sink 2：テンプレに効くパターン（XSS/情報漏えい/挙動改変の現実解）
テンプレsinkは、サーバ側テンプレでもクライアント側レンダリングでも成立し得るが、評価は「どの値がどこに入るか」を境界で固める。

### A. テンプレ変数解決が“継承プロパティ”を拾う
#### 典型形
- テンプレが `{{ user.name }}` 等を参照する際、内部で単純なプロパティ参照をしている
- テンプレcontextを `merge(defaults, userInput)` のように構築している

#### 何が起きるか
- 本来contextにないキーが“存在するもの”として解決され、表示内容が変わる
- エスケープ/サニタイズの分岐が変わり得る（例：`escape=false` などのオプションが間接的に変わる設計）

#### 観測ポイント
- 表示文言、属性値、リンク先などが変化する
- “テンプレエラー”の文言が変わる（ヘルパ解決・フィルタ解決が変わる）

#### 次の一手
- まずは「表示改変」や「情報露出」など、確実に再現できる影響で所見化する
- XSSまで接続する場合は `05_input_06_xss_*` と連携し、入力→DOM挿入境界で評価する（テンプレだけで完結させない）

---

### B. テンプレ“ヘルパ/フィルタ/パーシャル”解決が動的
#### 典型形
- `helperName` や `partial` 名を文字列で指定し、そこへ入力が混ざる設計
- テンプレ設定が“オプションオブジェクト”経由で渡される設計

#### 何が起きるか
- どのヘルパが呼ばれるか、どのテンプレ片が読み込まれるかが変わる（情報露出・挙動改変へ）

#### 観測ポイント
- エラーメッセージ（テンプレ名、パス）
- レンダリング結果の差分（特定ブロックが出たり消えたり）

---

## sink 3：RCEへ接続するパターン（条件が厳しいので“成立条件”で評価する）
ここは過剰に“手口”へ寄らず、実務での評価軸を固定する。
RCEは「危険APIがある」だけでは成立しない。**“危険APIの引数/オプションが汚染の影響を受ける”**が必要。

### A. “危険APIのオプションオブジェクト”を merge で作っている
#### 典型形（設計上の匂い）
- `options = merge(defaultOptions, userInputOptions)` のような設計
- options に `env/cwd/shell/timeout` のような“実行条件”が入る（具体名は実装依存。要は「実行環境を変えるキー」があるか）

#### 何が起きるか（意味）
- 実行条件が変わり、(1) 実行されるべきでない経路が動く、(2) 想定外の外部参照が走る、(3) 実行環境が改変される、などへ繋がり得る。

#### 観測ポイント（安全な範囲で）
- “外部通信が増える/変わる”
- “エラーログに実行環境情報が出る”
- “処理時間やリトライが変わる”
※実害再現（任意コマンド実行）を最初のゴールにしない。まずは「オプションが変わっている」ことを観測で固める。

---

### B. “動的ロード/動的評価”の設定がオプションで切り替わる
#### 典型形
- plugin/adapter/strategy の選択を文字列で行う
- その選択がオブジェクト経由（merge）で決まる

#### 何が起きるか
- 実行されるコードパスが変わり、評価対象が増える（設定改ざん→実行の連鎖）
- ただし環境依存が大きいので、成立条件を必ず分解する（選択可能範囲、ロード元、署名/検証、実行権限）

---

## “sink探索”の実務フロー（現実寄り：短時間で当てる順番）
### 1) まず認可sinkを当てに行く（成功率が高い）
- 管理画面、admin API、重要操作（承認/送金/権限変更/エクスポート）に対し、同一ユーザで挙動差分が出るかを見る
- 差分が出たら、権限境界（ロール/テナント/オブジェクト）で“どこが崩れたか”を特定する

### 2) 次にテンプレsink（表示改変・情報露出）を当てる
- サーバレンダリング画面、メールテンプレ、PDF/HTMLエクスポート、通知文面などで差分を見る
- XSSへ接続する場合は、DOM/レンダリング境界を別ファイルのモデルで詰める

### 3) RCEは最後（成立条件が重いので、観測で“可能性”を潰す）
- 危険APIが存在するか（設計・ログ・機能から推定）
- そのAPIの引数/オプションが“merge由来のオブジェクト”か
- 共有性があるか（1回の汚染で広がるか）
この3点が揃わない限り、RCE探索に時間を使わない（実務の優先度設計）。

---

## 観測ポイント（薄くしない：証跡として残す）
### 1) “分岐が変わった”証拠
- ステータス（403→200、404→200、同じ画面で機能が増える）
- レスポンスボディ差分（管理UI要素が出る、項目が増える）
- 件数差分（一覧が増える、フィルタが外れる）

### 2) “参照が継承プロパティを拾った”兆候
- 返却JSONに“想定外キー”が現れる
- バリデーションが通った/落ちたの差分が、キーの存在で決まっている

### 3) “共有性”の兆候
- 別エンドポイントでも同じ差分が出る
- 時間差で影響が残る（ただし検証は安全に、最小回数で）

### 4) “危険APIの条件が揃っている”兆候（RCE評価の前提）
- ジョブ/変換/プレビュー/外部連携など、実行系機能が存在する
- ログに「外部プロセス/外部コマンド/外部ツール」の痕跡がある（語彙やエラー）
- 実行系のオプションが設定として編集できる（UI/APIで）

---

## 結果の意味（所見化の粒度：source→sink→impact）
- sourceのみ成立：
  - 危険キーが通るが、影響点が見つからない → “潜在リスク”として残る（優先度は下がるが、修正は推奨）
- sink（認可/テンプレ）が成立：
  - 実害（権限逸脱、情報漏えい、表示改変）が観測できる → 高優先度（再現性が高い）
- sink（RCE）が成立：
  - 危険APIの引数/オプションが影響を受けることを観測で固めた上で、実害評価は“許可された検証環境”でのみ実施（社内/VDP条件に従う）

---

## 防御（sink側で効く設計要件：source対策と両輪）
### 1) 認可の参照は “own property” に固定する
- `hasOwnProperty` 等で「継承プロパティを認可判断に使わない」
- 認可コンテキストは `Object.create(null)` のような“辞書”型を採用し、プロトタイプ連鎖を断つ（実装方針）

### 2) テンプレコンテキストは “入力merge” しない
- テンプレに渡す context は明示的フィールド代入（allowlist）で組み立てる
- “共通context”をグローバルで持たない（リクエスト単位に閉じる）

### 3) 危険APIのオプションは外部入力から切り離す
- 実行条件（環境、パス、フラグ等）を入力で変更できない設計にする
- やむを得ない場合、許可リスト＋固定マッピング（文字列→内部定数）に落とす

### 4) 共有オブジェクトを凍結/隔離する
- “defaults” “config” “policy” を共有するなら、起動時に凍結し、リクエストごとにコピーして編集（影響の拡散を防ぐ）

---

## 次に試すこと（仮説A/Bで分岐）
### 仮説A：認可sinkが見つかった
- 次の一手：
  - 影響半径を確定（同テナント内だけか、越境するか）
  - 重要操作（承認/権限変更/エクスポート/招待）へ到達するか
  - 監査ログに principal/tenant の矛盾が出ないか（検知の余地）
  - `03_authz_*` の境界モデルに落として所見化

### 仮説B：認可sinkは見つからないが、テンプレ差分が出る
- 次の一手：
  - 表示改変/情報露出を“確実な影響”として固める
  - XSSへ接続する場合、`05_input_06_xss_*` の境界（反射/格納/DOM）で成立条件を整理

### 仮説C：差分が出ない（sinkが不明）
- 次の一手：
  - 共有性（グローバルmerge）を疑い、時間差/別エンドポイントの観測設計を組む（安全最小で）
  - source側へ戻り、別入力面（query/body/form/import/ws）での到達性を再点検する
  - 依存・設定差分（parser/merge実装）を特定して、再現条件を詰める

---

## 手を動かす検証（Labs：sinksの“観測”を再現する）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/14_prototype_pollution_sinks_authz_template/`
- Labの設計要件（手順書ではなく設計）
  - 目的：同じsourceでも、sinkの設計差で影響が変わることを観測で理解する
  - 構成：
    1) 認可ガードが “継承プロパティ” を拾う実装（悪い例）
    2) 認可ガードが “own property” のみ拾う実装（良い例）
    3) テンプレcontextを merge する実装（悪い例）
    4) テンプレcontextを allowlist で組む実装（良い例）
  - 観測：
    - レスポンス差分（403/200、表示差分）
    - サーバログ（参照したキー、参照元オブジェクト、判定結果）
    - 共有性（リクエスト跨ぎの影響があるか）

---

## コマンド/例（例示は最小限：概念のみ）
~~~~
# ここでは“攻撃文字列”ではなく、sinkの確認観点だけを書く。
# - 認可：ガードが参照するプロパティが own か inherited か
# - テンプレ：context構築が merge か allowlist か
# - 実行：危険APIの options を入力で変更できる設計か
~~~~

---

## 深掘りリンク（最大8）
- `05_input_14_prototype_pollution_01_sources（merge_parse）.md`
- `03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `03_authz_01_境界モデル（オブジェクト_ロール_テナント）.md`
- `03_authz_05_mass-assignment_モデル結合境界.md`
- `05_input_06_xss_01_反射_境界モデル.md`
- `05_input_06_xss_02_格納_境界モデル.md`
- `05_input_06_xss_03_DOM_境界モデル.md`
- `04_api_09_error_model_情報漏えい（例外_スタック）.md`
