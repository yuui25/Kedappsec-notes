## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）
- ASVS
  - 満たす/破れる点
    - パラメータ化（プレースホルダ）で「値→SQL」を遮断できているか（ただし識別子/構文は別問題）
    - 例外・エラーの統一で“差分（oracle）”を潰せているか（型キャスト/関数エラーが漏れると推定器になる）
    - 認可・テナント分離（tenant_id等の条件付与）がSQLiで崩れないか（越境混入の前提）
    - DB権限最小化（接続ユーザの権限・search_path・関数実行権限）で爆発半径を縮めているか
    - 監査（失敗頻度・遅延・エラー種別の相関）でブラインドSQLiを検知できるか
- WSTG
  - SQLiテスト（入力点のコンテキスト確定：文字列/数値/識別子/式/JSON/全文検索）
  - エラーハンドリング（型変換・キャスト・関数エラーが差分として漏れていないか）
  - 認可（SQL改変でBOLA/越境混入が起きる前提で観測点を持つ）
- PTES
  - Vulnerability Analysis：sink分類→Postgre方言差分（成立根拠）→最小差分セットで再現性確保
  - Exploitation：影響実証は必要最小限（過剰抽出や破壊的操作を避け、越境混入/読める範囲の確定に留める）
  - Reporting：根本原因を「動的組立」「ORM/raw」「型キャスト境界」「DB権限/設定境界」に分解し、修正を設計として提示
- MITRE ATT&CK
  - TA0001 Initial Access（公開アプリ入口）/ TA0009 Collection / TA0006 Credential Access（DB内に資格情報がある場合）/ TA0005 Defense Evasion（エラー統一下でブラインド化）
  - 代表：T1190 Exploit Public-Facing Application（SQLiは典型）

## タイトル
sql_injection_03_postgre（境界_プレースホルダ_型キャスト）

## 目的（この技術で到達する状態）
- PostgreSQL 方言のSQLiを、次の“境界”として説明・証跡化できる
  1) 値はプレースホルダで守れているか（守れていない箇所の特定）
  2) 守れない領域（識別子/構文/断片）を動的組立していないか（allowlist欠落の特定）
  3) PostgreSQL特有の「型キャスト/演算子/関数/JSON/全文検索」による差分（oracle）で成立根拠を固める
  4) 影響範囲（越境混入/列過剰/書込み可能性/二次注入）を最小限の検証で確定し、修正設計へ落とす
- “payload集”ではなく「意味→判断→次の一手」で迷わない（再現性と安全性を両立）

## 前提（対象・範囲・想定）
- 対象：PostgreSQL をバックエンドに持つWeb/API（検索/一覧/ソート/ページング/レポート/エクスポート/管理UI）
- 想定実装
  - ドライバ：psycopg/pgx/node-postgres/Sequelize/TypeORM/Prisma 等
  - ORM/Query Builderでも、raw断片（literal/sql fragment）や識別子の動的組立があると境界が破れる
- 本ファイルの焦点
  - PostgreSQL方言の“差分＝成立根拠”を **型キャスト（:: / CAST）** を軸に整理する
  - 併せて、JSON/全文検索/正規表現/配列など、PostgreSQLで頻出の“式コンテキスト”を境界として扱う
- 安全配慮（実務）
  - 高負荷・長時間遅延・外部通信（OOB）は原則避ける
  - 最小差分（baseline + true/false）で成立根拠を取る

## 観測ポイント（何を見ているか：入力→組立→実行→反応）

### 1) sink（注入文脈）を最初に分類する
- 値（data）
  - WHERE/INSERT/UPDATEの値（本来はバインド可能）
- 識別子（identifier）
  - ORDER BY列、SELECT列、テーブル名、スキーマ名（原則バインド不可）
- 式/断片（expression / fragment）
  - 条件式、演算子、関数呼び出し、JSONパス、全文検索クエリ、正規表現、配列演算
- 判断（次の一手）
  - 値コンテキストで差分が出る：バインド漏れ/文字列連結/ORM raw流入を疑う
  - 識別子/式で差分が出る：allowlist欠落（設計問題）として扱い、入力フィルタでの対処に寄せない

### 2) PostgreSQL方言の「差分＝成立根拠」を、4カテゴリで持つ
PostgreSQLは“語彙”よりも **型・演算・式** の差分が成立根拠として強い。

#### 2.1 型キャスト（:: / CAST）の差分（本ファイルの中核）
- PostgreSQLは `::type` が多用され、アプリ側も「入力を特定型として解釈」させる設計をしがち
- 差分として現れやすいもの
  - 入力の形を変えると「型変換エラー」「演算子不一致」「無効な入力構文」等が、安定して変化する
- 意味
  - これは “DB実行まで到達している” 可能性を上げるだけでなく、入力が **どの型として扱われているか** の推定器になる
- 判断（次の一手）
  - エラーが統一されていて見えない場合でも、Boolean/Timeに移行する際の「コンテキスト推定」に使える（文字列か数値かUUIDか、など）

#### 2.2 演算子（operator）文化の差分
- PostgreSQLは独自演算子が多く、式コンテキスト（expression）に入力が入ると差分が出やすい
  - JSON演算子、全文検索演算子、正規表現演算子、配列演算子など
- 意味
  - “値としてバインドされているはず”の入力が、演算子や式の一部として解釈されているなら、構文化の疑いが強い
- 判断
  - 入力点が検索（q/filter）なら「全文検索/正規表現/JSON検索」機能を疑い、sink分類を細分化する

#### 2.3 文字列リテラル表現（dollar-quoting等）の差分
- PostgreSQLは文字列表現が柔軟で、実装の正規化やサニタイズをすり抜けるケースがある
- 意味
  - “入力サニタイズの表層”に頼った設計は、方言差分で破られやすい
- 判断
  - 防御はエスケープの追加ではなく「そもそも構文側へ入力を入れない」「値は必ずバインド」に戻す

#### 2.4 システムカタログ/スキーマ（pg_catalog / information_schema）由来の差分
- エラーメッセージが抑制されても、挙動差（存在/権限/型）が推定器になることがある
- 意味
  - “存在オラクル”は、SQLiだけでなく認可・秘匿設計の問題にも接続する
- 判断
  - 403/404/200の違いなど、アプリの認可/例外モデルと混ざるため、差分の採用指標を固定する（件数/長さ/時間）

### 3) Oracle（差分）を「採用する指標」で固定する（ブレを潰す）
- Error oracle
  - 型変換/キャスト/演算子の差分が表面化する（ただし本来は抑制されるべき）
- Boolean oracle（推奨）
  - 件数/長さ/表示要素数の差分で確定（エラー統一でも成立する）
- Time oracle（補助）
  - 短い遅延・少回数で有意差を取る（ネットワーク揺れを前提にする）
- Second-order oracle（最優先で疑う）
  - 保存→レポート/エクスポート/管理UIで実行される（動的SQL/生成SQLが絡みやすい）
- OOB oracle
  - 原則Labsでのみ（実務範囲と影響が大きい）

### 4) プレースホルダ境界：PostgreSQLでも守れない領域を明確化する
- バインドできる：値（data）
- バインドできない/しにくい：識別子（列名/テーブル名/方向）、式断片（条件式/演算子/関数名）
- よくある破綻（黒箱で見抜く）
  - sort/fields が自由入力になっている（識別子が入力由来）
  - filter/q が“式文字列”として扱われる（断片が入力由来）
  - JSON/全文検索/正規表現で、入力を“式”として組み立てている
- 開発へ返すべき修正形
  - 値：必ずバインド
  - 識別子：allowlistでサーバ側マッピング（入力を識別子として使わない）
  - 式：生成禁止（必要なら安全なDSLに限定し、解釈器で組み立てる）

### 5) ORM/Query Builder境界：PostgreSQLで生じやすい“raw流入点”
- raw/literal/sql fragment の使用箇所（例：orderByRaw、whereRaw、sql`` など）があると、そこが主戦場になる
- PostgreSQLでは機能が強い分、以下が“動的式”になりやすい
  - JSON検索、全文検索、正規表現検索、配列条件、複合条件（AND/ORの動的生成）
- 判断（次の一手）
  - “便利機能の例外パス”に入力が流入していないかを、入力点（検索/フィルタ/ソート）から逆算して当てる

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定できる）
  - 入力がどのsink（値/識別子/式）に入っている可能性が高いか
  - PostgreSQL方言の差分（型キャスト/演算子/式）のどれが成立根拠（oracle）か
  - エラーモデルが統一されているか、差分がどこに現れるか（件数/長さ/時間）
  - 越境混入（tenant/row境界）が起き得る入口か（観測設計として）
- 断定しない（追加根拠が必要）
  - DB内部権限の断定（GRANT/ROLE等）
  - 大量データ抽出の可否（契約範囲・権限・設計に依存）
  - “PostgreSQLだ”の断定（証跡が単発なら互換/抽象化の可能性を残す）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・想定パス）
- 優先度が上がる入口（実務）
  - 検索/フィルタ/ソート/ページング（動的組立が入りやすい）
  - レポート/エクスポート（列・条件・並びの指定が増えやすい）
  - 保存検索・条件テンプレ（second-orderの温床）
  - マルチテナント境界が明確なAPI（tenant_id/org_idが暗黙に付与される設計）
- PostgreSQLで“攻め筋を選ぶ”判断
  - 型キャスト差分が強い：まず値コンテキストのバインド漏れ/文字列連結の可能性を詰める
  - 演算子/式差分が強い：JSON/全文検索/正規表現/配列の“式組立”を疑い、識別子/断片のallowlist欠落へ落とす
  - エラー統一が強い：Boolean→Time→Second-orderの順で観測点を変える（エラーを無理に引き出さない）

## 次に試すこと（仮説A/Bの分岐：最小差分で確定）

### 仮説A：値（data）でバインド漏れ/文字列連結がある
- 条件
  - 同一入力点で、入力の形を変えたときに型変換/キャスト起因の差分が安定して出る
- 次の一手
  - まず Boolean oracle（件数/長さ）で確定し、エラー差分は補助証拠に留める
  - “どの入力だけが”差分を出すかを横展開し、バインド漏れの局所性（特定条件だけraw）を探す

### 仮説B：識別子（identifier）や式断片（fragment）が動的組立されている
- 条件
  - sort/fields/filter が“仕様として自由度が高い”／入力で並びや返却列が明確に変わる
- 次の一手
  - allowlist欠落として根本原因を固定（入力フィルタでの対処に寄せない）
  - “入力値→サーバ側マッピング”がない証拠（受理範囲が広い／不正値の扱いが一貫しない）を集める

### 仮説C：エラーモデルが統一され、差分が見えにくいがSQLiが残る
- 条件
  - 例外は一定だが、結果（件数/長さ）や時間にのみ差分が出る
- 次の一手
  - 差分指標を固定し、試行回数を最小化して再現性を取る
  - second-order（保存→実行）へ観測点を移し、実行経路側で差分を確定する

## 手を動かす検証（Labs連動：設計として）
- 目的：PostgreSQLで「型キャスト差分」「式コンテキスト差分」「識別子allowlist欠落」を、観測点（HAR/ログ）で再現できるようにする
- 検証環境の設計案
  - エンドポイントを3種用意（同じUIでもよい）
    - (1) 値バインドのみ（安全）
    - (2) 値の一部を文字列連結（脆弱）
    - (3) sort/fields/filter を動的組立（識別子/断片の脆弱）
  - Postgres特有の式系（JSON/全文検索/正規表現/配列）を1つずつ“安全/危険”で比較できるようにする
- 取る証跡（最小）
  - HAR：baseline / true / false の3点
  - サーバログ：trace_id、例外分類（型変換/演算子/構文）、実行時間
  - DBログ（Labsのみ）：実行SQLがバインドか連結かの判定材料

## 例（最小限：設計の違いを理解するための形）
~~~~
# 危険：識別子（列名）を入力で組立（プレースホルダ化できない）
ORDER BY {user_sort} {user_dir}

# 安全：入力は選択肢、サーバ側で列名にマップ
sort=createdAt|name|price のように受け、
createdAt -> created_at
name     -> name
price    -> price
に変換して ORDER BY を生成（入力値を列名として使わない）
~~~~

~~~~
# 危険：フィルタを式文字列として組立（断片が混ざる）
WHERE {user_filter_fragment}

# 安全：安全なDSLに限定し、サーバ側で式を生成
例：filter=[{"field":"status","op":"eq","value":"active"}] のように受け、
field/op はallowlist、value はバインド
~~~~

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `01_topics/02_web/04_api_08_file_export_エクスポート境界（CSV_PDF）.md`
