## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 満たす/破れる点（この技術で何が起きるか）
    - 破れる：HTTPリクエストの「境界（どこまでが1リクエストか）」が、フロント（CDN/WAF/LB/Reverse Proxy）とバックエンドで不一致になり、認可・ルーティング・監査の前提が崩れる。入力（ヘッダ/ボディ）が“別リクエスト”として解釈され得るため、意図しない宛先や権限で処理される。
    - 満たす：フロント/バックでHTTPパーサの前提を揃える（TE/CLの扱い統一）、不正な組合せ（TE+CL等）を早期拒否、hop-by-hopヘッダ正規化、HTTP/2→1.1変換境界の設計、コネクション再利用（keep-alive）前提の安全策、監査ログの相関（front/backで同一request_id）を担保する。
- WSTG
  - 該当テスト観点（どの観測・検証に対応するか）
    - 入力検証（ヘッダ/ボディ）としてではなく、「中継点（proxy）を跨いだときの解釈差」を観測するテスト。特に TE/CL の優先順位、チャンク終端、メッセージ長の決定方法の差で “desync” が起きるかを、レスポンスの対応関係（request↔response）と時間差で確定する。
- PTES
  - 位置づけ
    - 脆弱性分析：対象スタック（CDN/WAF/LB/ReverseProxy/アプリ）を分解し、HTTP境界（H1/H2、TE/CL、connection reuse）を仮説化。
    - 侵害評価：成功条件は「RCE」ではなく、(1) フロントとバックで request boundary がズレる、(2) そのズレが“高価値の分岐”（認可・ルーティング・キャッシュ・ログ）に届く、を観測で固める。
- MITRE ATT&CK
  - 位置づけ（攻撃者の目的）
    - Initial Access：T1190（公開アプリの脆弱性悪用）として入口になり得る
    - Defense Evasion：フロントのWAF/認可前処理を“別リクエスト”として回避し得る
    - Collection / Credential Access：セッション混線・意図しないレスポンス取得などに繋がる設計がある場合
    - Impact：Proxy/ワーカ枯渇やキャッシュ汚染等へ波及（ただし成立条件を分解して評価）

---

## タイトル
HTTP Request Smuggling（TE.CL）：Transfer-Encoding を信じるフロントと Content-Length を信じるバックで、リクエスト境界が壊れる

---

## 目的（このファイルで到達する状態）
- TE.CL（Transfer-Encoding優先のフロント × Content-Length優先のバック）で起きる Proxy Desync を、次の形で説明・検証・報告できる。
  1) 何がズレるのか（HTTPメッセージ境界＝request boundary）
  2) どの構成で起きやすいか（CDN/WAF/LB/Reverse Proxy/アプリ、H2→H1変換など）
  3) どう観測して「成立根拠」を取るか（レスポンス対応関係、タイミング、ログ相関）
  4) 侵害評価を“現実の影響”で確定する（認可・ルーティング・キャッシュ・監査）
  5) 修正を「設計（統一/拒否/正規化）」として提示できる（単なるWAF推奨で終わらない）

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：HTTP/1.1 Request Smuggling の TE.CL パターン（proxy desync）
  - フロントが Transfer-Encoding: chunked を優先し、バックが Content-Length を優先/固定長で読むことで、1コネクション上の request boundary がズレる類型
- 扱わない（ただし接続は書く）
  - CL.TE（逆方向）は別ファイル：`05_input_18_http_request_smuggling_02_cl_te（proxy_desync）.md`
  - HTTP/2 フロント起因（H2→H1変換や疑似ヘッダ差）は別ファイル：`05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
  - 観測シグナルの体系化は別ファイル：`05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`

---

## 前提（TE.CLの成立に必要な“構成条件”）
### 1) HTTP/1.1 のコネクション再利用（keep-alive）
- request smuggling の本体は「同一TCPコネクション上で、次のリクエストの境界がズレる」こと。
- そのため、フロント→バック間でコネクションプール/keep-alive が使われる構成ほど影響が出やすい。

### 2) 中継点（プロキシ）が“前段で解釈→後段に転送”する
- CDN/WAF/LB/Reverse Proxy が、クライアントから受けたHTTPを自分のパーサで解釈し、バックへ再送する。
- このとき、前段と後段で「長さ決定ルール（TEかCLか）」が不一致だと boundary が割れる。

### 3) TE と CL の併記、あるいは TE の解釈差が存在
- 典型は TE: chunked と CL が同時に存在するリクエストを、前段と後段が異なる優先順位で扱う。

---

## 境界モデル（request boundary＝“どこまでが1リクエストか”）
### 1) 正常系：境界が一致している
- フロントもバックも同じルールで「このリクエストはここで終わり」と判断する
- request↔response の対応が崩れない

### 2) TE.CL：境界が不一致になる（本件）
- フロント：Transfer-Encoding: chunked を解釈して「ここでボディ終端」と判断
- バック：Content-Length を基に固定長で読み「まだボディが続く」と判断（または逆に“余り”が次リクエストとして扱われる）
- 結果：バックの視点では、フロントが“次のリクエスト”として送ったものが、前のリクエストの残り扱いになったり、逆に“余り”が次リクエストとして解釈される

---

## TE.CL の“成立根拠”を作る観測（最重要：薄くしない）
Request Smuggling は「成功したかどうか」が見えにくい。したがって観測を設計して “成立状態” を確定する。

### 観測1：request↔response 対応の崩れ（Desyncの本体）
- 同じコネクション上で、送った順番と返ってくるレスポンスの対応が乱れる
- 典型的な兆候（状態として書く）
  - 片方のリクエストに対するレスポンスが、もう片方のレスポンスとして返る
  - 2つ目のリクエストが “無視されたように見える”／逆に先に返る

### 観測2：時間差（タイムアウト/遅延の不連続）
- 入力長を少し変えたときに、応答時間が急に伸びる・一部だけタイムアウトする
- これはバックが “まだボディを待っている” などの状態に落ちた可能性を示す

### 観測3：エラーの層が変わる（400/502/504 など）
- フロントが弾く場合：フロント由来の 4xx（ただし製品依存）
- バックが困る場合：フロントが 502/504 を返す（バックのパース失敗・上流切断等）
- 同じ入力でも、微差でエラー種別が変わるなら、境界解釈が揺れているシグナルになり得る

### 観測4：ログ相関（可能なら最強の証拠）
- フロント（proxy）ログとバック（アプリ）ログで、同じクライアント操作に対して
  - バック側で想定外のリクエスト行/ヘッダが出る
  - request_id の数が合わない、順序が崩れる
  - 片方のリクエストが別ユーザ/別経路として処理された形跡が出る
を確認できると、成立根拠が極めて強い。

---

## TE.CL が “実害” になる分岐点（攻撃者視点＝利用の仕方）
Smuggling は「ズレた」だけでは所見として弱い。ズレが“高価値の分岐”に届くかで侵害評価を決める。

### 1) 認可・ルーティング境界に届く
- フロントで認可/制御（WAF、認証_toggle、path-based ACL）をしている場合：
  - フロントはAとして見て許可したが、バックはBとして解釈して処理した、が成立し得る。
- 影響例（状態として）
  - 本来到達できないパスがバックで処理される
  - フロントでは無害化したはずのヘッダがバックで残る（あるいは逆）

### 2) キャッシュ境界（CDN/Reverse Proxy）に届く
- request boundary の崩れが、キャッシュキー生成やレスポンス格納の前提を壊すと、
  - 意図しないレスポンスがキャッシュされる
  - ユーザ間のレスポンス混線が起こる
などに繋がり得る（ただし実害化の条件は別途厳密に評価）。

### 3) 監査・検知境界に届く
- フロントのログ上は “正しいリクエスト” に見えるが、バックでは別リクエストとして処理されると、
  - 監査の追跡性が破綻
  - インシデント調査が困難
になる。実務的には重大（再発防止策を設計に落とす必要がある）。

---

## TE.CL の検証設計（安全に、現実寄せで）
> 目的は“壊す”ことではなく、「境界がズレる状態」を最小の影響で観測し、根拠化すること。

### ステップ0：対象スタックの把握（当て勘を減らす）
- 入口が CDN/WAF/LB か、直に Reverse Proxy か
- HTTP/2 で入って HTTP/1.1 へ変換されるか（ALPN/Alt-Svcなどの観測）
- フロント→バックが keep-alive / connection pool か（proxyの挙動・ヘッダ差・タイミングで推定）

### ステップ1：同一コネクション維持ができる検証面を用意
- request smuggling は “同一コネクション” が本体。
- 従って、ツール/環境は
  - 1接続で複数リクエストを送れる
  - 送受信を生に近い形で観測できる
が必要（具体ツール名に依存せず要件で書く）。

### ステップ2：TE と CL の優先順位が揺れるかを “最小差分” で見る
- いきなり高負荷・大量送信を行わない
- 送るのは少数（1〜数回）で、観測は
  - 応答の対応関係
  - タイミング
  - ステータスの層
  - ログ相関
に集中する

### ステップ3：成立したら“実害の分岐”へ最短で寄せる
- 目的別に枝分かれする（後述：仮説A/B）
- ただし、第三者影響（キャッシュ汚染、他ユーザ混線）を伴う評価は、契約/VDP条件と安全設計（隔離環境）を満たすまで実施しない。

---

## 手を動かす検証（生リクエスト例：例示は最小限、観測点を主に）
> 下は“形”の例。ここから先の過剰なペイロード列挙は行わず、観測で成立を詰める。

~~~~
# TE.CL で見るべきポイント（形）
# - Transfer-Encoding: chunked と Content-Length が同時に存在する
# - フロントは chunked 終端で「終わり」と見る可能性
# - バックは Content-Length で「まだ続く」と見る可能性
# - 結果として、同一コネクション上の次リクエスト境界がズレる

POST /endpoint HTTP/1.1
Host: example
Content-Length: <CL_value>
Transfer-Encoding: chunked
Connection: keep-alive

<chunked-body ... 0\r\n\r\n>
<ここに次リクエスト相当が“混ざる/余る”状態を作ると desync の候補になる>

# 観測
# - 返ってきたレスポンスがどのリクエストに対応しているか
# - 片方がタイムアウト/遅延するか
# - 400/502/504 の層がどう変わるか
~~~~

---

## 観測ポイント（証跡として残す：proxy/pcap/log）
### 1) ネットワーク（pcap推奨：可能なら）
- クライアント→フロントのTCPストリーム
- 再送/切断のタイミング（RST/FIN）
- レスポンスの順序（HTTP/1.1のパイプライン的挙動が見えるか）

### 2) アプリ観測（HAR/レスポンス差分）
- 送った2リクエストの順序と、返ってきた2レスポンスの順序・内容が一致するか
- ステータスが微差で変動するか（境界揺れのシグナル）

### 3) フロントログ（Reverse Proxy / WAF / LB）
- 1リクエストとして記録されているか、2リクエストとして記録されているか
- request_id の発番がどうなるか（相関キー）

### 4) バックログ（アプリ/アプリサーバ）
- 想定外のリクエスト行・ヘッダ・ボディの形跡
- 同一クライアント操作で、想定外のリクエストが追加で処理されていないか

---

## 結果の意味（状態として整理：報告に直結）
### 状態S1：フロントが早期拒否（境界が守られている）
- TE+CL のような曖昧入力をフロントが弾き、バックへ到達しない
- 次の一手：別経路（H2→H1変換、別ホスト、別proxy）で“どこが弾いているか”を特定し、設計として固定できているか確認

### 状態S2：境界揺れの兆候（desync疑い）
- 400/502/504、遅延の不連続、レスポンス対応の乱れなどが観測される
- 次の一手：ログ相関で「フロントとバックの解釈差」を確定（可能なら最優先）
  - 確定できれば所見化の芯になる（“推測”で終わらせない）

### 状態S3：desync確定（request↔response対応が崩れる）
- 同一コネクション上で対応関係が崩れ、境界が壊れたことが観測できる
- 次の一手：実害の分岐（認可/ルーティング/キャッシュ/監査）に最短で寄せ、影響半径を確定する

---

## 次に試すこと（仮説A/B：現実寄せの分岐）
### 仮説A：WAF/フロント制御を“すり抜けてバックが処理”している兆候がある
- 次の一手
  - バックで到達してはいけないパス/操作（管理系・内部系・別Host想定）への処理痕跡をログで確認
  - 認可境界（03_authz）に接続し、「どのガードがフロント依存だったか」を特定
  - 監査ログの破綻（フロントの記録とバックの実処理の不一致）を根拠として提示する

### 仮説B：desyncは起きるが、実害は “DoS/劣化” 方向に見える
- 次の一手
  - 影響は「CPU」ではなく「ワーカ/コネクション枯渇」になりやすい（少数でも詰まる構成がある）
  - 観測シグナルを `05_input_18_http_request_smuggling_04_observable_signals` の枠組みで整理し、
    - どの層で詰まるか（front/back）
    - どの閾値で発生するか（安全な範囲で）
    を確定して、修正要件（拒否/正規化/タイムアウト/connection管理）へ落とす

---

## 防御（設計要件として：実装依存の小技に寄せない）
### 1) TE+CL を許さない（曖昧性の排除）
- 受信点（最前段）で、TEとCLの併記や異常形式を拒否する（統一ルール）
- 中継点が複数あるなら、“どこで拒否するか”を設計として固定（責務分界）

### 2) フロント/バックでHTTPパーサ前提を揃える
- どの層がどのRFC解釈で動くかを明示し、バージョン/設定を統一
- H2→H1 変換があるなら、その変換境界の正規化要件（ヘッダ/疑似ヘッダ、長さ決定）を明文化

### 3) コネクション再利用の安全策
- バックへのコネクションプールで desync が起きたときの隔離（該当コネクション破棄）
- 例外発生時に keep-alive を維持しない（中途半端な状態を次へ持ち越さない）

### 4) 監査・相関
- フロントとバックで request_id を受け渡し、順序・件数の不一致が検知できるようにする
- “フロントで見えたものだけ”を監査の真実にしない（境界破壊の前提を置く）

---

## 手を動かす検証（Labs：設計として書く）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/18_http_request_smuggling_te_cl_proxy_desync/`
- Lab設計要件（手順書ではなく設計）
  - 構成：
    - フロント：TEを優先する設定のReverse Proxy（または等価挙動）
    - バック：CLを優先するHTTPサーバ（または等価挙動）
    - その間は keep-alive/pool を有効化し、同一コネクション再利用を再現する
  - 観測点：
    - pcap（クライアント→フロント、フロント→バック）
    - フロントアクセスログ（request_id、upstream_response_time）
    - バックアクセスログ（リクエスト行、読み取りバイト、タイムアウト）
  - 成功条件（学習目的）：
    - request↔response 対応が崩れる状態を、少数リクエストで再現し、境界モデルを説明できる

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# ここでの主目的は「成立根拠（desync）」の観測。
# - 送信：同一コネクションで複数リクエストを扱える手段
# - 観測：レスポンス対応関係、遅延の不連続、エラー層、ログ相関
# - 判断：フロント/バックのどこで解釈差が出ているか
~~~~

---

## 深掘りリンク（最大8）
- `05_input_18_http_request_smuggling_02_cl_te（proxy_desync）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `06_config_03_セキュリティヘッダ（CSP_HSTS_Frame_Referrer）.md`
- `04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
