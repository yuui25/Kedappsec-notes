## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：認証が成立しても、**その後の「権限決定・権限伝播」**で境界が崩れると、IDOR/BOLA/BFLAのような典型だけでなく、(1) 不正なclaimsを“権限”として採用、(2) フロント/バック/ジョブで権限解釈がズレる、(3) テナント境界がclaimsに乗らず混線、(4) 失効/権限変更が反映されず“過去の権限”で動く、などの形で **認可が形骸化**する。
  - 満たす：AuthN（本人確認）で得た識別子を **一貫したプリンシパル**へ正規化し、AuthZ（権限判定）に使うデータ（roles/scopes/entitlements/tenant等）を **信頼できるソース**から供給し、サービス境界を跨いでも同じ意味で解釈されるようにする。トークン検証（iss/aud/exp等）・権限同期（変更/失効）・権限伝播（BFF→API→ジョブ）を「仕様」として固定する。
- WSTG
  - 観点：認証テストと認可テストの間にある“接続部”を評価する。
    - どのトークン/claimsが、どの境界（フロント/バック/キュー/WS）で、何の判断（ロール/テナント/オブジェクトスコープ）に使われているかを観測で確定する。
    - “JWTを改変して通るか”に寄せず、(1) 検証が厳密か、(2) claims→内部権限へのマッピングが安定か、(3) 伝播時に欠落/置換/再解釈がないか、を証跡で示す。
- PTES
  - 位置づけ：脆弱性分析〜侵害評価の「接続技術」。
    - Reconで得た認証方式（Cookie/Session/JWT/OIDC/SAML）から、権限判断点（Policy/Guard/Resolver/Service）までを繋ぎ、どこで境界が切り替わるか（権限伝播点）をモデル化してから検証する。
- MITRE ATT&CK
  - 有効アカウントの悪用、権限昇格、横展開（サービス間）に接続し得るが、本ファイルは“成立条件の観測と固定”を主眼とする。
  - 特に、認証後の権限データ（claims/ヘッダ/内部トークン）がサービス境界を越えて伝播する構造は、攻撃者にとって「一度通れば他も通る」面になるため、境界設計として扱う。

---

## タイトル
AuthN→AuthZ 接続（claims / 権限伝播）：本人確認の結果を“権限判断”へ安全に接続し、サービス境界を跨いでも意味が崩れない状態にする

---

## 目的（このファイルで到達する状態）
- 認証（AuthN）の成果物（session / token / claims）を、認可（AuthZ）の判断へ接続する「接続部」を、境界として説明できる。
  1) claimsの“出どころ”と“信頼できる範囲”を分類できる（IdP発行 / 自社発行 / 中継付与 / クライアント自己申告）
  2) claims→内部権限（role/permission/tenant/scope）へのマッピングを、実装パターン別に整理できる
  3) 権限伝播（Browser→BFF→API→Worker/Job→Audit）で、何が落ちる/変わると危険かを観測で確定できる
  4) 失効・権限変更・step-up（再認証）といった“時間要素”を、権限境界として扱える
  5) 次の一手を仮説A/Bで選べる（「検証が弱い」ならAuthN寄りに、「伝播が壊れている」ならAPI/ジョブ寄りに）

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：AuthN→AuthZ の接続点（claims / 権限伝播 / マッピング / 失効反映）
  - OIDC（ID token / Access token）、SAML assertion、セッション（Cookie）、内部JWT、API Gateway付与ヘッダ、ジョブ/キューの権限文脈
  - multi-tenant / RBAC / ABAC における「境界情報（tenant/org、role、scope、object scope）」の運び方
- 扱わない（接続先）
  - 認証方式そのものの深掘り：`02_authn_0x_*.md`
  - 認可の典型（IDOR/BOLA/BFLA）の詳細：`03_authz_0x_*.md`
  - API連携の詳細（非同期/権限伝播の一般形）：`04_api_01_権限伝播モデル（フロント_バックエンド_ジョブ）.md`
  - トークン設計の細部：`02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`

---

## 境界モデル：AuthN→AuthZ は「プリンシパル決定」と「権限データ供給」の2段で壊れる
### 1) 3つの境界（資産 / 信頼 / 権限）
- 資産境界（どこまでが対象か）
  - ブラウザ、BFF（Backend-for-Frontend）、API Gateway、各マイクロサービス、Worker/Job、監査ログ/権限DB、IdP
- 信頼境界（どこから先が第三者/外部連携か）
  - IdP（外部/社内）→ RP（自社）への主張（claims/assertion）
  - Gateway/Proxyが付与する「認証済みヘッダ」や「内部トークン」
  - メッセージング基盤（Queue/Topic）やWebSocket中継が“誰の権限文脈”を運ぶか
- 権限境界（どこで権限が切替/伝播するか）
  - “ログインした”と“管理操作できる”の境界
  - テナント/組織境界（org_id/tenant_id）を跨げるかどうか
  - step-up（再認証/MFA）で許される操作が増える境界
  - 権限変更（降格/解除）と、既存セッション/トークンの残存の境界（時間境界）

### 2) AuthN→AuthZ 接続の最小モデル（観測と判断のため）
- 接続は大きく2パターンに分かれる（混在が最も危険になりやすい）。
  1) トークン中心（claimsが権限の“主”）
     - Access token（JWT等）の roles/scopes/tenant を、そのままPolicy/Guardで判定する
  2) サーバ状態中心（claimsは“識別子”で、権限はDB/Policy側が主）
     - トークンはsub等でユーザを特定し、権限は都度DB/Policyから引く（または権限版数で同期）

この2つがサービスごとに混在すると「Aでは通るがBでは通らない」「降格が反映されない」など、境界が壊れた状態が生まれる。

---

## claims の“出どころ”と信頼ランク（まずここを誤ると全て崩れる）
### ランクS：検証済み・発行主体が明確（ただし用途制約あり）
- IdP発行の Access token / SAML assertion（署名検証・aud/iss等検証済み）
- 自社発行の内部トークン（署名検証・aud固定・有効期限短・用途限定）

### ランクA：検証済みだが「権限の根拠」には直結させない方が安全なもの
- OIDC ID token の多くのclaims（主にログインUI向け、API権限の根拠にするとズレが出やすい）
- 表示名・メール・プロフィール系（同一性・所属の根拠としては弱い）

### ランクB：中継が付与する“認証済みヘッダ”（境界設計が要）
- 例：`X-User`, `X-Email`, `X-Groups`, `X-Tenant` など
- これは「そのヘッダを付与できる主体」を信頼しているだけ。
  - 外部から注入できる経路があると即座に崩れる（Proxy境界での除去/固定が必須）

### ランクC：クライアント自己申告・UI状態
- ローカルストレージのフラグ、URLパラメータ、JS変数など
- 役割：UIの見た目程度。AuthZ根拠にしてはいけない。

---

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
> “どのclaimsが使われているか”を、リクエスト/レスポンスの1点だけで判断しない。  
> **Hop（経路）ごとに「入力→正規化→判定→伝播」を見る**。

### 1) ブラウザ→BFF（フロント境界）
- 観測対象
  - Cookie（セッション） / Authorization（Bearer） / CSRF系（あれば）
  - “ログイン後に呼ばれるAPI”の呼び出しパターン（BFF経由か直APIか）
- 境界の意味
  - ブラウザに置かれたトークンが「API権限の根拠」になっていないか（ID token誤用の兆候）
  - BFFが“権限判定”をやっているのか、単に中継しているだけか

### 2) BFF→API（権限伝播の主戦場）
- 観測対象（最重要）
  - どのヘッダ/トークンでユーザ文脈を渡しているか
    - Bearer（外部トークンをそのまま）
    - 内部JWTへの変換（token exchange / セッション→内部トークン）
    - 認証済みヘッダ（X-User等）
  - claimsの中身（例：sub、tenant/org、roles/scopes、amr/acr、auth_time）
- 境界の意味
  - “権限の根拠”がどこにあるか（token内か、DB/Policyか）
  - BFFでの正規化（principal/tenant決定）が一貫しているか

### 3) API→下流サービス（マイクロサービス境界）
- 観測対象
  - サービス間呼び出しで、ユーザ文脈をどう扱うか
    - ユーザのまま伝播（on-behalf-of）
    - サービスアカウントに切替（代理実行）＋監査で誰の要求かを別に運ぶ
  - 権限判定点（Guard/Policy middleware/Resolver/SQLフィルタ）
- 境界の意味
  - 代理実行に切り替わると、**“誰の権限で動いたか”の監査境界**が重要になる
  - 下流でclaimsが欠落すると、上流で通った権限が下流で“デフォルト許可/デフォルト拒否”になり得る

### 4) API→Async Job / Queue（時間境界・権限文脈の断絶点）
- 観測対象
  - ジョブ投入時に、どの情報を積むか（user_id / tenant_id / permission snapshot / request_id）
  - 実行時に、権限を再評価するか（現在の権限）／投入時のスナップショットを使うか
- 境界の意味
  - “投入時は権限あり、実行時は権限なし” のズレ（逆も）をどう扱うかが設計として問われる
  - 失効/降格を反映する要件があるなら、ジョブは実行時再評価が必要になりやすい

### 5) 監査ログ（証跡境界）
- 観測対象
  - principal（誰が） / tenant（どこで） / action（何を） / object（どれに） / decision（許可/拒否） / reason（ポリシー） / request_id（相関）
- 境界の意味
  - “権限が壊れた”を後から断定するには、判定点のログが必要。
  - 逆にログがないと、再現性が低く「推測」になり報告品質が落ちる。

---

## 状態の切り分け（結果の意味）：AuthN→AuthZ がどの型で壊れているか
### 状態A：サーバ状態中心で一貫（比較的堅牢）
- 特徴
  - トークンは識別子（sub等）に限定し、権限はDB/Policyが主
  - 失効/権限変更が反映されやすい
- 言えること
  - 問題は「IDOR/BOLA/BFLAの実装」寄りになりやすい（境界モデルの精度が重要）

### 状態B：トークン中心で“claims=権限”が直結（設計要件が厳しい）
- 特徴
  - roles/scopes/tenant を token claims から直接判定
- 言えること
  - token検証が厳密で、発行/失効/変更の同期が仕様化されていれば成立する
  - 同期が曖昧だと「降格が効かない」「古い権限で動く」が起きやすい

### 状態C：混在（最も事故が出やすい）
- 例
  - AサービスはDB参照、Bサービスはtoken roles参照
  - フロントはtoken rolesでUIを出し分け、APIはDBで判定（または逆）
- 言えること
  - “通る/通らない”の揺れが増え、例外経路が生まれやすい
  - テナント境界の混線や、管理操作の抜け道が出やすい（伝播点を潰す必要）

### 状態D：ヘッダ付与モデル（信頼境界が一点に集中）
- 特徴
  - Gateway/Proxyが `X-User` 等を付与し、下流はそれを信じる
- 言えること
  - 外部からそのヘッダを注入できる経路があると即崩壊する
  - “注入不可”を、プロキシ境界での削除・内部ネットワーク・mTLS等で証明できるかが鍵

### 状態E：非同期/バッチで権限文脈が断絶
- 特徴
  - ジョブはサービス権限で動き、ユーザの権限境界が曖昧
- 言えること
  - 監査境界（誰の依頼で何が起きたか）と、実行時の再評価要件が焦点になる

---

## 攻撃者視点での利用（ただし“成立根拠”ベースで評価する）
> ここは攻撃寄りに整理するが、具体手順の過度な提示は避け、評価軸（何が起きると危険か）を固定する。

### 1) claims の誤用（用途違いのトークンを権限根拠にする）
- 観測シグナル
  - APIがID tokenを受け入れている、aud/issが曖昧、用途が混ざっている
- 危険性
  - “ログインに使う主張”が“API権限”に転用され、境界が崩れやすい

### 2) 権限変更/失効が反映されない（時間境界の破綻）
- 観測シグナル
  - 降格後も操作が可能、古いトークンで継続できる、ジョブが過去権限で実行される
- 危険性
  - 運用上の権限管理が無意味になり、内部不正・退職者・委託の境界が崩れる

### 3) 伝播の欠落/置換（BFF→API→Job で意味が変わる）
- 観測シグナル
  - フロントではtenantが見えているがAPIでは欠落、Jobでは固定値、サービス間でrole表現が違う
- 危険性
  - テナント跨ぎ、管理操作の迂回、監査不能（誰の操作か不明）に繋がる

### 4) “認証済みヘッダ”の注入可能性（信頼境界の破壊）
- 観測シグナル
  - 外部から到達できる経路で `X-User` 等がそのまま下流に届く、除去されていない
- 危険性
  - サービス全体が“ヘッダ1本”でなりすまし可能になる（影響半径が大きい）

---

## 次に試すこと（仮説A/B：観測結果で分岐して迷わない）
### 仮説A：トークン検証が厳密で、権限根拠が一貫している
- 次の一手（AuthZ側へ寄せる）
  - 1) 権限判定点（Policy/Guard/Resolver）を特定し、どのリソース境界で判定しているかを洗う
  - 2) テナント境界（org/tenant）とオブジェクト境界（resource owner）の両方で、判定が揃っているかを見る
  - 3) 非同期/バッチの“代理実行”で、監査境界が成立しているかを確認する

### 仮説B：トークン検証が曖昧、または用途が混ざっている（AuthN寄りの問題）
- 次の一手（接続部の是正に直結）
  - 1) 受け入れているトークン種別と用途を整理（ID token / Access token / Session / Internal token）
  - 2) iss/aud/exp/署名検証、kid/鍵管理、clock skew、nonce/state等（方式に応じた要件）を“仕様”として固定できるか確認
  - 3) “認証済みヘッダ”モデルの場合は、注入不可を担保する境界（除去/固定/mTLS/内部限定）を優先的に見る

### 仮説C：混在しており、サービスごとに権限の意味が違う
- 次の一手（伝播・マッピングの統一）
  - 1) canonical principal（唯一のユーザ識別子）を決め、sub/email/idのどれが主かを固定
  - 2) canonical authorization source（DB/Policy vs token claims）を決め、混在を減らす
  - 3) tenant/role/scope の表現を統一し、サービス間の変換点を減らす（変換するなら変換規則を仕様化）

### 仮説D：非同期ジョブで権限文脈が断絶している
- 次の一手（時間境界の設計へ）
  - 1) “投入時スナップショット”と“実行時再評価”のどちらが要件か決める（重要操作ほど再評価寄り）
  - 2) request_id と principal/tenant をログ相関できる形で残す（監査境界）
  - 3) ジョブに必要な最小権限を定義し、サービス権限の過大付与を避ける（最小権限）

---

## 修正要件（設計に落とす：実務で揉めないための言い方）
### 1) 接続の仕様化（“どれを権限根拠にするか”を決める）
- 権限根拠を1つに寄せる
  - 可能なら：サーバ状態（Policy/DB）中心にし、トークンは識別子と最小メタ（iat/auth_time等）に限定
  - トークン中心にするなら：発行/失効/権限変更の同期要件（短寿命・再発行・失効戦略）まで仕様化する

### 2) 権限伝播の最小化（サービス境界を越えるデータは少なく）
- 伝播するのは「誰が（principal）」「どこで（tenant）」「何をしたい（action）」「相関（request_id）」が基本
- roles/permissions を全サービスへ配るのではなく、ポリシーサービス/権限サービスへ寄せる（または署名付き内部トークンに限定）

### 3) ヘッダ付与モデルの安全化（使うなら“注入不可”を構造で担保）
- 外部入力を境界で必ず落とす（外部→内部で同名ヘッダを除去）
- 内部通信を限定する（ネットワーク境界、mTLS、認証済み経路のみで付与）
- 監査ログに「付与した主体（Gateway）」を残す（責任境界）

### 4) 時間境界（失効・権限変更・step-up）を要件に含める
- 権限変更がどの範囲でいつ反映されるべきか（即時/次回ログイン/最大N分）を明示
- step-up の証跡（amr/acr/auth_time 等）を、重要操作の判定に使うなら
  - その値がどこで作られ、どこで検証されるか（BFF/API/Policy）を固定する

---

## 04_labs（AuthN→AuthZ 接続を“手で回して”理解する設計）
- 追加候補Lab（例）
  - `04_labs/02_web/10_authn_to_authz_01_token_vs_db_authority/`
  - `04_labs/02_web/10_authn_to_authz_02_gateway_asserted_headers_boundary/`
  - `04_labs/02_web/10_authn_to_authz_03_async_job_context_and_revocation/`
- Lab設計（手順書ではなく設計）
  - 構成例：
    - IdP（OIDCの簡易発行 or モック）→ BFF → API（RBAC/ABAC）→ Worker（Queue）
    - 権限DB（role/tenant変更が可能）＋ 監査ログ（decisionログ）
  - 観測点：
    - Hopごとの principal/tenant/role の形（ヘッダ/トークン/DB参照）
    - 権限変更（降格/解除）後の反映（即時/遅延/不変）
    - 非同期ジョブが“誰の依頼”で動いたか（相関キー）
  - 成功条件：
    - 「どの層で権限が決まり、どの層で伝播し、どこで意味が変わると危険か」を、ログとリクエストで説明できる

---

## コマンド/例（例示は最小限：観測・判断を優先）
~~~~
# 目的は「claimsを眺める」ではなく、
# 1) どのHopで（BFF/API/Job）、
# 2) どのデータ（token/headers/db）を根拠に、
# 3) どの判定（tenant/role/object scope）をしているか
# を“差分”で確定すること。

# 記録の最低セット（例）：
# - リクエスト：Authorization/Cookie/主要ヘッダ
# - トークン：iss/aud/exp/sub/tenant/roles/scopes（見える範囲）
# - 判定ログ：principal/tenant/action/object/decision/reason/request_id
~~~~

---

## 深掘りリンク（最大8）
- `01_topics/02_web/02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`
- `01_topics/02_web/02_authn_04_sso_oidc_flow観測（state_nonce_code_PKCE）.md`
- `01_topics/02_web/02_authn_05_sso_saml_flow観測（assertion_audience_recipient）.md`
- `01_topics/02_web/02_authn_16_step-up_再認証境界（重要操作_再確認）.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/03_authz_04_rbac_abac_判定点（policy_engine）.md`
- `01_topics/02_web/03_authz_03_multi-tenant_分離（org_id_tenant_id）.md`
- `01_topics/02_web/04_api_01_権限伝播モデル（フロント_バックエンド_ジョブ）.md`
