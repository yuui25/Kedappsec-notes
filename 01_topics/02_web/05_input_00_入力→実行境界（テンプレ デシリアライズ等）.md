<<<BEGIN>>>
# 05_input_入力→実行境界（テンプレ デシリアライズ等）.md

（先頭要約：ガイドライン対応の位置づけ）
- ASVS：入力が「どこまで到達し」「どこで解釈/実行に変わるか」を境界として扱い、満たす/破れる点を説明できる状態にする
- WSTG：Input Validation / Injection 系の観点を、入力点→解釈点→実行点の“到達性”として整理し、検証順を作る
- PTES：Vulnerability Analysis で“実行境界”に到達する入力を最短で特定し、Exploitation の成立条件を明確化する
- ATT&CK：Execution / Persistence 等に直結し得る「入力→実行」導線を、攻撃者の目的と境界で説明できる状態にする

## 目的（この技術で到達する状態）
- 「入力がある＝脆弱性」ではなく、入力が **どこで解釈され、どこで実行に変わるか（実行境界）** を観測し、検証の当たり所を自分で決められる。
- 入力点を“フォーム”に限定せず、API/ヘッダ/ファイル/URL/GraphQL/テンプレ/ログ/キュー等を含め、**到達性（どこまで届くか）** を軸に整理できる。
- 各入力について、次の3点を最低限で説明できる。
  - 入力点（どこから入る）
  - 解釈点（どこで意味を持つ）
  - 実行点（どこで危険な操作に変わる）
- ツールや典型ペイロードの列挙ではなく、「観測→意味→次の一手」を中心に、再現可能な検証設計を作れる。

## 前提（対象・範囲・想定）
- 対象：許可範囲のWeb/API（必要なら検証環境）に限定。
- 想定：
  - SPA+API、テンプレエンジン、ジョブ/キュー、ファイルアップロード、ログ集約、外部連携（SaaS/API）
  - “入力”は表示（HTML）だけでなく、バックエンドの内部処理（テンプレ/デシリアライズ/クエリ生成/コマンド組立）に使われる
- 依存（前段の接続）：
  - `01_topics/02_web/04_api_権限伝播・入力・バックエンド連携.md`
  - `01_topics/02_web/06_config_設定・運用境界（CORS ヘッダ Secrets）.md`（設定が到達性を変えることがある）
- 観測基盤（推奨）：
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap har log）.md`
- やらないこと：
  - ペイロード集の羅列（「これ入れると出ます」だけは不可）
  - “落とし穴”章は作らない

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
### 1) 入力点（Entry）の洗い出し：フォーム以外が主戦場
- URL：path/query/fragment
- Header：Host/Origin/Referer/User-Agent、X-*、Content-Type 等
- Body：JSON/Form/XML、GraphQL variables
- Cookie：状態を左右する値
- ファイル：アップロード、ダウンロード、メタデータ（名前/拡張子/Content-Type）
- 非同期：キュー、WebHook受信、バッチ、通知
- 外部連携：SaaS/外部APIから“戻ってくる”入力（自システムが受け取る側になる）

### 2) 解釈点（Interpretation）：入力が“意味”を持つ場所
- パーサ：JSON/XML/YAML/CSV
- テンプレ：サーバサイドテンプレ、メールテンプレ、PDF生成、レポート生成
- クエリ生成：SQL/NoSQL/検索クエリ/GraphQL resolver
- パス解釈：ファイルパス/URL/リダイレクト先
- ログ：ログフォーマット、ビューア、SIEM/可視化

### 3) 実行点（Execution Boundary）：危険操作へ変わる場所
- コマンド実行/シェル呼び出し
- テンプレ実行（評価）
- デシリアライズ（任意オブジェクト生成/コードパス）
- スクリプト実行（JS/式言語等）
- SSRF（外部へリクエストを飛ばす）
- ファイル操作（読み/書き/上書き/展開）

### 4) “到達性”の取り方（入力→実行へ届くかを最短で測る）
- まずは “反射/保存/処理結果” のどれかを確認する（見える出力があるか）
  - レスポンスに反映（反射）
  - 後から別画面/一覧/通知で出る（保存）
  - 処理結果の差分（エラー/時間/件数/状態）で推定（非表示処理）
- 次に “どの境界で変わるか” を差分で確定する
  - 入力の場所（URL/Body/Header/ファイル）
  - 文字種/サイズ/エンコード/構造（例：JSONの型、配列/オブジェクト）
  - コンテキスト（HTML/属性/JS/URL/SQL/テンプレ等）

### 5) “実行境界に近い入力”の見分け方（観測での優先度）
- 文字列が「別の構文」に組み込まれている兆候
  - 例：クエリ文字列、テンプレのプレースホルダ、コマンド引数、URL生成
- エラーが“構文”を示す（パーサ/テンプレ/クエリ）
- 処理時間が極端に変わる（外部呼び出し/重い評価/検索）
- 出力が正規化される（パーサが介在している兆候）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定できる）
  - 入力点→解釈点の導線（どこで意味を持つか）
  - どの条件差（型/構造/エンコード/コンテキスト）で挙動が変わるか
  - “実行境界に近い”可能性（エラー/時間/状態差からの推定）
- 推定（追加観測で強くなる）
  - 実行点の種類（テンプレ/クエリ/デシリアライズ/外部呼び出し等）
  - 影響の広がり（保存される範囲、参照される箇所、外部連携の範囲）
- 言えない（この段階の限界）
  - 具体的な脆弱性の断定（成立条件の追加観測が必要）
  - 内部実装の確定（ソース/ログがないと推定に留まる）
  - 影響の最大化（許可範囲と安全性の制約がある）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
### 1) 優先度の付け方（実行境界に近い順）
1) 外部呼び出し（SSRF相当）になり得る入力（URL/画像取込/連携設定 等）
2) クエリ生成に入りそうな入力（検索、フィルタ、レポート、管理一覧）
3) テンプレ/通知/帳票に入る入力（メール、PDF、メッセージ）
4) ファイル処理に入る入力（アップロード、展開、メタデータ）
5) デシリアライズ/構造入力が濃い入力（JSONの深い構造、型が効く、オブジェクト受け渡し）

### 2) 攻め筋（“到達性”を測ってから成立条件へ）
- 反射がある → コンテキスト（HTML/JS/URL/属性等）を確定し、実行境界の種類を絞る
- 保存がある → 参照面（どこで表示/利用されるか）を特定し、境界の広がりを絞る
- 反射/保存が見えない → エラー/時間/状態差で解釈点を推定し、次の観測を変える

### 3) 次の仮説に繋げる
- 入力がAPIの権限境界と絡む場合：`03_authz` と合わせて “誰がどの入力を使えるか” を優先する
- 設定が到達性を変える場合：`06_config` へ（CORS/ヘッダ/Secrets/連携設定）

## 次に試すこと（仮説A/Bの分岐と検証）
### 共通の最小セット（まず1入力でやり切る）
- “代表入力”を1つだけ選ぶ（検索、コメント、アップロード、連携設定など）
- 観測点を固定する
  - HAR/Proxyログ（入力がどこに入ったか）
  - 結果観測（反射/保存/状態差のどれで見えるか）
  - 状態確認（再取得/一覧/履歴/通知）

### 仮説A：入力がテンプレに入っている（通知/帳票/画面生成）
- 検証（A/B）
  - A：通常入力で生成結果を観測（どこに出るか）
  - B：文字種/構造だけ変えて、エラーや出力の変化を観測（解釈点の推定）
- 期待する観測
  - 解釈点（テンプレの存在）が“状態”で説明でき、次の深掘り（テンプレ評価）へ繋がる

### 仮説B：入力がクエリ生成に入っている（検索/フィルタ/レポート）
- 検証（A/B）
  - A：単純入力で結果件数/エラー/時間を記録
  - B：構造/エンコード/型（数値/文字/配列）を変えて差分を取る
- 期待する観測
  - “どの条件で挙動が変わるか”が説明でき、解釈点（SQL/NoSQL/検索）を絞れる

### 仮説C：入力が外部呼び出し（SSRF相当）に繋がっている
- 検証（A/B）
  - A：正規のURL等で処理が成功する条件を観測
  - B：入力形式だけ変えて失敗の型（タイムアウト/到達不可/拒否）を観測し、外部呼び出しの存在を推定
- 期待する観測
  - 外部呼び出しの“到達性”と“成立条件”が説明でき、次の観測点（ログ/ネットワーク）を決められる

### 例示（最小の観測：コマンドは補助）
~~~~
# 例：APIへの入力が「どこに入るか」を観測する入口（概念例）
curl -i -H "Authorization: Bearer <TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"q":"test"}' \
  "https://example.com/api/search"
~~~~
- 主役は「入力点の特定」と「結果の意味（件数/エラー/時間/状態差）」であり、ペイロード列挙ではない

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回）
- ASVS：
  - 入力の扱い（検証/正規化/エンコード/実行境界）を“境界”として整理し、満たす/破れる点を観測で説明できる状態にする
- WSTG：
  - Input Validation / Injection の観点を、入力点→解釈点→実行点（到達性）として構造化し、検証順（A/B）へ落とす
  - 該当が薄い場合の接続：このファイルは「他の脆弱性検証の前提（入力がどこへ届くか）」を支える
- PTES：
  - Vulnerability Analysis：実行境界に近い入力を絞り、検証優先度を作る
  - Exploitation：成立条件が見えたら、最小の再現手順と状態確認まで揃える
- MITRE ATT&CK：
  - 戦術：Execution（入力→実行の導線）、Persistence（テンプレ/設定/ジョブ等に保存される場合）、Discovery（到達性の把握）等
  - 技術名の貼り付けではなく「攻撃者の目的に対して、どの入力が実行境界に繋がるか」を説明できる状態にする

## 参考（必要最小限）
- `01_topics/02_web/04_api_権限伝播・入力・バックエンド連携.md`
- `01_topics/02_web/06_config_設定・運用境界（CORS ヘッダ Secrets）.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap har log）.md`
- `02_playbooks/05_api_権限伝播→検証観点チェック.md`

<<<END>>>
