## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）

- ASVS
  - 入力→実行境界：ユーザ入力が **APOCプロシージャ（拡張機能）** の引数として到達し、外部到達（HTTP/ファイル等）や動的実行（Cypher実行）へ繋がらない設計か
  - 設計：APOCを使用する場合、利用可能プロシージャの **allowlist（最小権限）** と、引数の型拘束・上限・スキーマを実装で強制しているか
  - 認可境界：DBユーザ権限（Neo4jロール）と、アプリユーザ権限（tenant/role）を混同していないか（権限伝播の誤り）
  - 例外/エラー：プロシージャの失敗が詳細エラー（スタック、設定、URL等）を返さないか（oracle化）
  - 可用性：APOCは高コスト処理（ロード/変換/探索）を含み得るため、レート・タイムアウト・上限の設計が必要
- WSTG
  - Injection：Cypher Injectionの延長として、プロシージャ呼び出しが「実行境界（機能呼び出し）」になっていないかを検証
  - SSRF/XXE/ファイル系：APOCの入出力機能は、入力→外部到達（URL）/ローカル資源（file）へ繋がるため、WSTGの該当観点へ接続する
- PTES
  - Vulnerability Analysis：APOC利用箇所（CSVインポート、外部参照、動的Cypher、変換）を特定し、入力点→引数→効果（到達性/実行）の差分で成立根拠を取る
  - Exploitation：影響実証は最小限（到達性/越境混入/情報露出の根拠まで）。外部到達や高負荷は避ける
  - Reporting：原因を「APOC露出」「許可プロシージャ過多」「引数検証不足」「権限伝播不備」「エラーモデル不備」「運用設定不備」に分解して提示
- MITRE ATT&CK
  - TA0001 Initial Access / TA0009 Collection / TA0008 Lateral Movement（外部到達や内部資源アクセスがあれば）/ TA0005 Defense Evasion
  - 代表：T1190（公開アプリ入口）、SSRF的な到達があれば内部探索へ波及

---

## タイトル
NoSQL（Neo4j）：APOC procedure_security（プロシージャ露出・外部到達・動的実行境界）

## 目的（この技術で到達する状態）
- Neo4j の APOC（Awesome Procedures On Cypher）を「便利な拡張」ではなく、
  - **入力→機能呼び出し（procedure）**
  - **入力→外部到達（URL）/資源アクセス（file）**
  - **入力→動的Cypher実行**
  の境界として整理し、次をできるようにする。
  1) アプリがAPOCを使っている入口（機能）を同定できる  
  2) 露出しているAPOCの種類を「危険系（外部到達/動的実行/ファイル）」として分類できる  
  3) 成立根拠（差分＝oracle）を低侵襲に確定できる  
  4) 修正方針を「APOC禁止」ではなく **allowlist + 権限分離 + 引数型拘束 + 設定** に落とせる

## 前提（対象・範囲・想定）
- 対象
  - “インポート/エクスポート/同期” “外部データ参照” “CSV/JSONロード” “データ加工” “ETL” “可視化” 等の機能
  - 管理機能（データ管理/バッチ処理）に隠れていることが多い
- 想定構成
  - アプリ→Neo4j（Bolt/HTTP）
  - APOC有効（Community/Enterprise、構成で差がある）
  - プロシージャ呼び出しはCypher経由で行われる（CALL dbms.procedures / CALL apoc.*）
- 本ファイルの焦点
  - APOCによって “NoSQLi（Cypher Injection）” が **別の影響面（外部到達・動的実行）** に拡張される点
- 注意（実務）
  - APOCの具体的な悪用手順・payload提示は避け、観測設計と防御設計に寄せる
  - ラボで再現する場合も、外部到達は自分の管理下（ローカル・ダミー）に限定し、実環境での到達テストは抑制する

## まず押さえる：APOCが危険になる条件（3層モデル）

### 層1：APOC自体が“利用可能”である（運用設定）
- アプリがAPOCを呼べるDBユーザ権限を持っている
- apoc.* の実行が許可されている（ホワイトリスト/ブラックリスト設定がない、または緩い）

### 層2：アプリが“APOCに入力を渡す”導線がある（入口）
- 管理画面、インポート機能、検索/推薦の拡張、外部参照、レポート生成など

### 層3：APOCの中でも“外部到達/動的実行/ファイル”系を触っている（高影響）
- 外部到達：HTTP等で外部を取りに行く
- 動的実行：文字列でCypherを実行する/構文を組み立てる
- ファイル：file:// 等ローカル資源へ触れる

> 実務の判断：層1〜3のどこが成立しているかを分解して報告する  
> 「APOCがある＝脆弱」ではない。入口と権限と種類が揃って初めて高リスクになる。

## 境界モデル（入力→CALL→効果）

### 1) 入口（input surface）：APOCを使いがちな機能の当たり
- 高確度
  - CSV/JSONの取り込み、URLからのデータロード、ETL、外部連携、データ整形、バッチ更新
- 中確度
  - 可視化/分析（グラフ探索の補助）、管理者向けクエリエディタ、デバッグ用機能
- 低確度だが注意
  - “おすすめ/関連” の高速化で内部的にAPOCを使っているケース（APOCのgraph algo系）

### 2) sink（実行点）：CALL apoc.* がどこで作られるか
- 安全側
  - 呼び出すプロシージャは固定、引数はparamsで型拘束
  - 実行権限は最小（その機能だけ）
- 危険側
  - 文字列連結で CALL を作る、または「任意プロシージャ名」や「任意URL」を入力で受ける
  - 管理者機能のつもりが一般ユーザへ露出している（認可不備）

### 3) oracle（成立根拠）：エラーより“到達性”と“挙動差分”
- Boolean oracle（主）
  - 成功/失敗、件数/反映結果、ログに残る実行痕跡、非同期ジョブの状態変化
- Error oracle（補助）
  - “procedure not found / not allowed / security exception” 等の差分
  - ただし詳細エラーを返す場合は情報露出として独立に指摘
- Time oracle（補助）
  - 外部ロードや重い処理で遅延は起き得るが、負荷検証は避け、制約欠如として評価

## APOCを“危険カテゴリ”で分類する（報告の軸）

### カテゴリA：外部到達（SSRF類似の境界）
- 例（概念）
  - URL/HTTP経由でデータ取得・変換する系
- 何が危険か（意味）
  - 入力がURLに入ると、アプリ→DB→外部/内部 という到達性が開く可能性
  - これはWSTGのSSRF観点（到達性・メタデータ・内部）に接続する
- 何を見るか（判断）
  - URLが入力由来か、allowlistがあるか、内部宛てが拒否されるか
  - リダイレクト、DNS、IP直指定などの“到達性トリック”に弱い設計か（ただし実環境での到達テストは抑制）

### カテゴリB：動的Cypher実行（Injection増幅器）
- 例（概念）
  - 文字列からCypherを実行する/構文生成する系
- 何が危険か
  - Cypher Injectionが成立した場合の影響が“検索条件改変”から“任意クエリ実行”寄りに増幅する
- 何を見るか
  - 入力が “クエリ断片/全文” に入る導線があるか
  - stored query（固定）か、動的生成か

### カテゴリC：ファイル/ローカル資源アクセス（環境依存の高影響）
- 例（概念）
  - file:// の読み込み、エクスポート先指定など
- 何が危険か
  - DBが動くホストの資源へ触れる可能性（ただし環境/設定で差が大きい）
- 何を見るか
  - 設定で禁止されているか、パスallowlistがあるか、実行ユーザ権限が最小か

### カテゴリD：高コスト処理（可用性境界）
- 例（概念）
  - 大量探索、アルゴリズム、ロード・変換
- 何が危険か
  - 認可が弱いと一般ユーザが重い処理を叩ける
- 何を見るか
  - レート/タイムアウト/ジョブキュー化/上限（深さ、件数）

## 根本原因の分類（報告にそのまま使える形）

### 原因A：プロシージャ許可が広すぎる（allowlist不在）
- 症状
  - 多数のapoc.* が実行できる/拒否されない
- 修正
  - 必要なプロシージャだけ許可（最小権限）
  - アプリ用途と管理用途でDBユーザを分離（権限伝播を切る）

### 原因B：引数（URL/クエリ/パス）に型拘束・allowlistがない
- 症状
  - URLやクエリ断片、パスなどが自由入力
- 修正
  - URL：スキーム/ホスト/ポート/パスのallowlist、IP直指定禁止、リダイレクト制限
  - クエリ：本文固定、入力はparamsのみ
  - パス：ベースディレクトリ固定、正規化、相対パス拒否

### 原因C：アプリ認可が弱く、管理機能が露出している
- 症状
  - インポート/同期/管理系が一般ユーザから叩ける（またはCSRF等で誘導可能）
- 修正
  - 管理機能は別UI/別API、強い再認証、IP制限、監査をセット
  - “操作権限”と“データ範囲”を分離（BFLA/BOLAを同時に潰す）

### 原因D：エラーモデル不備（oracle化）
- 症状
  - procedure名、設定、スタック、URLなどがエラーで露出
- 修正
  - 外部：統一エラー＋trace_id
  - 内部：分類ログ（mask）

### 原因E：可用性制限がない（DoS設計不備）
- 症状
  - 高コストプロシージャが無制限
- 修正
  - レート、タイムアウト、ジョブキュー、上限（深さ/件数/期間）

## 次に試すこと（仮説A/B/C：安全に確定）
> 具体の危険payloadは示さず、差分観測で“どの境界が開いているか”を確定する。

### 仮説A：APOC呼び出し自体が可能（層1が成立）
- 条件（観測）
  - ある機能操作で “procedure not allowed / not found” の差分が出る、または成功痕跡が出る
- 次の一手
  - その機能がどのapocカテゴリ（外部到達/動的実行/ファイル/高コスト）に属するかを分類し、優先度を付ける

### 仮説B：入力が引数に到達し、到達性/実行が入力依存で揺れる（層2が成立）
- 条件（観測）
  - URL/クエリ/パス/パラメータの形で結果（成功/失敗/件数）が再現性を持って変わる
- 次の一手
  - “dataとしての入力”か、“語彙/構文としての入力”かを切り分ける
  - 仕様として許すべき柔軟性（例：外部連携）なら、allowlistと認可・監査が揃っているかを検証する

### 仮説C：second-order（保存→実行）でAPOCが実行される
- 条件（観測）
  - 保存した設定/ジョブ/レポートを実行したときだけ差分が出る
- 次の一手
  - 保存時/実行時の二重検証と、設定のバージョニング・承認フロー（管理者承認）を修正案に入れる

## 防御設計（実装・運用：APOCを“安全に使う”）

### 1) DBユーザ分離（最重要：権限伝播を切る）
- アプリの通常処理用DBユーザ：読み取り/限定書き込みのみ、危険プロシージャは許可しない
- 管理/運用用DBユーザ：必要時のみ、強い認証/監査/到達制限の下で使用
- 目的：アプリの入口が突破されても、APOC高影響面へ直結しない

### 2) procedure allowlist（最小権限）
- “必要なapocだけ”許可する
- 外部到達/動的実行/ファイル系は原則禁止（必要なら限定条件付き）
- 変更はIaC/構成管理で追跡し、監査対象にする

### 3) 引数の型拘束・allowlist
- URL入力が必要な機能は、サーバ側で
  - 送信先allowlist（ドメイン/ポート）
  - スキーム制限
  - リダイレクト制限
  - DNS解決の固定（必要なら）
  を実装する（“URL文字列のエスケープ”では解決しない）
- 動的Cypherが必要な場合
  - クエリ本文は固定、入力はparamsのみ（語彙を入力にしない）
- ファイル系が必要な場合
  - ベースディレクトリ固定、正規化、相対パス拒否、アクセス権最小

### 4) 認可と監査（管理機能の保護）
- 管理系操作は
  - 強い再認証（step-up）
  - IP/デバイス制限
  - CSRF対策
  - 監査ログ（誰が何を実行したか）
  をセットで持つ

### 5) 可用性制限（DoS境界）
- タイムアウト、レート、ジョブキュー化、上限（深さ・件数・期間）
- 監査：高コスト傾向（実行時間、失敗率）を検知

### 6) エラーモデル統一（oracle化防止）
- 外部：統一エラー＋trace_id
- 内部：プロシージャ名、カテゴリ、拒否理由、入力形状（型/長さ）を記録（値はマスク）

## 手を動かす検証（Labs連動：安全に境界を再現）
- 目的：APOCの層1〜3（許可/入口/種類）を分解して再現し、何が揃うと危険かを体で理解する
- 最小構成（推奨）
  - (1) 通常DBユーザ：apoc禁止（安全）
  - (2) 管理DBユーザ：必要なapocだけ許可（allowlist）
  - (3) 悪い例：アプリDBユーザにapocを広く許可（危険）
  - (4) second-order：保存→実行でのみapocを呼ぶ導線（危険の典型）
- 証跡
  - HAR：操作→実行→結果
  - サーバログ：trace_id、実行されたプロシージャカテゴリ、引数の型/長さ、実行時間
  - DBログ（Labsのみ）：CALL履歴、拒否理由

## 例（最小限：発想の固定）
~~~~
# 安全設計（概念）：CALLするプロシージャは固定、入力はparamsのみ、かつサーバ側でallowlist検証
CALL apoc.<fixed_proc>($param1, $param2)

# 危険設計（概念）：プロシージャ名やクエリ断片を入力で決める/連結するのは境界破壊
# ※具体の悪用payloadは提示しない
~~~~

## 参考（必要最小限）
- Neo4j APOC Docs（概要・設定・プロシージャ一覧）  
  - https://neo4j.com/docs/apoc/current/
- Neo4j Operations Manual：Security（認証/認可/ロール/設定）  
  - https://neo4j.com/docs/operations-manual/current/security/
- Neo4j Cypher Manual（パラメータ化）  
  - https://neo4j.com/docs/cypher-manual/current/

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/05_input_04_nosql_injection_03_neo4j_cypher_01_query（cypher_injection）.md`
- `01_topics/02_web/05_input_09_ssrf_01_reachability（internal_localhost_metadata）.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 次（作成候補順）
- `01_topics/02_web/05_input_04_nosql_injection_03_neo4j_cypher_03_authz（graph_traversal_scope）.md`
