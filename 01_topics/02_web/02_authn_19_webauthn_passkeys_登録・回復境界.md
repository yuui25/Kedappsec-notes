## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - この技術で満たす/破れる点：強固な認証（フィッシング耐性）、認証器登録/管理の保護（step-up必須、本人確認）、回復導線の強度（回復でパスキーを迂回しない）、多要素の整合（MFA解除/回復コード再発行の保護）、セッション/端末信頼の扱い
  - 支える前提：パスキーは強いが、登録・削除・回復が弱いと“強さが迂回”される（攻撃は認証器そのものより運用境界を狙う）
- WSTG：
  - 該当テスト観点：Authentication Testing（MFA/強固認証、Account Recovery）、Session Management（再認証境界）
  - どの観測に対応するか：登録（attestation/credential creation）、認証（assertion）、認証器管理（rename/remove）、回復（fallback）を“境界”として観測し、例外パスを検出する
- PTES：
  - 該当フェーズ：Vulnerability Analysis（登録/回復境界の欠陥、例外パス抽出）、Exploitation（許可範囲での最小検証：テストアカウント）
  - 前後フェーズとの繋がり（1行）：16（step-up）で登録/削除/回復の境界を締め、11（account recovery）と一体で「パスキーを回復で迂回」できないことを確認し、15/17/18でセッション/トークン盗用耐性を補完する
- MITRE ATT&CK：
  - 戦術：Credential Access / Persistence / Defense Evasion
  - 目的：強固認証を回復導線・端末信頼・登録手続きの穴で迂回し、永続アクセス（登録済み認証器の追加/置換）を成立させる（※手順ではなく成立条件の判断）

## タイトル
webauthn_passkeys_登録・回復境界

## 目的（この技術で到達する状態）
- WebAuthn/Passkeys を「ログイン方式」ではなく「登録・管理・回復まで含む運用境界」として分解し、どこが弱点になり得るかを証跡付きで評価できる
- “フィッシング耐性” を実効化するために必要な設計（登録時の再認証、回復導線の強度、fallbackの制約、通知/監査）を具体的に指示できる
- エンジニアが何を実装/設定すべきかを、「どの操作をstep-up必須にするか」「どの回復を許すか」「どのログを残すか」まで落とし込める
- 後続（20 magic-link）や既存（11 account recovery）に対して、パスキー導入後も残る“弱い入口”の扱いを設計として閉じられる

## 前提（対象・範囲・想定）
- 対象：
  - 登録（credential creation）：/webauthn/register/begin → /webauthn/register/finish 等
  - 認証（assertion）：/webauthn/auth/begin → /webauthn/auth/finish 等
  - 認証器管理：一覧、名称変更、削除、デフォルト設定、信頼端末管理
  - 回復：パスキーが使えない時のfallback（メール/OTP/回復コード/サポート）
- 想定する境界：
  - パスキーは“強い”が、必ず fallback が存在する（端末紛失・機種変更・同期失敗）
  - 端末同期パスキー（クラウド同期）と、セキュリティキー（外部キー）が混在し得る
  - 既存ログイン（パスワード/MFA）と共存し、アカウント設定で切替/無効化が起きる
- 安全な範囲（最小検証の基本方針）：
  - テストアカウントで、登録/削除/回復の“境界が働くか”を観測する（大量試行はしない）
  - 物理デバイスが必要な部分は、設計・挙動・ログで評価する（無理に再現しない）
  - 変更を伴う検証（認証器削除等）は巻き戻し（再登録）手順を確保する

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
### 1) パスキー導入で狙われるのは「登録・回復・管理」だと固定する
- 攻撃の現実的な焦点
  - 追加登録（攻撃者の認証器を登録できると永続化）
  - 既存認証器の削除（防御解除）
  - fallback回復（弱い回復でログインできる）
  - “信頼端末” 誤用（step-up省略の温床：16/15と接続）
- 観測の第一歩
  - 「ログイン画面」だけでなく、設定画面（セキュリティ/デバイス）と回復導線を必ず列挙する

### 2) 登録フローの境界：誰が、いつ、何を前提に登録できるか
- 観測対象（典型）
  - 登録開始：challenge（チャレンジ）とrpId、user情報、timeout等が渡される
  - 登録完了：attestation/credentialPublicKey 等が送られ、サーバに紐付く
- 重要な境界（設計の要）
  - 登録は “ログイン済みセッション” だけで許可してよいか？
    - 原則：重要操作＝step-up必須（16）
  - 登録開始/完了がCSRF/取り違え耐性を持つか？
    - 13のstate設計と同型：トランザクションID（challenge）をサーバ側に保存し、単回・短寿命で照合
  - 登録のスコープ
    - どのユーザIDに紐付けるか（セッションのユーザと一致すること）
    - “他人のユーザIDで登録できる” 形のAPIを作らない（IDORは別テーマだが、境界として強調）
- 証跡として残す項目
  - 登録開始/完了のエンドポイント、要求条件（step-upの有無）、失敗時のエラー
  - challengeの単回性・TTLの兆候（再送で通らない等）
  - 監査ログ（credential_added）

### 3) 認証フローの境界：パスキーが“強い”ことを弱い入口で壊していないか
- 重要観測
  - パスキーでログインできる時、パスワード入力に戻せない/戻さない設計か（ポリシー次第）
  - “パスワード fallback” が常に有効だと、パスキーの意味が薄れる（要件と照合）
- 実務の判断軸
  - パスキーを“必須”にしたいのか、“推奨”として残すのか
  - 推奨の場合でも、重要操作（16）はパスキー/強い再認証を要求する、という設計が必要

### 4) 認証器管理（devices/credentials）：ここが永続化・防御解除の中心
- 観測対象
  - 認証器一覧（登録済みcredentials）
  - 名称変更（運用のため）
  - 削除（credential remove）
  - “これを既定にする/優先する” 等の設定（ある場合）
- 重要境界（ペネトレでの核心）
  - 削除・追加は step-up 必須か（16）
  - “最後の認証器を削除” できるか（できるならfallback強度がより重要）
  - 管理APIがUI以外でも叩ける場合、CSRF/取り違え/認可が効いているか（13/16と同型）
- 監査/通知
  - credential追加/削除は必ず通知（本人へ）と監査ログに残るべき（侵害時の検知性）

### 5) 回復（fallback）境界：パスキーを迂回させない設計（11と直結）
- 典型fallback
  - 回復コード、メールリンク（20）、SMS/OTP、サポート代行
- 重要判断
  - パスキー必須アカウントでも、回復でパスワードに戻せるのか？
  - 回復後に “パスキーが無効化される/再登録を強制” するか？
  - 回復行為自体が step-up（本人確認強度）相当になっているか（11）
- 観測焦点
  - 回復導線で“本人確認の強度”が十分か（11の観点：サポート代行・メール乗っ取り等）
  - 回復後の状態遷移：
    - 全端末ログアウト（15）
    - refresh系列失効（17）
    - 既存認証器の扱い（無効化/維持/再確認）
  - 回復フローが列挙（ユーザ存在判定）や試行（12）に弱くないか（副作用も含める）

### 6) “信頼端末/同期” という現実：強度の過信を潰す
- パスキーの実務上の落とし穴
  - 同期パスキーは “端末” ではなく “プラットフォームアカウント（Apple/Google等）” に依存する
  - 端末紛失より、クラウドアカウント侵害が本質リスクになる場合がある（ただしここでは攻撃手順は扱わない）
- 観測で確定したい点
  - “信頼端末ならstep-up省略” の条件が存在するか（16と接続）
  - 同期がある前提で、回復が弱くなっていないか（回復で迂回が成立しないか）

### 7) passkeys_key_boundary（後工程に渡す正規化キー）
- 推奨キー：passkeys_key_boundary
  - passkeys_key_boundary = <policy>(required|optional|unknown) + <register_protection>(stepup_yes/no/unknown) + <manage_protection>(stepup_yes/no/unknown) + <fallback_strength>(strong|medium|weak|unknown) + <fallback_effect>(force_rereg|keep|disable|unknown) + <notify_audit>(yes/no/partial/unknown) + <exception_path>(present/none/unknown) + <confidence>
- 記録の最小フィールド（推奨）
  - register_endpoints / auth_endpoints / manage_endpoints / recovery_endpoints
  - stepup_required_on_register/manage（yes/no）
  - last_credential_delete_policy（許容/拒否/不明）
  - recovery_posture（回復後の全失効/再登録強制の有無）
  - evidence（HAR、UIスクショ、監査ログ、設定断片）
  - action_priority（P0/P1/P2）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定できる）：
  - 登録/削除/回復に step-up が掛かるか、どこが例外パスか（UI/API差分含む）
  - fallback（回復導線）の強度と、回復後の状態遷移（全端末logout、refresh失効、再登録強制等）の有無
  - 認証器変更の通知/監査があるか（侵害検知・追跡可能性）
- 推定（根拠付きで言える）：
  - 登録/削除がstep-up無しなら、侵害セッション（盗用/放置端末）で永続化が成立し得る（15/16/17と連鎖）
  - fallbackが弱いと、パスキーのフィッシング耐性が“実運用上は無効化”される可能性が高い
- 言えない（この段階では断定しない）：
  - 認証器/プラットフォーム固有の内部挙動（iOS/Android/ブラウザ差）※ただし運用設計の弱点は示せる

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- 優先度（P0/P1/P2）
  - P0：
    - 認証器の追加/削除が step-up なし（重要操作の境界欠落）
    - 回復導線が弱く、回復後も既存セッション/refreshが生きる（侵害遮断が効かない）
    - “最後の認証器削除” が容易で、即座に弱いログインへ戻れる
  - P1：
    - step-upはあるが、入口差分（mobile/api/管理API）が例外パス
    - 通知/監査が薄く、侵害検知・追跡が困難
  - P2：
    - 設計は堅牢だが、UX/サポート運用が不明瞭（回復時の手当が重い/軽すぎる）
- “成立条件”としての整理（技術者が直すべき対象）
  - 登録/削除/回復を step-up 必須にする（16）
  - 回復後に全端末logout（15）＋refresh系列失効（17）＋再登録要求（必要なら）で“侵害遮断”を閉じる
  - 例外パス（UIだけ防御）を消し、APIレベルで強制する
  - 通知/監査を必須化し、相関キー（user_id/device_id/credential_id）を残す

## 次に試すこと（仮説A/Bの分岐と検証）
- 仮説A：登録/削除に step-up が無い（永続化リスク）
  - 次の検証（低アクティブ）：
    - 認証器追加（開始/完了）で step-up 要求が出るか
    - 認証器削除で step-up 要求が出るか
    - UIの裏で叩くAPIをHARで特定し、API直叩きでも同じ境界があるか（例外パス検出）
  - 判断：
    - 無い/例外あり：P0
- 仮説B：fallback回復が弱く、回復後に遮断が走らない
  - 次の検証：
    - 回復手段（メール/回復コード/サポート）ごとに、本人確認強度の差を観測（11）
    - 回復完了後に、他端末のセッションが切れるか（15）、refreshが死ぬか（17）を観測
  - 判断：
    - 切れない：P0
    - 切れる：回復は堅牢寄り。次は通知/監査（仮説C）へ
- 仮説C：通知/監査が薄い（侵害時に気づけない）
  - 次の検証：
    - credential追加/削除の監査ログが残るか（相関キー含む）
    - 本人通知（メール/プッシュ）があるか
  - 判断：
    - 無い/薄い：P1（検知性の欠落）
- 仮説D：例外パス（mobile/api）が存在する
  - 次の検証：
    - webとmobile（可能なら）で登録/削除の要求条件を比較
    - APIトークン/PAT等が絡む場合、管理面に統合されているかも確認
  - 判断：
    - 例外あり：P1（権限の高い例外ならP0寄り）

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - `04_labs/02_web/02_authn/19_webauthn_passkeys_boundary/`
    - 構成案：
      - RP：登録/認証/管理/回復の4系統エンドポイントを用意し、step-up有無を切替できる
      - 回復：メールリンク（20）/回復コード（11）を簡易実装し、回復後の“全失効”を切替できる
      - 監査ログ：credential_added/removed、recovery_completed、sessions_revoked、refresh_family_revoked を必ず出す
- 取得する証跡（深く探れる前提：HTTP＋周辺ログ）
  - HTTP：HAR（register begin/finish、manage list/remove、recovery）
  - UI：認証器一覧、削除時の再認証要求画面
  - アプリログ：challengeの保存/照合、credential_id、step-up強度、回復後の失効イベント
  - 監査ログ：相関キー（user_id/device_id/credential_id）
- 観測の設計（巻き戻し前提）
  - 削除検証は必ず再登録手順を確保（最後の認証器を消すと戻れないことがある）
  - 回復検証は“回復後の全失効”を確認し、テストアカウントのセッションを巻き戻す

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
~~~~
# 例：WebAuthn登録（擬似）
POST /webauthn/register/begin
POST /webauthn/register/finish

# 例：認証器管理（擬似）
GET  /settings/passkeys
POST /webauthn/credential/remove   { credential_id: "..." }

# 観測すること（擬似）
- 追加/削除で step-up が要求されるか（重要操作境界）
- begin/finish の challenge が単回・短寿命で照合されるか（取り違え耐性）
- 回復後に全端末logout・refresh失効が走るか（侵害遮断）
~~~~
- この例で観測していること：
  - パスキーの“強さ”が登録/回復で迂回されていないか
- 出力のどこを見るか（注目点）：
  - step-up要求、challenge照合失敗の挙動、削除/回復後の失効イベント、監査ログ
- この例が使えないケース（前提が崩れるケース）：
  - IdP主導でWebAuthnが完結し、RP側で詳細が見えない（→RPが守るべき“管理/回復”に焦点を移し、IdPログ/設定で裏取り）

## 参考（必要最小限）
- OWASP ASVS（強固認証、認証器管理、回復、重要操作の再認証）
- OWASP WSTG（MFA/強固認証、Account Recovery、Session Management）
- WebAuthn/Passkeys の設計原則（強さは“登録と回復”で決まる）

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/02_authn_11_account_recovery_本人確認（サポート代行_回復コード）.md`
- `01_topics/02_web/02_authn_16_step-up_再認証境界（重要操作_再確認）.md`
- `01_topics/02_web/02_authn_20_magic-link_メールリンク認証の成立条件.md`
