## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）
- ASVS
  - 入力→実行境界：外部コマンド起動は「コマンド文字列」だけでなく **実行環境（env）** が実質的な“第二入力面”。PATH/LD_PRELOAD 等で「呼ばれる実体」がすり替わる設計を許さない
  - 安全な実行：絶対パス固定、引数配列、**環境変数のallowlist**、プロセス権限分離、作業ディレクトリ固定
  - 監査：プロセス生成（親子、argv、cwd、envの要約/ハッシュ）を trace_id と相関
- WSTG
  - コマンド注入（Command Injection）の派生として、**環境変数の汚染（environment poisoning）** を検証に含める（入力が直接コマンドに見えなくても成立）
- PTES
  - Vulnerability Analysis：外部コマンド呼出し箇所の特定 → “envがどこ由来か（継承/上書き/ユーザ入力）” を分解
  - Exploitation：影響実証は最小限（「別実体が呼ばれ得る」「ライブラリ/設定が注入され得る」成立根拠の確定まで）。本番での破壊的実証は避ける
  - Reporting：原因を「絶対パス不使用」「環境allowlist不在」「実行権限過大」「作業dir不定」「second-order設定経路」に分解
- MITRE ATT&CK
  - Execution：Command and Scripting Interpreter（T1059）
  - Defense Evasion / Privilege Escalation：環境汚染で“意図しない実体”を起動、またはロード挙動を変える
  - Discovery/Collection：実行環境の情報取得（環境変数・パス・プロキシ設定）を起点に横展開の足場

---

## タイトル
command_injection_env（path_ld_preload）

## 目的（この技術で到達する状態）
- 「メタ文字が効かない＝安全」でも、「argvが固定＝安全」でもなく、**envが制御できると“実行結果”が変わる**ことを、現実の実装パターンに即して評価できる
- 具体的に次をできるようにする
  1) 外部コマンド起動の“実体決定”に env が関与しているか（PATH/ローダ/言語ランタイム/プロキシ/設定）を分類できる  
  2) 入力が env に到達する経路（直入力/ヘッダ/管理画面設定/ジョブ保存＝second-order）を特定できる  
  3) 低侵襲な差分観測で「env汚染で挙動が変わる」成立根拠を確定できる  
  4) 対策を “入力フィルタ” ではなく **絶対パス＋env allowlist＋権限分離＋cwd固定** に落とせる

---

## 背景：envは“見えにくい入力”で、実装者の想定外で混入しやすい
- Webアプリは多くの場合、プロセス環境（env）を継承して外部コマンドを起動する
- その env は
  - デプロイ設定（K8s env / systemd Environment / .env）
  - 代理実行（ジョブワーカー/バッチ）
  - リクエスト由来の値（管理機能やヘッダを転写する実装）
  の合成になり、**どこか一箇所がユーザに触れると全体が汚染**される
- 実務で危険なのは “直入力” より **second-order（保存した設定が後で実行環境に混ざる）**：
  - 「Webhookの疎通テスト設定」「外部連携のプロキシ設定」「変換ジョブのオプション」など

---

## 境界モデル（入力→env→実体決定→実行）

### 1) envの決まり方（3つの供給源）
- 継承（inherit）
  - アプリプロセスが持つ env をそのまま子プロセスへ渡す
- 上書き（override）
  - spawn/exec のオプションで env を構成し直す（ここが設計次第で安全にも危険にもなる）
- 合成（merge）
  - 基本 env ＋ 追加 env（ユーザ設定やリクエスト情報）をマージする（最も事故りやすい）

### 2) 実体決定のポイント（envが効く場所）
- PATH：コマンド名だけで起動していると、PATH順序で“どの実体”が呼ばれるか決まる
- ローダ：LD_PRELOAD 等が有効だと、ライブラリロード順が変わり挙動が変わる（Linux系）
- ランタイム：PYTHONPATH / NODE_OPTIONS / JAVA_TOOL_OPTIONS などで、実行時の挙動が変わる
- ネットワーク：HTTP_PROXY / NO_PROXY 等で、外部到達や経路が変わる（SSRF/内部到達に接続）
- ツール固有：GIT_* / SSH_ASKPASS など、コマンドの外部連携挙動が env で変わるものがある

---

## 攻撃面の分類（現実寄り：何が起きるか）

### A. PATH Poisoning（呼ばれる実体のすり替え）
- 成立条件（典型）
  - アプリが `git` / `curl` / `convert` などを **絶対パスなしで起動**
  - かつ PATH が “ユーザが書き込めるディレクトリ” を先に含む、または PATH 自体がユーザ由来で変えられる
- 影響の方向性（現場の論点）
  - “想定したバイナリ”ではなく“別のバイナリ”が呼ばれる（= 実行の起点）
  - ただし、書込み可能ディレクトリの有無、実行ユーザ権限、コンテナ/FSが鍵
- 実務での高頻度シナリオ
  - 変換/プレビュー用の作業ディレクトリが書込み可能で、そこが PATH に入っている
  - バッチ/ワーカーが広い PATH を持っている（運用都合で雑に通す）

### B. LD_PRELOAD / ローダ系（ロード挙動のすり替え）
- 成立条件（典型）
  - 子プロセスに LD_PRELOAD 等が有効な形で渡る（※OS/実行条件で無効化される場合もある）
  - “攻撃者が指定したライブラリ”が参照可能な場所にある（多くはここが難所）
- 影響の方向性
  - 実体のすり替えというより「同じ実体でも挙動を変える」方向に作用する
- 実務の見立て
  - “成立したら重い”が、“成立条件が揃う環境は限定的”になりやすい
  - だからこそ **「env allowlist + クリア」** を規約化して潰す（可能性をゼロ寄せ）

### C. ランタイム/ツール固有env（“ミニ設定言語”注入）
- 成立条件（典型）
  - 外部コマンドが「言語ランタイム」または「多機能CLI」で、env を設定として読む
  - 例：プロキシ設定、設定ファイル参照、プラグイン読み込み、デバッグ/詳細出力
- 影響の方向性
  - 情報露出（詳細ログ/設定表示/エラー詳細）
  - 内部到達（プロキシ/NO_PROXYの誤設定を踏むと内部へ向かう）
  - 可用性（過剰ログ、重いモード）
- ここが“攻撃より”の要点
  - 文字列がそのままコマンドに入っていなくても、**env＝設定として効く**ため、入力の到達経路を潰す必要がある

### D. env → 認可/スコープ破壊（second-orderで起きやすい）
- 例（概念）
  - 管理者が設定したつもりの “外部連携設定” を一般ユーザが編集できる
  - それがワーカー環境へ反映され、別テナントのデータへアクセスする導線になる
- 重要
  - これは “Command Injection” というより **権限伝播/設定管理の脆弱性** と複合する
  - 報告では原因を分離（設定の認可不備＋実行環境への反映設計）して示す

---

## 成立根拠（差分＝oracle）を取る：攻撃者視点だが低侵襲

### 1) まず「絶対パスか？」を推定する（最短で当たりを付ける）
- 観測の考え方
  - 絶対パスで起動していれば PATH 汚染の余地は大幅に減る
  - ただし “内部的に別コマンドを呼ぶ”ケースもあるため、単純には断定しない

### 2) env が入力由来で変わる経路を探す（直入力より second-order）
- 高確度の探索ポイント
  - 管理画面：プロキシ設定、外部連携、ジョブテンプレ、変換プロファイル
  - リクエスト転写：`X-Forwarded-*` や任意ヘッダを env に入れる実装（まれだが一撃で危険）
  - ファイル名/パス：作業ディレクトリや出力先が “PATH 汚染” と結びつくケース
- 観測サイン
  - 同じ機能でも “管理設定を変えると” 実行結果（通信先/ログ/生成物）が変わる

### 3) 差分の取り方（安全優先で証拠化）
- 優先度順
  1) **エラー差分**：失敗理由が「実体が違う/設定が違う」方向へ変わる（ただし詳細露出は別問題として切る）
  2) **生成物差分**：出力ファイルのメタ情報や内容の一部が変わる（大量生成は避ける）
  3) **通信差分**：外部到達が変わる（SSRFと同様に、実環境での到達実証は抑制し、設計不備として示す）
  4) **時間差分**：最終手段（DoS境界に近いので慎重に）

---

## command_injection_env_key（正規化キー：診断メモをブレさせない）
- 推奨キー：command_injection_env_key
  - command_injection_env_key =
    <exec_api>(execve|spawn|unknown)
    + <absolute_path_used>(yes/no/unknown)
    + <env_source>(inherit|override|merge|unknown)
    + <env_vector>(PATH|LD_PRELOAD|PROXY|RUNTIME|TOOL_SPECIFIC|multi|unknown)
    + <user_control>(direct|second_order|none|unknown)
    + <observable>(error|file|network|timing|log|unknown)
    + <exec_context>(privileged|same_user|container|unknown)

---

## 根本原因（報告用の分類）

### 原因1：絶対パス不使用（PATHに依存）
- 修正の核
  - 起動対象は絶対パス固定
  - 依存コマンドも固定（内部で呼ぶものも含めて棚卸し）

### 原因2：env allowlist がない（継承し放題/マージし放題）
- 修正の核
  - 子プロセスへ渡す env は **最小セット**（PATHも固定値）
  - 不要な env はクリア（特にローダ系/ランタイム系/プロキシ系）

### 原因3：second-order 設定が実行環境へ混入（認可・検証不足）
- 修正の核
  - 設定の編集権限、承認フロー、変更監査
  - 実行環境へ反映する値は型拘束＋allowlist（URL/ドメイン/パス等）

### 原因4：実行権限が強い / 作業dirが不定
- 修正の核
  - 実行ユーザ最小化、作業dir固定（書込み可能領域を限定）
  - コンテナ/サンドボックスで外部到達とFSアクセスを局限

### 原因5：ログ/監査がなく、再現も検知もできない
- 修正の核
  - trace_id とプロセス生成（argv要約、cwd、env要約）を相関
  - 異常探索（短時間に失敗連発、help相当、異常な実行時間）を検知

---

## 防御設計（“現実に効く”順）

### 1) 絶対パス固定 + 引数配列（前提）
- PATHに依存しない。まずここで PATH Poisoning をほぼ殺せる

### 2) env allowlist（子プロセスは“新規に作る”）
- 例（概念）
  - PATHは固定（例：`/usr/bin:/bin` 等、運用に合わせて最小）
  - ローダ系/ランタイム系/プロキシ系は原則渡さない
- 重要
  - “親のenvをそのまま渡す”のは便利だが、攻撃面が読めなくなる

### 3) 作業dir固定 + 書込み先固定
- PATH Poisoning の成立条件（書込み可能ディレクトリが PATH に含まれる）を構造的に潰す
- 生成物はサンドボックスへ、実行ユーザも限定

### 4) second-order 設定の統制
- “設定＝入力”としてASVS的に扱う
- 変更監査・承認・差分レビュー（設定が env/実行に影響するなら特に）

### 5) 監査と検知（攻撃者の探索行動を拾う）
- env/argvの全文を残すのではなく、**要約（キーの存在、長さ、ハッシュ、危険キーの有無）**で良い
- trace_id と結び、検知ルールへつなぐ

---

## 手を動かす検証（Labs連動：現実寄りに「起き方」を再現）
- 目的
  - (1) 絶対パスなし＋PATH依存がどれだけ危険か  
  - (2) env allowlist の有無で攻撃面がどれだけ変わるか  
  - (3) second-order 設定が“後から効く”怖さ  
  を体感し、診断時の勘所を固定する
- 最小構成（推奨）
  - 悪い例A：コマンド名のみで起動（PATH依存）
  - 良い例A：絶対パス固定
  - 悪い例B：親env継承＋ユーザ設定をマージ
  - 良い例B：env allowlist（固定PATH）＋設定値の型拘束
  - second-order：設定保存→ジョブ実行で初めて反映、の経路を作る
- 証跡
  - HAR（設定変更→実行→結果）
  - アプリログ（trace_id、argv要約、cwd、env要約、実行時間）
  - OS側（Labsのみ）：プロセスツリー、実行ユーザ

---

## 例（最小限：設計の差だけ示す）
~~~~
# 悪い例（概念）：PATH依存・env継承
execve(["convert", input, output], env=inherited_env)

# 良い例（概念）：絶対パス固定・env allowlist
safe_env = { "PATH": "/usr/bin:/bin", "LANG": "C" }  # 必要最小限
execve(["/usr/bin/convert", input, output], env=safe_env)

# 悪い例（概念）：ユーザ設定をenvへマージ（second-orderの温床）
safe_env = inherited_env + user_config_env
execve([ABS_CMD, ...], env=safe_env)
~~~~

---

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/05_input_05_command_injection_01_shell（metachar_pipeline）.md`
- `01_topics/02_web/05_input_05_command_injection_02_args（option_injection）.md`
- `01_topics/02_web/05_input_09_ssrf_01_reachability（internal_localhost_metadata）.md`（PROXY等の到達性接続）

---

## 次（作成候補順）
- `01_topics/02_web/05_input_06_xss_01_反射_境界モデル.md`
