## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：キャッシュに格納されたレスポンス（オブジェクト）が“本来の境界（ユーザ/テナント/機能/表現）”を跨いで再利用されると、アプリ側の認証・認可が正しくても **誤った内容が配布**される。これは情報漏えい、誤誘導、誤配布、監査破綻（真実性の喪失）を引き起こす。
  - 満たす：動的レスポンスのキャッシュ禁止（no-store/private）を原則とし、例外的にキャッシュする場合は **キー（Keying）と正規化（Normalization）を仕様化**し、レスポンスに影響する入力は必ずキーへ含める（Vary/キー構成の整合）。また、エラー/リダイレクト/ユーザ依存/権限依存/テナント依存のレスポンスを共有キャッシュに載せない。キャッシュ層とオリジンのログ相関（hit/miss・キー・生成元）を整備する。
- WSTG
  - 観点：Cache Poisoningは「入力→出力」が“保存→再利用”されるため、テストは (1) キャッシュ可能性、(2) キー推定、(3) unkeyed入力の影響、(4) **格納オブジェクトが誰に配られるか（影響半径）** の4段階で評価する。本ファイルは(4)に集中し、成立根拠の取り方を固定する。
- PTES
  - 位置づけ：侵害評価（Impact評価）に直結。Poisoned Objectは第三者影響（他者へ配布）を含み得るため、許可範囲・回数・TTL・対象エンドポイントを厳格に制御し、証跡重視で所見化する。再現性の追求より「境界が崩れた証拠」と「配布範囲の確定」を優先する。
- MITRE ATT&CK
  - T1190（Exploit Public-Facing Application）に接続し得る。
  - Impact（ユーザへの誤配布・劣化）、Collection（混線により情報露出）へ接続し得るが、断定は“配布範囲”と“格納実証”が揃ってから行う。

---

## タイトル
Poisoned Object（stored response）：キャッシュに“誤レスポンス”が格納され、境界を跨いで配布される状態を観測・相関で確定する

---

## 目的（このファイルで到達する状態）
- 「キャッシュキーが壊れ得る」「unkeyed入力がある」から一歩進み、**格納された誤レスポンス（poisoned object）が“誰に配られるか”** を境界で確定できる。
  1) poisoned object の成立条件（格納・再利用・配布範囲）を分解できる
  2) 観測で“格納されたこと”と“再利用されたこと”を証跡化できる
  3) 影響半径（匿名/ログイン/テナント/地域/UA等）を切り分けられる
  4) 第三者影響を最小化しつつ、侵害評価として成立根拠を作れる
  5) 修正要件を「キャッシュ設計/運用/監視」の観点で提示できる

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：Poisoned Object（格納済みレスポンスの配布）に関する境界モデル・観測・証跡化
  - “格納された”ことの根拠（ヒット/Age/ログ相関/オブジェクトID）
  - “誰に配布されるか”の根拠（共有キャッシュ/キー構成/境界）
  - “何が配布されると危険か”の分類（HTML/JSON/リダイレクト/エラー等）
- 扱わない（前提として接続する）
  - keyingの確定：`05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
  - unkeyed入力の特定：`05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`

---

## 定義：Poisoned Object を“実務の判定”に落とす
### Poisoned Object（poisoned cached response）とは
- 攻撃者が何らかの入力差（unkeyed、正規化差、層間不一致等）で **“期待しないレスポンス”** を生成させ、
- そのレスポンスが共有キャッシュ（CDN/Reverse Proxy等）に **格納（store）** され、
- 別の利用者/別条件のリクエストへ **再利用（serve）** される状態。

### 判定の必須3条件（これが揃わない限り“poisoned”と断定しない）
1) Store：キャッシュに格納された証拠（hit/miss遷移、Age増加、ログのstore、オブジェクトID等）
2) Serve：別のリクエストが“同一オブジェクト”を受け取った証拠（hit、同一ETag、同一キャッシュID等）
3) Radius：配布範囲（誰に・どの条件で）を境界で説明できる（共有キャッシュか、キーが何を含むか）

---

## 境界モデル：Poisoned Object の“影響半径”を決める要素
### 1) 共有/非共有の境界（最重要）
- 共有キャッシュ（CDN/Reverse Proxy）
  - 影響：第三者へ配布され得る（重大度が上がる）
- 非共有（ブラウザ/個人キャッシュ）
  - 影響：基本は当該クライアント内に閉じる（ただし端末共有や社内プロキシ等の例外は別途）

### 2) キー境界（Keying）
- キーに含まれる要素が“配布範囲”を決める
  - Host/Path/Query
  - Vary対象のHeader（言語/圧縮/UA/Origin等）
  - Cookie/Authorization（例外的にキーへ含まれる場合は要注意）
- ここは `01_keying` の成果物を前提に、Poisoned Objectの半径を決め打ちする。

### 3) 正規化境界（Normalization）
- “別物が同一キー扱い”になる衝突があると、半径が一気に拡大する（テナント跨ぎ等）

### 4) TTL / 再検証境界（時間で半径が変わる）
- TTLが長いほど影響が拡大しやすい
- 再検証（ETag/If-Modified-Since）が絡むと「更新されないのに配布され続ける」形になる
- “短TTLだから安全”とは限らない（短時間でも多数ユーザが同時に踏む経路なら影響大）

---

## “何が毒になるか”の分類（Poisoned Object の危険度は内容で決まる）
> ここは攻撃寄りの判断軸だが、実害評価のために必要。断定は証跡が揃ってから。

### A) HTML（ページ）毒
- 影響しやすい理由：リンク/フォーム/スクリプト参照/メタ情報（OGP等）が含まれる
- 典型の危険
  - 絶対URL生成が変わる（スキーム/ホスト）
  - script/link参照先が変わる
  - ログイン誘導/遷移誘導が変わる
- 注意：内容に“スクリプト実行”が含まれる評価は別トピック（XSS）。ここでは「配布されるHTMLが期待と違う」こと自体を毒として扱う。

### B) JSON/API 応答毒
- 影響：フロントが信じるURL/設定/フラグが変わると、後続の挙動（権限操作・遷移）に波及し得る
- ただしAPIはCache-Controlで抑止されることも多く、まず“キャッシュされている”根拠が必要

### C) リダイレクト（3xx）毒
- “どこへ飛ばすか”が毒になる。特にログイン/決済/ダウンロード等の遷移が絡むと影響が大きい
- 重要：3xxを共有キャッシュに載せる設計は原則危険（例外は厳密設計が必要）

### D) エラー（4xx/5xx）毒
- エラーがキャッシュされると、可用性・監査・復旧が壊れる
- ただし“単なるDoS”のように見えやすいので、キャッシュ由来（Age/hit/log）で確定する

### E) 静的アセット（JS/CSS）毒
- 強い影響を持つが、実害の断定は慎重に（配布範囲が広い分、検証の安全策が必須）
- 多くはCDNが強く関与するため、層（CDN/Origin）の特定とキーの確定が最重要

---

## Poisoned Object の成立経路（“原因”ではなく“経路”として理解する）
Poisoned Object は単独の脆弱性名ではなく、複数の不整合が合成されて発生する。

### 経路1：Unkeyed入力で“別レスポンス”を生成 → 同一キーに格納
- 前提：`02_unkeyed` で「レスポンスが変わるがキーに入らない入力」を特定済み
- ここでは「そのレスポンスが store され、別条件に serve される」を証跡化する

### 経路2：正規化差で“別リクエストが同一視” → 衝突して格納
- 前提：`01_keying` の正規化差（Host/Path/Query）で衝突が疑える
- ここでは「衝突が配布範囲（特にテナント境界）に触れるか」を評価する

### 経路3：別トピックとの合成（境界が壊れると毒の生成が容易になる）
- Request Smuggling（front/back解釈差）でオリジンへ想定外のリクエストが到達し、キャッシュが誤格納する可能性
- CRLF/ヘッダ分割でレスポンス形状が変わり、キャッシュ挙動が崩れる可能性
- Open Redirect でLocationや遷移が毒になる可能性
※ただし合成経路は断定せず、「観測された状態」として位置づける（推測で所見化しない）。

---

## 観測ポイント（Store/Serve/Radiusを“確定”するための証拠）
> ここが薄いと「それっぽい」止まりになる。Poisoned Objectは“証拠の積み上げ”が本体。

### 1) Store（格納）の証拠
- ヒット/ミスの遷移
  - 1回目はミス、2回目以降がヒット（兆候）
- Age等のオブジェクト経過情報（出る範囲で）
  - Ageが増加する＝同一オブジェクトが再利用されている兆候
- キャッシュ層ログ（可能なら最強）
  - storeイベント、cache key、bypass理由、object id

### 2) Serve（再利用）の証拠
- 同一条件での再現（同じURLで同じオブジェクトが返る）
- 条件差を付けたときに“同一オブジェクト”が返ってしまう（unkeyed/衝突の根拠）
- ETag/Last-Modified が同一のまま配布される（補助証拠：キーそのものではないが同一性の手掛かり）

### 3) Radius（配布範囲）の証拠
- 共有キャッシュかどうか（CDN/Reverse Proxyの関与）
- キーの構成（Vary/ログ/推定結果）
- 境界ごとの切り分け
  - 匿名 vs ログイン
  - テナントA vs B（Host/subdomain等）
  - 言語/UA/地域
- ここは“推定”で止めず、可能な限りログやヘッダで補強する

---

## 侵害評価（攻撃寄りの深掘り：ただし分岐で、推測しない）
Poisoned Objectが成立しても、影響は「配布範囲」と「毒の種類」で決まる。

### 影響分岐A：配布範囲が匿名・広域（共有キャッシュで広く当たる）
- 重要度が上がる（影響ユーザ数が大きい）
- 評価すべきこと
  - 毒が“遷移/参照/設定”に影響していないか（HTML/JSON/3xx）
  - 復旧条件（TTL/パージ）がどうなるか

### 影響分岐B：配布範囲がログイン/特定条件に限定
- 重要度は状況依存だが、ユーザ境界破壊なら重大
- 評価すべきこと
  - キーにCookie/Authorizationがどう扱われているか（例外設計の可能性）
  - 同一テナント内でも権限差（一般/管理）が混線し得るか（ただし断定はログ等が必要）

### 影響分岐C：配布範囲がテナント跨ぎの可能性
- B2Bでは最優先で重大
- 必須根拠
  - Host/Path/Queryの正規化衝突の証拠
  - 共有キャッシュでのキー構成証拠
- 推測で「テナント跨ぎ」と言わない（最も報告品質が問われる）

---

## “安全に”成立根拠を取る（第三者影響を出さない設計）
> Poisoned Object は検証そのものが他者へ影響し得る。実務では「根拠は取るが、拡散はさせない」が最優先。

### 安全策（原則）
- 隔離環境（Lab/ステージング）を優先
- 実環境での検証は
  - 低トラフィックな時間帯
  - 影響が限定されるページ
  - 少数回
  - 可能なら短TTL/パージ可能性の確認
を条件に行う（PTESのリスク管理として明記する）。

### 証跡優先の考え方
- “広く配って証明”ではなく、
  - storeの証拠
  - serveの証拠
  - radiusの証拠
を揃えれば、侵害評価として十分に戦える。

---

## 修正要件（設計・運用・監視：Poisoned Object を潰す現実解）
### 1) キャッシュ可否の原則（デフォルト拒否）
- ユーザ/権限/テナント/経路（Host/Proto等）に依存するレスポンスは共有キャッシュしない
- HTMLは特に保守的に（例外を作るなら仕様化と監視が必須）

### 2) 3xx/4xx/5xx のキャッシュ禁止（原則）
- リダイレクトとエラーは毒になりやすい
- 例外的にキャッシュするなら、キーとTTLと配布範囲を仕様化し、影響を限定する

### 3) キーと正規化の統一（層間一致）
- CDN/Proxy/Originで canonicalization を揃え、衝突/分裂を潰す
- Varyと実際のキー要素の不一致をなくす（監査可能にする）

### 4) unkeyed入力の除去/固定化
- 代理ヘッダや内部ルーティング用ヘッダは外部入力として受け取らない（境界で落とす/上書き）
- レスポンス生成が依存する入力はキーへ含めるか、レスポンスをキャッシュ不可にする

### 5) 監視・検知（再発防止の中核）
- キャッシュ層ログ：hit/miss、key（または構成要素）、bypass理由、object id
- Originログ：受信したHost/path/query、request_id
- これらの相関で「同一キーに異なる生成元レスポンスが格納された」兆候を検知できる

---

## 04_labs（Poisoned Object の“成立根拠”を安全に取る訓練）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/19_cache_poisoning_03_poisoned_object_stored_response/`
- Lab設計要件
  - 構成：共有キャッシュ（Proxy/CDN相当）＋ Origin
  - 変数：
    - cacheable endpoint（キャッシュされる）
    - unkeyed入力（レスポンスに影響、キーに入らない）
    - TTL/再検証（ETag/If-None-Match）
  - 観測点：
    - cache：store/serve、key、object id、hit/miss
    - origin：受信入力（Host/path/query/ヘッダ）
  - 成功条件：
    - “Store/Serve/Radius” の3条件をログで証明できる
    - 影響半径を境界（匿名/ログイン/テナント等）で説明できる

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# Poisoned Object で最重要なのは「格納された」「再利用された」「誰に配られるか」を証拠で揃えること。
# 広く配って証明しない（第三者影響のリスクが高い）。
# 必要な証跡：
# - hit/miss と時間差（可能なら Age 等）
# - cacheログ（store/serve、key、object id）
# - originログ（受け取った入力と request_id）
~~~~

---

## 深掘りリンク（最大8）
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
- `06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
