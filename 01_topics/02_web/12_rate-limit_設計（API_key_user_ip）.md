## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：レート制限が“ログインだけ”や“IPだけ”に偏ると、(1) ブルートフォース/クレデンシャルスタッフィング、(2) OTP/MFA疲労、(3) APIキー悪用、(4) 高負荷での可用性毀損、(5) 例外パス（パスワードリセット/招待/検索/エクスポート）経由の突破、が現実に起きる。さらに、制限が強すぎると正規ユーザを落とし、弱すぎると攻撃を止められない。**“誰を” “どの境界で” “何を単位に”**制限するかが設計課題になる。
  - 満たす：レート制限を「認証」「重要操作」「探索（列挙）」「リソース消費」の4系統に分け、キー（API key / user / IP / tenant / device）を多層で組み合わせる。さらに、段階制御（soft→hard）、例外（信頼経路/バックオフィス）、検知（相関ID/監査ログ）とセットで“運用できる制限”にする。
- WSTG
  - 観点：単に429が返るかではなく、(1) どの単位でカウントされているか、(2) 認証前後で制限が変わるか、(3) エラー/リトライで増幅しないか、(4) 分散回避（IP分散/キー回し/アカウント回し）に耐えるか、(5) “本当に守りたい資産（ログイン/OTP/検索/エクスポート）”に効いているか、を観測して境界を確定する。
- PTES
  - 位置づけ：Vulnerability Analysisで“列挙可能性/総当たり耐性/DoS耐性”を評価し、Exploitationは「現実的な速度で成立するか」「どの回避で突破できるか」を“最小の実験”で示す。Reportingは、レート制限を“設計要件”として（キー設計・閾値・段階制御・例外・監視）まで落とす。
- MITRE ATT&CK
  - レート制限は、攻撃者の “速度” と “ノイズ” を制約する防御。回避（分散・低速化・キー回し）を前提に、(a) アカウント探索、(b) 認証情報攻撃、(c) API乱用、(d) 可用性妨害 の各行為を、検知（ログ/相関ID）と合わせて抑える。
  - ATT&CKへの接続は「何がどれだけの速度で可能か」を観測で固めてから言語化する。

---

## タイトル
Rate Limit 設計（API key / user / IP）
“何を守りたいか”から逆算し、キー設計・閾値・段階制御・例外・監視までを境界として固定する

---

## 目的（このファイルで到達する状態）
- レート制限を “429を返す仕組み” ではなく、**権限境界・信頼境界・可用性境界**として説明できる。
- 次をできるようになる：
  1) 守る対象を4系統（認証/重要操作/探索/リソース消費）に分解できる  
  2) キー（API key / user / IP / tenant / device）を、攻撃者の回避戦術を踏まえて組み合わせ設計できる  
  3) 認証前後、BFF/API、同期/非同期で“どこで制限すべきか”をHop別に決められる  
  4) 閾値・窓・バースト・段階（soft→hard）を、ユーザ体験とセキュリティの両面で言語化できる  
  5) 診断では「回避可能性」「例外パス」「副作用（正規ユーザ巻き込み）」を観測で確定できる

---

## 扱う範囲（スコープ）
- 扱う
  - API key / user / IP を中心としたレート制限の設計（多層キー、閾値、段階制御）
  - 認証前後の境界（匿名→ログイン後）と、重要操作（step-up）との接続
  - 探索（検索/一覧/ID推測）と、重い処理（エクスポート/集計/アップロード等）の制限
  - 例外・運用（バックオフィス、信頼ネットワーク、アラート、監査ログ）
- 扱わない（接続先）
  - ブルートフォース全般：`02_authn_12_bruteforce_rate-limit_lockout（例外パス）.md`
  - API権限伝播：`04_api_01_権限伝播モデル（フロント_バックエンド_ジョブ）.md`
  - ログ設計：`11_logging_tracing_相関IDと証跡設計.md`

---

## 境界モデル：レート制限は「誰を単位に数えるか」と「どこで止めるか」で崩れる
### 1) 資産境界（何を守るのか）
- 認証系
  - ログイン、パスワードリセット、MFA/OTP、回復コード、magic link、招待受諾
- 重要操作系
  - 権限付与、連携追加、支払い/承認、エクスポート、削除
- 探索（列挙）系
  - 検索、一覧、フィルタ、GraphQL、ID推測
- リソース消費系
  - 画像/動画処理、PDF生成、エクスポート、重い集計、メール送信、Webhook送信

### 2) 信頼境界（誰が「同じ利用者」か）
- IPは“利用者”の良い近似である場合もあるが、現実には崩れる：
  - NAT/企業プロキシ/モバイル回線で多数が同一IPになる（正規ユーザ巻き込み）
  - 攻撃者はIP分散できる（回避される）
- user はログイン後には強いが、認証前には使えない
- API key はB2B/API利用では強いが、漏えい/共有/回しで崩れる
- tenant はマルチテナントで必須（他テナントへの巻き込み回避）
- device は補助（偽装され得るが、巻き込み抑止に効くことがある）

### 3) 権限境界（制限の強度を変えるタイミング）
- 匿名（認証前）は強めに、認証後は“ユーザ単位”を主にする
- step-up（再認証/MFA）後は、重要操作に限定して “別枠の制限” をかける（連打対策、疲労攻撃対策）

---

## “キー設計”の中心：API key / user / IP をどう組み合わせるか
### 1) 単一キーの限界（事故が出る型）
- IPのみ
  - 企業/学校/カフェなどで正規ユーザが同時に使うと簡単に誤爆（DoS自己発生）
  - 攻撃者は分散で回避しやすい
- userのみ
  - 認証前に使えない（ログイン/OTPの入口を守れない）
  - アカウント回しで回避される
- API keyのみ
  - 漏えい/共有/テストキー流出で破綻
  - keyを回されると回避される

### 2) 多層キー（現実解：回避と巻き込みを同時に抑える）
- 匿名（認証前）
  - primary：IP（ただし“硬すぎない”）
  - secondary：IP + UA/JA3/Device cookie（可能なら）で補助（同一IP誤爆を軽減）
  - per-endpoint：ログイン/OTP/回復などは別枠で強め
- 認証後（ユーザが確定）
  - primary：user_id（最も意味が安定）
  - secondary：tenant_id（マルチテナントで必須）
  - tertiary：IP（異常検知、分散回避の補助）
- API（B2B/サービス間）
  - primary：api_key（顧客単位、契約単位）
  - secondary：tenant_id（契約テナントと一致させる）
  - tertiary：source_ip（許可リストや異常検知に利用）

### 3) “キーの正規化”がないと回避される
- 同じ利用者でもキーがぶれると、攻撃者は簡単に回避できる
  - 例：X-Forwarded-For の扱いが曖昧 → 任意IP注入で回避
  - 例：IPv6/IPv4や、プロキシ経由の実IPの取り扱いが統一されない
- 結論：IP基準を使うなら「信頼できる境界で確定した client_ip」を使う（アプリ層でヘッダを盲信しない）

---

## 制限の“形”を選ぶ（閾値だけでなく窓・バースト・段階が本体）
### 1) 窓の概念（実務で必要な最低限）
- 短期（秒〜分）：バースト抑止、総当たり速度抑止
- 中期（分〜時間）：探索・列挙の抑止、OTP連打・疲労攻撃の抑止
- 長期（時間〜日）：API乱用、スクレイピング、コスト爆発の抑止

### 2) バーストと平常時を分ける（ユーザ体験のため）
- 例：短時間だけ突発的に増える操作（ページング/検索/画面遷移）を許容しつつ、平均は抑える
- 設計の言語化：
  - “瞬間的にXは許すが、Yを超えると遅延・CAPTCHA・一時遮断へ移行”

### 3) 段階制御（soft→hard）が“運用可能性”を作る
- soft（減速・追加確認）
  - 429で即拒否ではなく、遅延、チャレンジ、追加確認（CAPTCHA/step-up）へ
- hard（拒否・一時ブロック）
  - 連続超過で短時間ブロック、さらに長期でアカウント保護（ロックは慎重）
- 設計のコツ
  - “正規ユーザ救済”の導線（再試行待ち時間表示、サポート/解除フロー）が無いと事故になる

---

## どこで止めるか（Hop別の設計：Edge / BFF / API / Worker）
### 1) Edge（CDN/WAF/LB/Ingress）
- 強い理由
  - 高トラフィックをアプリに入れずに止められる（可用性保護）
- 弱い理由
  - user_id や tenant_id を知らない（匿名前提になりがち）
- 使い分け
  - 匿名の入口（ログイン、OTP、回復、検索の粗い抑止）はEdgeが強い
  - ただし “重要操作” はアプリ/認可判定点で監査ログとセットで止める方が意味が残る

### 2) BFF（フロント専用バックエンド）
- 強い理由
  - ユーザセッションを理解し、UI単位で制限を設計できる
- 弱い理由
  - BFFを迂回してAPIを直叩きされると意味が薄い
- 使い分け
  - BFFだけに依存せず、API側でも同等の制限を持つ（“二重化”が現実解）

### 3) API（権限判定点の近く）
- 強い理由
  - user_id/tenant_id/action を理解した上で制限できる
  - 監査ログ（誰が何をしたか）と結び付けられる
- 弱い理由
  - ここでしか止めないと、上流での負荷遮断ができず可用性が弱い
- 使い分け
  - 重要操作・探索（列挙）・重い処理はAPIで必ず守る

### 4) Worker/Job（非同期）
- 強い理由
  - “処理コスト”の爆発を直接止められる（エクスポート/メール/生成系）
- 弱い理由
  - ユーザの意図と実行の時間がずれる（誤爆しやすい）
- 使い分け
  - “投入時”にも制限、“実行時”にもコスト制限（キュー深さ、同時実行、ユーザ単位）をかけ、相関IDで監査する

---

## 守る対象別：設計の定石（API key / user / IPの使い分け）
### 1) ログイン（認証前/認証後の境界が切り替わる）
- 認証前
  - IP中心＋（可能なら）デバイス/UA補助
  - アカウント探索（存在確認）を抑えるため、失敗応答の差分を減らしつつ速度も抑える
- 認証後
  - user中心（同一ユーザの失敗連打を止める）
- 追加
  - ログイン成功後に「失敗カウンタをどう扱うか」（すぐリセットか、しばらく保持か）を仕様化しないと回避される

### 2) OTP/MFA（疲労攻撃と誤爆の両方が起きる）
- user中心（主体が明確）
- IP補助（同一ユーザへの多元連打の検知）
- 段階制御（連打で拒否＋別チャネル確認/step-up強化）
- 監査ログ（誰が何回挑戦したか）が必須

### 3) APIキー利用（B2B/SDK/自動処理）
- api_key中心（契約単位の公平性）
- tenant中心（顧客・組織境界）
- IP補助（異常/漏えい時の封じ込め）
- 例外：サーバ間通信（mTLS等）なら、IP/証明書主体で強く制限しても誤爆しにくい

### 4) 検索/一覧（探索・列挙の主戦場）
- user中心（ログイン後はここが主）
- tenant中心（他テナントの誤爆回避）
- IP補助（分散回避の検知）
- “APIパラメータ”による増幅（大きいlimit、複雑なfilter）を別枠で制限（コストベース）

### 5) エクスポート/重い処理（コスト境界）
- user/tenant中心＋ジョブ枠（同時実行数/日次回数）
- API key利用なら api_key中心
- Worker側でコスト上限（時間/件数/サイズ）を設け、異常時は打ち切る
- 監査ログ：誰がどの条件で何件出したか（情報漏えいにも直結）

---

## 診断（観測→判断→次の一手）：レート制限を“回避可能性”まで含めて評価する
### 1) 入口（制限があるか）だけで終えない
- 観測するべき事実
  - 429が返るか
  - 返るまでの回数/時間（閾値）
  - どの単位でカウントしているか（IPかuserかkeyか）
  - リセットの条件（時間窓、成功でリセット、別エンドポイントで共有）
- 次に見る
  - 回避可能性：IP分散、アカウント回し、APIキー回し、パス違い（別エンドポイント）で避けられるか

### 2) 例外パス（守っているつもりの穴）
- 典型
  - ログイン本体は強いが、パスワードリセット/招待/OTP開始が弱い
  - BFFは強いが、API直叩きが弱い
  - v1は強いが、v2/旧UIが弱い
- 判断
  - “守る対象の同型操作”が別パスで残っていないかが重要（境界は機能で切る）

### 3) 副作用（正規ユーザの巻き込み）を確認する
- IPのみ制限の誤爆（NAT環境）
- 429がUIで適切に扱われない（無限リトライでさらに悪化）
- モバイル/SDKのリトライが指数バックオフになっていない（増幅）

### 4) ログ/相関（検知できるか）
- 429発生時に
  - trace_id / request_id
  - principal / tenant / ip / api_key（マスク）
  - endpoint / action / decision
  が残り、調査できるか
（接続先：`11_logging_tracing_相関IDと証跡設計.md`）

---

## よくある失敗パターン（実務で刺さる）
1) “ログインだけ”守って満足する（回復/OTP/招待が穴）
2) IP制限だけで企業ユーザを落とす（誤爆で業務停止）
3) 429だけ返してUIが無限リトライ（自爆DoS）
4) “重い処理”に制限がなくコスト爆発（エクスポート/生成/通知）
5) API key を平文表示・ログに混入し二次被害（鍵漏えいで乱用）
6) X-Forwarded-For をそのまま信じてIP回避される（信頼境界の崩壊）
7) 例外（社内IP/管理者）を広げすぎて攻撃者に悪用される（境界の崩壊）

---

## 04_labs（検証環境で“回避と誤爆”を体験して設計に落とす）
- Lab候補（例）
  - `04_labs/02_web/12_rate_limit_01_key_design_api_key_user_ip/`
  - `04_labs/02_web/12_rate_limit_02_login_otp_recovery_exception_paths/`
  - `04_labs/02_web/12_rate_limit_03_cost_based_limits_export_generation/`
- Lab設計要件
  - 同一IP（NAT相当）で複数ユーザが操作する状況を再現できる（誤爆の体感）
  - IP分散・アカウント回し・キー回しの“回避”を再現し、どのキー設計が効くか比較できる
  - 429時のUI挙動（リトライ/バックオフ/待ち時間表示）が確認できる
  - 監査ログ/相関IDが残る（調査可能性の体感）

---

## コマンド/例（例示は最小限：設計と判断を優先）
~~~~
# 観測のポイント（診断/運用共通）
# - 429の有無だけでなく、閾値・窓・単位（IP/user/api_key）を確定する
# - 回避（IP分散/回し）と誤爆（NAT）を同時に評価する
# - 重要操作/重い処理はAPI/Worker側で必ず制限し、監査ログで追えるようにする
~~~~

---

## 深掘りリンク（最大8）
- `01_topics/02_web/02_authn_12_bruteforce_rate-limit_lockout（例外パス）.md`
- `01_topics/02_web/11_logging_tracing_相関IDと証跡設計.md`
- `01_topics/02_web/10_authn_to_authz_接続（claims_権限伝播）.md`
- `01_topics/02_web/03_authz_06_privileged_action_重要操作（承認_送金_権限）.md`
- `01_topics/02_web/02_authn_16_step-up_再認証境界（重要操作_再確認）.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_02_graphql_境界（schema_introspection_query_cost）.md`
- `01_topics/02_web/04_api_06_idempotency_レースと二重実行境界.md`
