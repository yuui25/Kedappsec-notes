## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - この技術で満たす/破れる点：
    - 「デシリアライズ＝入力の復元」は、実装上ほぼ必ず **“型選択（どのクラス/型として復元するか）”** を含む。ここが“入力→実行”境界になる。
    - 破綻は、(1) 型ヒント（@type/$type/__type 等）を受け付ける、(2) DefaultTyping/TypeNameHandling 等で“外部入力から型が変えられる”、(3) 例外パスでブラックリスト回避、(4) 復元後に危険APIへ到達（テンプレ/SQL/コマンド/URLフェッチ）が典型。
- WSTG
  - 該当テスト観点：
    - 入力処理（JSON）の「型・構造・境界」テスト（予期しない型、深いネスト、巨大配列、未知フィールド、型ヒント）を通じて、復元ロジックの制御点と例外挙動を確定する。
- PTES
  - 位置づけ：
    - 情報収集：JSONを受け付ける面（REST/GraphQL/内部API/Webhook/ジョブ）と、パーサ/フレームワークを推定。
    - 脆弱性分析：型ヒント・ポリモーフィズムの設定、復元先の型（interface/abstract/base class）、検証点（validation前後）、例外露出をモデル化。
    - 侵害評価：RCEに短絡せず、まず「入力で型が変えられる」→「危険なsinkへ到達する」までを成立根拠として固める。
- MITRE ATT&CK
  - 初期侵入：T1190（公開アプリの脆弱性悪用）
  - 実行/影響への接続（成立条件つき）：
    - 型選択を操れると、復元後のオブジェクトが“別の処理経路（テンプレ評価/URLフェッチ/ファイルアクセス）”へ流れ、SSRF/情報漏えい/DoS、場合によりRCEに接続する。

---

## タイトル
JSONデシリアライズ（ポリモーフィズム/型ヒント）：型選択が“入力→実行経路”を切り替える境界

---

## 目的（このファイルで到達する状態）
- 「JSONはただの文字列」ではなく、実装では **型（class/type）とオブジェクトグラフを復元する** ため、入力が処理経路を切り替える点（境界）を説明できる。
- 次の4点を、診断で“差分＝成立根拠”として固められる。
  1) 型ヒントが有効か（外部入力で型が変わるか）
  2) 復元先がポリモーフィックか（interface/abstract/base class か）
  3) 検証（validation/allowlist）が型選択の前にあるか後にあるか
  4) 復元後にどのsinkへ流れるか（テンプレ/URL/FS/コマンド/SQL/ロジック）
- 報告として「RCEの可能性」だけで曖昧にせず、**構造欠陥（型選択が外部入力に開放）** と **到達可能な影響（SSRF/情報漏えい/DoS/権限逸脱）** を分けて書ける。

---

## 扱う範囲（このファイルの守備範囲）
- 本ファイル：JSONの **ポリモーフィズム（型選択）** と **型ヒント（type hint）** に集中
  - 例：`@type` / `$type` / `__type` / `type` / `class` 等のフィールドで型が指定される設計
  - 例：DefaultTyping/TypeNameHandling/AutoType のような“機能で型が外部入力に開放される”設計
  - 例：Map/Any/Object など “復元先が曖昧” で後段が動的ディスパッチする設計
- 直接は扱わない（ただし接続は書く）：
  - YAML/XMLのデシリアライズ（別ファイル）
  - 具体的ガジェットチェーンや実行ペイロードの列挙（本プロジェクトでは“成立条件”と“境界”が主）
- 接続先：
  - `05_input_13_deserialization_02_yaml（anchors_tags）.md`
  - `05_input_13_deserialization_03_xml（object_mapping）.md`
  - `05_input_09_ssrf_*`（復元後にURLフェッチへ到達する場合）
  - `05_input_01_入力→実行境界（テンプレート注入_SSTI）.md`（復元後にテンプレ評価へ到達する場合）

---

## 境界モデル（JSON→オブジェクト復元は“型の決定”を含む）
### 1) データフロー（最小モデル）
Request JSON
→ Parser（JSON構文解析：トークン化）
→ Binder（データバインディング：オブジェクト復元）
→ Domain（業務ロジック：検証/整形/保存）
→ Sink（テンプレ/URL/FS/SQL/コマンド/キュー…）

本質：
- 危険なのは Parser ではなく、多くの場合 Binder（復元）で起こる。
- Binderは “型を決める” 行為であり、型が変わると **コンストラクタ/セッター/デシリアライズフック** が変わり、実行経路が変わる。

### 2) 3つの境界（資産/信頼/権限）
- 資産境界：
  - 復元したオブジェクトがどの“資産”に紐づくか（テンプレ、Webhook設定、通知先URL、認可ポリシー）
- 信頼境界：
  - JSONが外部入力か（公開API/フロント）／内部入力か（ジョブキュー/イベント/連携）
  - “内部だから安全”が崩れる典型：Webhook受信、SaaS連携、ログ/設定のimport、管理画面の一括登録
- 権限境界：
  - 型選択ができると、業務上の「許可された表現」から外れたオブジェクトを作り、認可/検証を迂回し得る
  - 例：本来は `NotificationEmail` しか許可しないのに、`NotificationWebhook` 相当へ切替が可能、等

---

## 用語の整理（現場で混乱しやすい点を先に固定）
- ポリモーフィズム（polymorphism）：
  - 同じ“基底型”に対して、複数の具体型が存在する設計（例：`Shape`→`Circle`/`Square`）
  - JSON復元では「どの具体型として作るか」を決める必要がある
- 型ヒント（type hint / type discriminator）：
  - JSON中のフィールドやメタ情報により、具体型を指定・推定する仕組み
  - 例：`{"type":"circle", ...}` のような discriminator は“設計として正当”
  - 一方 `{"@type":"com.example.SomeClass", ...}` のように “クラス名/型名を外部入力が直接指定”できる設計は危険になりやすい
- “危険な型ヒント”と“安全なdiscriminator”の差：
  - 安全：アプリが定義した **短い識別子（allowlist）** → 内部で型へマップ
  - 危険：外部入力が **任意の型名（クラス名/アセンブリ名）** を指定できる

---

## 破綻パターン（差分＝成立根拠として使う）
### パターンA：型名を外部入力が直接指定できる
- 兆候：
  - `@type` / `$type` / `__type` / `class` など、型を示すキーが存在
  - エラーに「型が見つからない」「型解決に失敗」「許可されない型」等の文言が出る
- 成立根拠の取り方（安全寄り）：
  - “存在しない型名”を与えたときのエラー差分で、型解決が動いていることを確定する
  - “許可された型のみ通る”なら allowlist がある可能性、等

### パターンB：復元先が曖昧（Object/Any/Map）で、後段が動的に分岐する
- 兆候：
  - 受け口が `Object` / `Any` / `Map<String, Object>` 的
  - 復元後に “キーがあるかどうか” で処理が分岐（if文の塊）
- リスク：
  - 型ヒントが無くても、後段の分岐で “テンプレ評価” “URLフェッチ” “式評価” のような sink に入り得る
  - ＝本質は「型ヒント」だけでなく「動的ディスパッチの設計」

### パターンC：検証（validation）が型選択より後にある
- 兆候：
  - 型により“検証コードが変わる”、または“検証が呼ばれない型がある”
  - 例：想定型はvalidateされるが、別型はvalidateが未実装
- リスク：
  - “検証で守っているつもり”でも、型を変えると素通りする

### パターンD：例外パス（エラー処理）で別のデシリアライズが走る
- 典型：
  - 失敗時に “ゆるい復元”（Map/Any）へフォールバック
  - 互換性のために複数フォーマットを受け付ける（旧版→新版）
- リスク：
  - 強いパスは守れていても、フォールバックが穴になる

---

## 影響（RCEに短絡せず、現実に起きるゴールへ分解）
> 実務では「RCE」より先に、設定改ざん・SSRF・情報漏えい・DoSが現実的に発生する。

### 影響1：SSRF（復元後にURL/HTTPクライアントへ到達）
- 例：通知先、Webhook、画像取得、プレビュー、外部連携
- ポイント：
  - “型が変わる”＝“HTTPフェッチ機能を持つ型へ切替” が成立し得る

### 影響2：認可・業務ロジック逸脱（型で権限境界を越える）
- 例：ユーザ入力が `UserProfileUpdate` のはずが、`AdminSettingUpdate` 相当の型に寄る
- ポイント：
  - 認可が“エンドポイント”にしか掛かっていないと、同一エンドポイント内で型により機能が増える

### 影響3：情報漏えい（例外/ログ/構造露出）
- 型解決エラーが、内部クラス名、パス、ライブラリ名、スタックを露出する
- これは後段の攻撃面（フレームワーク特定、CVE探索）に直結する

### 影響4：DoS（深いネスト、巨大配列、再帰構造）
- 型ヒントが無くても成立するが、ポリモーフィズムは “作られるオブジェクトの量/複雑さ” を増やしやすい
- 例：深いネスト、巨大な配列、極端な文字列長、型変換例外の連打

---

## 観測ポイント（どこを見れば“型選択が動いている”と確定できるか）
### 1) HTTP/エラーで見えるもの（外部から確定しやすい）
- エラーメッセージの語彙：
  - “type id” “polymorphic” “cannot resolve subtype” “TypeNameHandling” “DefaultTyping” “AutoType”
- ステータス差分：
  - 400（バリデーション） vs 500（バインディング例外）で境界位置を推定できる

### 2) レスポンス構造（成功時の“反映のされ方”）
- 入力した `type` が保存・反映されるか（discriminatorが業務データとして残るか）
- 出力（GET）のJSONに `type` / `@type` が戻るか（往復でヒントが見える）

### 3) サーバログ/監査（可能なら依頼する：価値が高い）
~~~~
request_id
endpoint / handler
deserializer (library)
target_type (base type)
resolved_subtype (if any)
type_hint_key (if any)
validation_phase (pre|post)
error_class (binding|validation|domain)
reject_reason (rule_id)
payload_size / max_depth / max_array_len
~~~~
- “resolved_subtype” が取れると、診断の確度が一気に上がる（成立根拠が明確）

---

## 検証設計（意味→判断→次の一手：安全な差分で確定する）
> ここは「危険ペイロード」ではなく「型選択の有無」を確定するための差分セット。

### 差分セットJ1：型ヒントキーの存在確認（@type/$type等）
- 目的：型解決が走るかどうかを、エラー差分で確定
- 判断：
  - 型解決エラーが出る → 型ヒント経路が存在
  - 無視される/単に未知フィールド扱い → discriminator設計（allowlist）か、型ヒント無効の可能性

### 差分セットJ2：discriminator（安全な識別子）型か、型名直指定型か
- 目的：設計として安全なパターンか、危険なパターンかを分類
- 判断：
  - `type: "circle"` など短い値で、未知値が拒否される → allowlistの可能性
  - `type: "Namespace.Class, Assembly"` 等の“型名”が通る → 外部入力で型名指定が可能（高リスク）

### 差分セットJ3：復元先の基底型（interface/abstract）推定
- 目的：ポリモーフィズムの土台があるか
- 方法（安全寄り）：
  - 既存の正当リクエストから、どのフィールドが“派生型ごとに違う”かを観測
  - エラー文面に“base type / abstract type”が出るかを見る
- 判断：
  - “subtype” “base type” が出る → ポリモーフィズムの根拠

### 差分セットJ4：検証がどこで走るか（pre/post）
- 目的：型選択→検証の順序を確定
- 方法：
  - 同じ構造で “型だけ違う” 入力が可能な場合、バリデーションエラーの有無を比較
- 判断：
  - 型によりvalidateが抜ける/変わる → 重大（設計欠陥）

---

## 実務での“狙いどころ”（攻撃寄りだが、判断は境界条件で）
### 1) 管理者機能に見える“インポート/テンプレ/設定”は最優先
- JSONインポート、Webhook設定、通知設定、ワークフロー定義、権限ポリシー編集
- 理由：型が変わると “機能そのもの” が変わりやすい（impactが大きい）

### 2) 非同期（キュー/ジョブ）に流れるJSONは危険度が上がる
- 理由：
  - 入力が“内部扱い”され、検証が弱くなりがち
  - 失敗時のログ露出が増える

### 3) “互換性対応”があるAPIは穴になりやすい
- v1/v2互換、旧形式フォールバック、複数のデシリアライズ経路

---

## 防御（設計としての優先順位：型選択を外部入力から切り離す）
### 1) 型名直指定を禁止し、discriminatorは allowlist にする
- “外部入力が型名を指定できない”が原則
- 実装方針（概念）：
  - `type` 値 → 内部の固定マッピング（switch/map）で型を選ぶ
  - 未知 `type` は拒否（安全な失敗）

### 2) DefaultTyping / TypeNameHandling / AutoType 等の危険機能を無効化
- “便利機能”が境界を壊すことがあるため、プロジェクト標準で禁止・CIで検知する

### 3) 検証は型選択“前後”で二段にする
- pre：サイズ/深さ/必須キー/許容キー
- post：復元後のドメイン検証（不変条件・権限境界）

### 4) 例外はサニタイズし、型情報・スタックを返さない
- 例外露出は“フレームワーク特定→弱点探索”の導線になる

### 5) リソース制限（DoS対策）をJSONパーサ層で
- max_depth、max_array_len、max_string_len、max_total_bytes を明示

---

## 次に試すこと（仮説A/Bで分岐）
### 仮説A：discriminatorはallowlistで、型名直指定は不可（比較的健全）
- 次の一手：
  - “型が変わると機能が増える”設計になっていないか（認可・業務境界）を確認
  - 例外パス/互換フォールバックが穴になっていないかを確認（J4）

### 仮説B：型名直指定または危険機能が有効（高リスク）
- 次の一手（安全側での詰め方）：
  - 型選択が可能な範囲（どの入力点で有効か、どの権限で到達するか）を整理
  - 復元後のsink（URLフェッチ/テンプレ/FS/設定反映）を特定し、影響を“具体的な業務機能”として報告に落とす
  - 実害評価は「RCE再現」より「境界欠陥（型選択開放）＋到達可能sink」を優先（実務で通る）

---

## 手を動かす検証（Labs：再現は“境界”中心で）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/13_deserialization_json_polymorphism_typehint/`
- Lab設計要件
  - 3パターンを作り、差分で理解できること：
    1) 安全：discriminator allowlist（短いtype→内部マップ）
    2) 危険：型名指定（@type等）で外部から型解決
    3) 危険：Any/Map復元＋後段動的ディスパッチ（型ヒントなしでもsinkへ）
  - ログに `resolved_subtype` / `validation_phase` / `reject_reason` を残す

---

## コマンド/リクエスト例（例示は最小限・意味中心）
~~~~
# 例：安全なdiscriminator設計（概念）
# 入力: {"type":"email", "to":"a@b", "body":"..."}
# 内部: if type=="email" -> NotificationEmail
#      else if type=="webhook" -> NotificationWebhook
#      else reject

# 例：危険な設計（概念）
# 入力が型名を直接指定できる（@type/$type等）
# -> 外部入力で復元クラスが変わる = 入力→実行経路の切替点
~~~~

---

## 深掘りリンク（最大8）
- `05_input_13_deserialization_02_yaml（anchors_tags）.md`
- `05_input_13_deserialization_03_xml（object_mapping）.md`
- `05_input_09_ssrf_01_reachability（internal_localhost_metadata）.md`
- `05_input_09_ssrf_06_parser_differential（url_parse_smuggling）.md`
- `05_input_01_入力→実行境界（テンプレート注入_SSTI）.md`
- `05_input_05_command_injection_01_shell（metachar_pipeline）.md`
- `04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `03_authz_01_境界モデル（オブジェクト_ロール_テナント）.md`
