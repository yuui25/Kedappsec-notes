## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：キャッシュキーに入らない入力（unkeyed input）がレスポンス生成に影響すると、攻撃者が“特定条件のレスポンス”をキャッシュへ格納し、他者へ配布できる。これは認証・認可が正しくても「キャッシュが境界を破る」形で情報露えい・誤配布・混線を生む。
  - 満たす：レスポンスに影響する入力（Host/Proto/Path/Client属性/言語/圧縮/内部ルーティング等）を体系的に棚卸しし、(1) キーへ含める、(2) キャッシュ不可にする、(3) 正規化して差分を潰す、のいずれかへ落とす。特に“代理ヘッダ（X-Forwarded-* 等）”“内部ルーティング用ヘッダ（X-Original-URL 等）”は危険側に倒して扱う。
- WSTG
  - 観点：Cache Poisoningは「入力→出力」だが、中継点（CDN/Proxy）のキーとオリジン処理がズレることで成立する。本ファイルは “unkeyed（キーに入らないのに効く入力）” を、観測（Hit/Miss、ヘッダ、ログ相関）で特定し、成立根拠を作る。
- PTES
  - 位置づけ：脆弱性分析〜侵害評価。実環境では第三者影響が出やすいので、(1) Keying確定、(2) Unkeyed候補の安全な絞り込み、(3) 影響半径の最小化（隔離/短TTL/低頻度）を前提に、証跡ベースで所見化する。
- MITRE ATT&CK
  - T1190（公開アプリ脆弱性悪用）に接続し得るが、本ファイルの焦点は “成立根拠の作り方”。
  - Impact：不正コンテンツ配布、ユーザ混線、サービス劣化に接続し得る（条件付き）。
  - Defense Evasion：キャッシュが原因だと、監査・再現性が落ち、検知・追跡が難化する。

---

## タイトル
Cache Poisoning（Unkeyed）：キーに入らない入力（ヘッダ/パラメータ）がレスポンスを変えると、攻撃者は“他者に配るレスポンス”を作れる

---

## 目的（このファイルで到達する状態）
- 「キー（Keying）は分かった」次に、**キーに入っていないのにレスポンスへ影響する入力（unkeyed）** を安全に特定できる。
  1) unkeyed候補の“体系”を持ち、闇雲に試さない
  2) 影響の種類（表示差/リンク差/リダイレクト差/エラー差/キャッシュ制御差）を分類できる
  3) 成立根拠（unkeyedでレスポンス差 + キャッシュ格納/再利用）を証跡で取れる
  4) 第三者影響を最小化しながら、侵害評価（誰に影響するか）へ繋げられる
  5) 修正要求を「キーへ含める/キャッシュ不可/正規化/入力無視」の設計要件で提示できる

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：unkeyed input（headers_params）でのキャッシュ汚染“入口”
  - ヘッダ：代理ヘッダ、内部ルーティング、表現（言語/圧縮/UA）、CORS/Origin周り など
  - パラメータ：無視される/正規化されるクエリ、フレームワークの特殊パラメータ など
  - 観測：Hit/Miss、レスポンス差分、ログ相関、層の切り分け
- 扱わない：格納後の拡散・攻撃連鎖（別ファイル）
  - poisoned object（stored response配布の評価）：`05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
  - keyingの確定：`05_input_19_cache_poisoning_01_keying（vary_normalization）.md`

---

## 前提：Unkeyedの本質は「レスポンス依存入力」と「キー」の不一致
### 定義（実務で使える形）
- unkeyed input ＝ **レスポンスに影響するが、キャッシュキーに含まれていない入力**
- 必要条件（3点セット）
  1) キャッシュされる（または再利用される）レスポンスである
  2) そのレスポンスが、ある入力で変化する
  3) その入力がキーに入っていない（＝別入力でも同じキャッシュが返る）

### 重要：Unkeyedは「危険入力」ではなく「危険な不一致」
- 同じヘッダでも、キーに入っていれば unkeyed ではない。
- 逆に、無害そうなヘッダでも、レスポンスを変えるのにキーに入っていなければ危険になる。

---

## 境界モデル（Unkeyedが破る“誰に何が配布されるか”）
- 境界B1：ユーザ境界（ログイン/個人化）
- 境界B2：テナント境界（subdomain/org_id）
- 境界B3：機能境界（/admin/設定/エクスポート）
- 境界B4：表現境界（言語/圧縮/デバイス）
- 境界B5：経路境界（http/https、ホスト、内部ルーティング、パス正規化）
Unkeyedが触るのは主に B4/B5 だが、B1/B2/B3へ波及すると重大性が跳ね上がる。

---

## Unkeyed候補の体系（ヘッダ編：現実の構成で刺さる順）
> “全部試す”は禁止。まず「どの層が何に依存していそうか」で絞る。

### 1) 代理/経路ヘッダ（Reverse Proxy配下で最優先）
- 目的：オリジンが “実URL/実スキーム/実ホスト/実クライアント” を再構成するために使う
- 代表カテゴリ（名前は実装差があるので“カテゴリ”で捉える）
  - 実ホスト再構成：Forwarded / X-Forwarded-Host 系
  - 実スキーム再構成：Forwarded / X-Forwarded-Proto 系
  - 実IP再構成：X-Forwarded-For / True-Client-IP 系
  - 内部URL再構成：X-Original-URL / X-Rewrite-URL / X-Forwarded-Uri 系
- 典型的なレスポンス影響（観測すべき差分）
  - 絶対URL（リンク、OGP、Location、フォームaction）の生成差
  - http↔httpsの切替差（Mixed Content、リダイレクト、Cookie属性）
  - “内部ルーティングの切替”（別エンドポイント扱い）
- Unkeyedになる条件
  - それらヘッダがキャッシュキーに入っていないのに、HTML/JSONの内容（リンク/リダイレクト等）が変わる

### 2) 内部機能フラグ系（機能/表示が変わるが、キーに入らない）
- 例（カテゴリ）
  - A/Bテスト、段階ロールアウト、実験フラグ（ヘッダやCookieで切替）
  - デバイス/アプリ種別（UAや独自ヘッダで切替）
  - Geo/言語（Accept-Language、国判定ヘッダ、CDN由来ヘッダ）
- 典型的なレスポンス影響
  - HTMLの差分（リンク先、スクリプト読み込み、フォーム先）
  - JSONのフィールド差分（フラグ値、URL、リソース）
- Unkeyedになる条件
  - 変化軸がVaryにない、またはCDNが独自キーだが不完全で衝突する

### 3) CORS/Origin系（APIで事故りやすい）
- Origin / Access-Control-* 反映がレスポンスヘッダを変える
- Unkeyedになると
  - 本来別Origin向けのCORSレスポンスが混線（誤許可/誤拒否）し得る
- 注意：ここは誤判定が起きやすいので、まず keying（Vary: Origin）とキャッシュ可否を固める

### 4) 圧縮/転送表現（Accept-Encoding等）
- 多くは Vary: Accept-Encoding で分離されるべき
- もし分離されない/変換層で崩れると、内容が壊れたり誤配布が起きる（ただし実害評価は慎重に）

---

## Unkeyed候補の体系（パラメータ編：キーに入らない/無視されるQuery）
### 1) “無視される”パラメータ
- アプリがパラメータを無視していても、**中継点がキーに含める/含めない** の差が事故要因になる
- Unkeyedは「無視される」より、「レスポンスを変えるのにキーに入らない」方が本命

### 2) “正規化される”パラメータ（順序/重複/空値など）
- Keying側が正規化で同一視し、Origin側が意味として扱うと衝突する（01_keyingと接続）

### 3) フレームワーク/ゲートウェイ特有の特殊パラメータ（カテゴリ）
- ルーティングに影響する（rewrite/locale/format 等）
- 表示やテンプレ切替に影響する（theme/variant 等）
- これらがキーに入らないと “別表示が同一キー” になる

---

## Unkeyedを“観測で確定”する（薄い所見にしないための必須手順）
> 目的は「unkeyedでレスポンスが変化し、その結果がキャッシュ再利用される」を証跡化すること。

### 0) 安全策（最優先）
- 第三者影響が出る可能性があるため、原則は
  - Lab / ステージング / 許可された隔離環境
  - 影響が限定されるエンドポイント（静的に近い/低リスク）
  - 少数回で証跡重視
- 実運用で“配布”が疑われる検証は、必ず合意と範囲の明確化を先に行う（PTES的な前提）。

### 1) キャッシュが効いている層を確定（Hit/Missの“証拠”を取る）
- レスポンスヘッダ（Cache-Control/Vary/Age等）
- 1回目/2回目の時間差
- 可能ならキャッシュ層ログ（hit/miss、bypass理由）
- ここで曖昧なら、unkeyed探索に進まない（全部が揺れる）

### 2) 差分は1軸だけ（unkeyed候補ヘッダ/パラメータを1つずつ）
- “同じURL・同じ条件”で、対象の入力だけ変える
- 変わるべき観測点（例）
  - HTML内の絶対URL（scheme/host）
  - Location（リダイレクト先）
  - 参照する静的ファイル（script/link）
  - JSONのURLやフラグ
- ここで「レスポンスが変わる」をまず確定する（unkeyedの前半）

### 3) “キーに入っていない”ことを証跡化
- 同じURLで、入力を変えても **同一のキャッシュが返る** 兆候を取る
  - Hit/Missが同じ（ヒット継続）
  - Ageが進む（同一オブジェクトを再利用）
  - あるいはログ上で同一キー扱い
- 重要：レスポンス差があるのに、キャッシュ再利用される（衝突）なら危険度が上がる

### 4) 層間差を切り分け（CDN/Proxy/Originのどこが原因か）
- 可能なら
  - cacheログ：キー構成要素
  - originログ：受信したHost/path/query/代理ヘッダ
- “入力がどこで解釈され、どこでキー化されていないか”が所見の芯になる

---

## 観測シグナル（Unkeyed特化：次に何を取るべきか）
### シグナルU1：ヘッダでHTMLの絶対URL/Locationが変わる
- 解釈：経路再構成（Host/Proto/URL）に依存している
- 次の一手：そのヘッダがキーに入っているか（Vary/ログ/Hit継続）を確定

### シグナルU2：言語/UAでHTML断片やJS参照が変わるが、Varyがない
- 解釈：表現差の衝突リスク
- 次の一手：CDNが暗黙にキーへ入れていないか（ログ/ベンダ仕様）を確認し、衝突の証拠を取る

### シグナルU3：Originはヘッダを受け取っているが、キャッシュ層はキーへ入れていない
- 解釈：層間不一致（設計欠陥）で、unkeyed成立条件が揃っている
- 次の一手：影響半径（誰に配布され得るか：ユーザ/テナント/匿名）を評価し、`03_poisoned_object` へ接続

---

## 実害評価（攻撃寄り：ただし“分岐”で評価し、推測しない）
Unkeyedが成立しても、実害は「何が変わるか」で変わる。

### レベル1：表現差（UX差）止まり
- 例：言語や圧縮差の軽微な混線
- 所見：設計不整合として改善提案（重大度は状況依存）

### レベル2：リンク/遷移/参照資源が変わる
- 例：絶対URL、リダイレクト、script/linkの参照先
- 所見：誤誘導・誤配布の可能性。配布範囲（匿名/ログイン/テナント内）を確定する。

### レベル3：境界（ユーザ/テナント/機能）に触れる
- 例：テナント識別に関わるHost/パスが混線、管理系ルーティングが混線
- 所見：重大。認可以前に“配布層で境界が壊れている”ため、優先修正。

---

## 修正（設計要件：unkeyedを潰す4つの手段）
### 1) キーへ含める（Vary/キー構成の修正）
- レスポンスに影響する入力はキーへ含める（ただしVary過多で運用崩壊しない設計が必要）

### 2) キャッシュ不可にする（最も確実な止血）
- ユーザ依存/テナント依存/経路依存があるレスポンスは原則キャッシュしない
- 特にHTMLや管理/設定/エクスポート周辺は保守的に扱う

### 3) 入力を無視/固定化（Origin側）
- 代理ヘッダ等を“信頼境界”で固定（フロントからのみ受け付け、外部からの注入を無視）
- 内部ルーティング用ヘッダは外部入力として扱わない（境界で落とす）

### 4) 正規化ルールを層間で一致させる
- CDN/Proxy/Originで canonicalization の順序と規則を統一し、衝突/分裂を潰す

---

## 04_labs（Unkeyedの再現：事故らず“成立根拠”を取る練習）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/19_cache_poisoning_02_unkeyed_headers_params/`
- Lab設計要件
  - Proxyキャッシュ（キー構成が見える）＋Origin（受信ヘッダが見える）
  - unkeyed候補をカテゴリ別に用意
    - 経路再構成（Host/Proto/URL）
    - 表現差（言語/UA）
    - CORS（Origin）
  - 目的：unkeyedの「3条件（キャッシュ/レスポンス差/キー不一致）」をログで証明できること

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# Unkeyedは第三者影響が出やすい。
# やるべきことは「入力を増やす」ではなく、
# 1) キャッシュ層の確定（hit/miss）
# 2) 1軸差分でレスポンス差の確定
# 3) その差分がキーに入っていない証拠（同一オブジェクト再利用）
# 4) 層間不一致（cache vs origin）の証跡化
~~~~

---

## 深掘りリンク（最大8）
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
- `06_config_01_CORSと信頼境界（Origin_資格情報_プリフライト）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
