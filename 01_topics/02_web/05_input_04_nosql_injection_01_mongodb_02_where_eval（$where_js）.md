## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK）

- ASVS
  - 満たす/破れる点（このファイルの主眼）
    - 入力→実行境界：ユーザ入力が「DB内のコード評価（JS）」に到達する設計が存在しないか（最優先で排除）
    - 防御の優先順位：ブラックリスト/エスケープではなく **機能無効化・API禁止・allowlist設計** を採用しているか
    - 例外/エラー：$where の構文/実行エラーを返さない（oracle化防止）＋内部例外のログ相関
    - 最小権限：DBユーザ権限・ロール（アプリ側）と、DB設定（サーバ側）で爆発半径を縮める
    - 監査：$where / $function / script を含むクエリの監視、異常頻度・遅延・スキャン傾向の検知
- WSTG
  - Injection testing として、SQLiの“コード注入”に近い位置づけで扱う（NoSQLiの中でも高危険度）
  - エラー誘発よりも「入力形式→クエリ構造→遅延/件数」の差分観測で成立根拠を取る（安全配慮）
- PTES
  - Vulnerability Analysis：入口（filter/where）→クエリ生成点→$where到達条件（成立根拠）→影響（認可境界/DoS）を評価
  - Exploitation：影響実証は必要最小限（DoSになりやすいので、過度な遅延や重い条件を避ける）
  - Reporting：根本原因を「$whereを許可する設計」「汎用フィルタを直渡し」「機能無効化不足」「監査不足」に分解して提示
- MITRE ATT&CK
  - TA0001 Initial Access（公開アプリ入口）/ TA0009 Collection（条件改変で収集）/ TA0005 Defense Evasion（エラー統一下でブラインド化）
  - 実装次第で “コード評価” が絡むため、攻撃面としては強い（ただし本リポジトリでは悪用手順ではなく境界モデル化）

# NoSQL Injection（MongoDB）：$where_eval（$where_js）

## 目的（この技術で到達する状態）
- MongoDB の `$where`（JS評価）を、NoSQLi の中でも別格の「入力→コード評価」境界として切り出し、
  1) 入口（入力形式）と到達条件（どのAPI/どのマージ処理で$whereが混入するか）を特定できる  
  2) 成立根拠（oracle：件数/長さ/遅延/エラー）を安全に取れる  
  3) 影響（認可境界の崩壊、過負荷、監査回避）を“推測”でなく設計として説明できる  
  4) 修正を「サニタイズ」ではなく **$where禁止（機能の排除）** と **安全な代替（式/演算子の限定）** に落とせる  
  状態になる。

## 前提（対象・範囲・想定）
- 対象
  - MongoDB を使うWeb/APIで、`filter` / `where` / `query` のような「汎用条件」を受け取る設計
  - 管理画面・検索API・ログ閲覧・可視化ダッシュボード等（柔軟検索が欲しくなる領域）
- 成立しやすい構造
  - ユーザ入力JSONをそのまま find 条件へ渡す
  - 既定条件（tenant/owner 等）とユーザ条件を “同階層マージ” している
  - “Mongoクエリをそのまま受ける” 仕様（内部ツールに多い）
- 本ファイルの焦点
  - `$where` / JS評価の成立根拠と防御設計
- 非スコープ（別ファイル）
  - 集約パイプライン（pipeline）、BSON型混乱など

## $where を「特別扱い」する理由（差分＝成立根拠）
- `$ne/$gt/$regex` は “クエリ演算子の注入” だが、`$where` は **JSコード評価** の側面がある
- したがって優先順位が変わる
  - まず “使わせない（禁止/無効化）” が原則
  - 次に “もし残るなら監査・制約・隔離” が必須
- 実務的な危険性（推奨の説明軸）
  - 認可境界（tenant/owner）と同じ場所で条件が評価される → 越境混入に繋がりやすい
  - 評価が重い → DoS/遅延が起きやすい（PTでは特に安全配慮）
  - エラーが出ると oracle になりやすい

## 観測ポイント（入力→クエリ構造→評価→反応）

### 1) 入口を確定する：$where を“どこから混入できるか”
- 典型入口（優先して疑う）
  - `filter` パラメータ（JSON文字列）をパースしてMongo条件にする
  - `where` パラメータ（文字列/JSON）をそのままクエリへ渡す
  - 画面側で“詳細検索”として条件式を受ける
- 入口確定の観測
  - Content-Type（json/form/query）によって混入可否が変わる
  - “同じ入力点”でも、特定のモード（advanced=true 等）でだけ混入する（実装分岐の兆候）
- 判断（次の一手）
  - 入口（どのパラメータがクエリ構造に変換されているか）を最優先で確定し、以後の検証はそこに固定する

### 2) 差分（oracle）指標を固定する（安全に確定する）
- Boolean oracle（推奨）
  - 結果件数、レスポンス長、表示要素数、ページネーション、特定レコードの有無
- Time oracle（補助、短時間・少回数）
  - $where は評価コストが差分になり得るが、DoSに近づく  
    → 実務では「短い遅延」「少回数」「他指標との併用」を原則にする
- Error oracle（補助）
  - 構文/参照エラーが返る場合は “DB評価到達” の補助証拠になるが、レポート上は **情報漏えい（例外モデル）** としても扱う

### 3) $where が混入する“境界破壊の型”を3分類で整理する（原因特定に直結）

#### 型A：ユーザ入力が `$where` キーを直接作れる（構造注入）
- 例：ユーザが `{ "$where": "..." }` を作れる経路がある
- 根本原因
  - クエリ構造を入力にさせている（allowlist不在、スキーマ検証不在）
- 修正の方向
  - `$` で始まるキーを禁止（ただしブラックリストに依存しすぎない）
  - 受理するフィールド/演算子をallowlist化し、アプリ独自DSLから生成する

#### 型B：既定条件とユーザ条件のマージが危険（同階層 merge / deep merge）
- 例：`base = { tenant_id: X }` と `userFilter` を同階層で混ぜる
- 根本原因
  - “権限条件” と “検索条件” が同じ構造で扱われ、上書き/混入が起きる
- 修正の方向
  - 既定条件は固定し、ユーザ条件は “安全に生成したサブ条件” としてAND結合する（入力オブジェクトを直接混ぜない）

#### 型C：文字列の “評価機構” に流れている（whereStringを評価）
- 例：詳細検索で `where="..."` のような条件式を受ける
- 根本原因
  - 機能要件が “評価” を必要としている（設計起因）
- 修正の方向
  - 文字列式ではなく、安全なDSL（eq/gt/contains 等）に落とし、サーバでクエリ生成する

## 結果の意味（何が言える/言えない）

### 言える（確定できる）
- $where を含むクエリ構造が入力から形成できる（入力→評価境界の破壊）
- 入口（どのパラメータ/どのモード/どのContent-Type）が原因か
- oracle（件数/長さ/遅延/エラー）のうち、何が再現性のある根拠か
- 認可境界と同居している設計上の危険性（越境混入の可能性）を説明できる

### 断定しない（追加根拠が必要）
- 具体的な実行結果の断定（内部実装や権限に依存）
- 高負荷・DoS成立の断定（性能試験は契約・安全性が必要）
- DBが必ずMongoである断定（互換や抽象化がある）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・想定パス）
※悪用手順は書かず、ペンテストでの判断軸として整理する。

### 優先度が上がる入口（$where を疑う場所）
- “高度な検索” “条件式” “スクリプト検索” を謳う機能
- 管理者向けのログ閲覧/分析（内部ツールで安易に残りやすい）
- 保存検索・テンプレ（second-order：保存値が後で評価される）
- テナント/所有者条件が暗黙に付与されるAPI（認可境界と衝突しやすい）

### SQLiとの違い（判断のブレを潰す）
- SQLi：DBがSQL構文として解釈
- $where：DBがJS評価として解釈（より危険。まず“禁止”が設計解）
- よって、発見したら “細工して深掘る” より “入口と原因の特定→禁止の提案” を優先する

## 次に試すこと（仮説A/B/C：安全に最小差分で確定）

### 仮説A：入力が `$where` を直接形成できる（構造注入）
- 条件（観測）
  - filter/where にオブジェクト構造が入り、結果（件数/長さ）が安定して変わる
- 次の一手
  - 入口（どのパラメータがクエリ構造へ変換されているか）を固定
  - `$` キーの受理有無を “仕様・バリデータ” として確認（400で落ちるべき）
  - レポートでは「$where混入が可能」だけでなく「なぜ可能か（スキーマ検証不在/直渡し）」を根本原因として書く

### 仮説B：マージ処理が危険で、権限条件と同居している
- 条件（観測）
  - 単純入力では変わらないが、advanced filter で差分が出る
- 次の一手
  - “既定条件” と “ユーザ条件” の合成方法（AND結合か、同階層mergeか）を推定する
  - 認可境界（tenant/org/owner）に関わるフィールド名が、ユーザ入力と同じ階層に存在するかを確認する（越境混入の設計リスク）

### 仮説C：文字列式として受け取った where が評価されている（評価機構）
- 条件（観測）
  - where= のような文字列入力で差分が出る（件数/長さ/遅延）
- 次の一手
  - 仕様として必要なら、安全DSL化（演算子・フィールド allowlist、型拘束、最大複雑度制限）へ
  - 仕様不要なら機能削除（$where禁止）を最優先で提案

## 防御設計（修正の“設計”として提示する）

### 1) 原則：$where を使わない（最優先）
- アプリ設計として $where を禁止し、レビュー/静的解析で検知する
- 代替案
  - 単純検索：フィールド比較（eq/gt/lt）をサーバ側で生成
  - 部分一致：index前提の検索（正規表現の自由入力は避ける）
  - 複雑検索：専用DSL（JSON）→サーバ側でクエリ生成（演算子/フィールドはallowlist）

### 2) 入力の構造拘束（“文字列エスケープ”ではない）
- スキーマ検証（JSON schema / DTO / zod 等）で
  - フィールド名をallowlist化
  - 値の型を固定（string/number/boolean/date）
  - オブジェクト/配列の深さやサイズを制限
- `$` で始まるキーを拒否（ただし補助。最終的には“受理するキーがallowlist”であることが重要）

### 3) マージの禁止（同階層mergeをしない）
- 権限条件（tenant/owner）は固定で付与し、ユーザ入力オブジェクトと直接混ぜない
- “ユーザ条件”は安全DSLから生成した条件のみを AND 結合する（深いmergeをしない）

### 4) 監査・検知（運用境界）
- ログに残す（機微はマスク）
  - trace_id、入口（endpoint）、filterの構造要約（演算子出現の有無）
  - 遅延・タイムアウト・エラー種別
- アラート候補
  - `$where` / `$function` / `script` を含む入力の出現
  - 正規表現・広範囲検索の頻度上昇
  - 失敗率/遅延の急増（DoS兆候）

## 手を動かす検証（Labs連動：安全に理解する）
- 目的：$where の危険性を「入口」「合成」「oracle」で再現し、実務での判断を固定する
- 最小構成（推奨）
  - (1) 安全：受理フィールド/型固定、演算子禁止
  - (2) 脆弱：filter JSON を直渡し（$where混入）
  - (3) 脆弱：base条件とuser条件の同階層merge（権限条件と同居）
  - (4) 仕様系：where文字列式を評価（“最悪の例”として）
- 証跡
  - HAR：baseline / 差分true / 差分false
  - サーバログ：trace_id、クエリ構造要約、実行時間
  - DBログ（Labsのみ）：$whereが実際に評価された痕跡

## 例（最小限：設計の違いを理解するための形）
~~~~
# 危険：汎用filterを直渡し（$where混入が可能）
query = JSON.parse(req.query.filter)
db.collection.find(query)

# 安全：アプリ独自DSLを解釈してクエリ生成（演算子/フィールドallowlist）
input = JSON.parse(req.query.filter)
assert field in allowlist
assert op in allowlist
assert type(value) == expected
query = buildQuery(input)   # サーバで生成（$whereを生成しない）
~~~~

~~~~
# 危険：権限条件とユーザ条件を同階層merge
base = { tenant_id: t }
user = JSON.parse(req.query.filter)
query = { ...base, ...user }     # 同階層で混ぜるのが危険

# 安全：baseは固定、userは安全に生成した条件のみAND結合
query = { $and: [ base, safeUserCondition ] }
~~~~

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

## 次（作成候補順）
- `01_topics/02_web/05_input_04_nosql_injection_01_mongodb_03_aggregation（pipeline_$lookup）.md`
