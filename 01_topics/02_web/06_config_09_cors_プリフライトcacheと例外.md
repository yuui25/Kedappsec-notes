## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 破れる：CORSの許可が過剰（反射/ワイルドカード/credentials混在）だとブラウザ境界が崩れ、同一ユーザ権限での読み取りが起き得る。プリフライトや例外レスポンスで挙動が揺れると、運用で“危険な回避実装”を誘発する。
  - 満たす：必要最小限の許可（Origin/Methods/Headers/Credentials）を一貫運用し、プリフライト（OPTIONS）と例外パス（エラー/リダイレクト）まで含めて設計する。
- WSTG
  - 観点：CORS設定、プリフライト挙動、エラー/リダイレクト時のヘッダ、Varyの適切性、許可の反射や例外ルールを検証する。
- PTES
  - 位置づけ：脆弱性分析（設定/運用）→ 侵害評価（ブラウザからの読み取り可能性）→ 報告（許可範囲と運用要件）。
- MITRE ATT&CK
  - Collection（同一ユーザ権限での情報収集）を支える前提になり得る。ただしサーバ認可が本質で、断定は成立確認後。

---

## タイトル
CORS（プリフライトcacheと例外）：OPTIONSと反映遅延が“許可/拒否”を不安定にする

---

## 目的（このファイルで到達する状態）
- CORSを「緩い/厳しい」ではなく、**プリフライト（OPTIONS）とそのキャッシュ、例外レスポンスで許可境界がどう揺れるか**で説明できる。
- 実務で使える判断ができる。
  - どの条件でプリフライトになるか（メソッド/ヘッダ/Content-Type）
  - `Access-Control-Max-Age` が運用上の反映遅延になる点
  - エラー/リダイレクト/認証前でCORSヘッダが抜ける“例外運用”の危険性

---

## 扱う範囲（本ファイルの守備範囲）
- プリフライトとMax-Age（反映遅延の運用境界）
- 例外パスでのCORSヘッダ不整合
- `Vary: Origin` を含む混線防止の観点
※典型的な設定ミスの網羅は主目的にしない（ここでは“運用で壊れる点”に集中）

---

## 前提：CORSは“ブラウザ制御”。サーバ認可を代替しない
- CORSが緩いと、ブラウザ上で“読める”条件が増える
- しかし、本質はサーバ側の認可（CORSで守る設計は現実に破綻しやすい）
- だからこそ、CORSは「正しく動く」＋「運用で揺れない」を目標にする

---

## 境界モデル（プリフライトと例外が壊す境界）
- ブラウザ境界：プリフライト結果がブラウザ内で再利用される（Max-Age）
- 運用境界：許可変更（修正/ロールアウト）がすぐ反映されない
- 例外境界：401/403/500/302でヘッダが抜けると、フロントが危険な回避策を取りがち

---

## 観測ポイント（現実で刺さる順）
### 1) プリフライト（OPTIONS）の一貫性
- リクエスト：Origin / Access-Control-Request-Method / Access-Control-Request-Headers
- レスポンス：Allow-Origin / Allow-Credentials / Allow-Methods / Allow-Headers / Max-Age
- 例外：OPTIONSにだけ別挙動（WAFやGatewayが特別扱い）になっていないか

### 2) `Access-Control-Max-Age`（運用で効く）
- 大きすぎると、修正してもユーザのブラウザに“古い許可”が残る可能性
- 小さすぎると、頻繁なOPTIONSで性能影響→運用が例外を作り始める

### 3) `Vary: Origin`（混線防止）
- 共有キャッシュが関与する場合、Vary不足は致命傷になり得る
- “たまたま動く”状態は運用で破綻する

---

## 結果の意味（この状態なら何が言えるか）
- プリフライトが揺れる：環境（WAF/CDN/Gateway）で例外処理が入っている可能性
- Max-Ageが大きい：許可変更の反映遅延が発生し得る（運用リスク）
- 例外レスポンスでヘッダが抜ける：CORSが“設計”ではなく“偶然”になっている

---

## 攻撃者視点での利用（現実で使われる）
- CORSを“サーバ認可の穴”としてではなく、“ブラウザで読める条件”として評価する
- 例外パス（エラー/リダイレクト/認証前）に挙動差があると、誤設定の入口になる

---

## 次に試すこと（仮説A/Bで分岐）
### 仮説A：設定は概ね正しいが、例外パスで崩れる
- 次の一手
  - 401/403/500/302の各レスポンスでCORSヘッダが一貫しているか確認
  - OPTIONSがWAF/Gatewayで別扱いされていないか（ログ/設定確認）

### 仮説B：Max-Ageが運用に合っていない（反映遅延 or 性能劣化）
- 次の一手
  - 変更反映のSLO（どれくらいで効くべきか）を決める
  - 重要APIは保守的に、匿名APIは性能寄り、など“範囲”で分ける

---

## 修正（現実で通る要件）
- 例外レスポンスも含めてヘッダを一貫させる（共通ミドル/ゲートウェイ統制）
- Vary: Origin を要件化（混線防止）
- Max-Ageは運用SLOに合わせる（反映遅延を許容しない領域は短く）

---

## 04_labs（プリフライトと例外：揺れるCORSを再現して判断できるようにする）
- 追加候補Lab（例）
  - `04_labs/02_web/06_config/09_cors_preflight_cache_exceptions/`
- Lab設計要件
  - 200/401/500/302でCORSヘッダが変わる構成＋Max-Age差分
  - 目的：例外パスでの不整合と反映遅延を“運用要件”に落とせること

---

## コマンド/例（例示は最小限：観測と判断を優先）
~~~~
# CORSは「通常リクエスト」だけ見ても不十分。
# - OPTIONS（プリフライト）を観測
# - 401/403/500/302の例外でも同じヘッダが付くか確認
# - Max-Age（反映遅延）と Vary: Origin（混線防止）を要点として記録
~~~~

---

## 深掘りリンク（最大8）
- `06_config_03_security_headers（CSP_HSTS_XFO等）.md`
- `06_config_05_cache_control_機微レスポンスの境界.md`
- `06_config_10_cdn_waf_運用境界（ルール例外_バイパス）.md`
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
- `06_config_07_error_pages_詳細表示と環境切替.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
