## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 重要点：メール送信は「アプリ→外部（MTA/メールAPI）→人間（受信者）」の境界を跨ぐ。入力が **ヘッダ値として扱われる** と、CRLF混入で“ヘッダ行の構造”が壊れ、追加ヘッダ・宛先増殖・本文解釈変更などへ波及する。
  - 要件：ヘッダ生成をライブラリに委譲、ヘッダ値の改行禁止、エンベロープ（SMTP RCPT）とヘッダ（To/Cc/Bcc）を分離し、送信先はサーバ側の許可リスト/認可で拘束する。
- WSTG
  - 入力検証だけでなく、連携（メール送信・通知・招待）機能で「ユーザ入力がどのヘッダ/どのテンプレ変数に入るか」を追い、受信した生メール（raw source）で構造破壊が起きるかを確認する。
- PTES
  - 情報収集：メール送信経路（SMTP直送 / SES・SendGrid等API / 社内MTA中継）、送信対象（招待・パスワードリセット・問い合わせ返信・監査通知）を棚卸し。
  - 脆弱性分析：エンベロープ（宛先指定）とメッセージ（ヘッダ/本文）で「入力が入る場所」を分解し、CRLFの遮断点を特定。
  - 侵害評価：実害はサーバRCEではなく、(1) 追加宛先での情報漏えい、(2) Reply-To等改変によるフィッシング補助、(3) MIME/Content-Type改変によるクライアント側解釈変更、(4) 運用・監査逸脱。
- MITRE ATT&CK
  - 初期侵入/横展開への接続：メールはT1566（Phishing）の媒介になり得るが、本件は「アプリ機能が攻撃者の配布経路になる」点が本質。
  - 実行：T1204（User Execution：受信者がメールを開く/リンクを踏む）
  - 影響：情報漏えい（宛先追加）、信頼境界の破壊（通知フローの改ざん）、業務妨害（大量送信誘発）など。

---

## タイトル
Email Header Injection：SMTPの“宛先（エンベロープ）”と“ヘッダ（メッセージ）”の境界を壊し、情報漏えい・誘導・運用逸脱を起こす

---

## 目的（このファイルで到達する状態）
- 「メールヘッダ注入」を、次の形で説明・検証・報告できる。
  1) メール送信の二層（SMTPエンベロープ / メッセージヘッダ）を区別できる
  2) 入力がヘッダ値に入る“構造破壊点（CRLF）”をモデル化できる
  3) 実害を“業務フロー”として確定できる（誰が受け取る/何が漏れる/何が誤誘導される）
  4) 修正を「生成方式（ライブラリ/API）」「入力制約」「認可・宛先拘束」「監査」に分けて提案できる

---

## 扱う範囲（本ファイルの守備範囲）
- 扱う：Email Header Injection（CRLF Injection in email headers）
  - 例：From/To/Cc/Bcc/Reply-To/Subject/Message-ID/Headers（X-*）等の“ヘッダ行”が外部入力で壊れる
  - 影響：追加宛先、返信先改変、ヘッダ改ざん、MIME解釈変更、情報漏えい、運用逸脱
- 扱わない（ただし接続は必須）
  - 一般的なCRLF Injection（HTTPヘッダ分割）は `05_input_20_crlf_injection_*` に委譲
  - メール本文テンプレのHTML XSSは `05_input_06_xss_*` と連携（メールクライアントは別実行環境）

---

## 前提：メール送信は「2つの宛先モデル」を持つ（ここが境界）
### 1) SMTPエンベロープ（配送先）
- SMTPの RCPT TO に相当する「実際の配送先」
- 多くのメールAPI（SES/SendGrid等）では “to/cc/bcc配列” がこれに近い

### 2) メッセージヘッダ（表示・返信・解釈）
- 受信者が見る To/Cc/From/Reply-To/Subject 等
- MIME/Content-Type など “本文の解釈” にも関与

結論
- **ヘッダ注入**は主に(2)の構造破壊だが、実装によっては(1)にも影響し、情報漏えい（追加宛先）として致命化する。
- 逆に、(1)が安全に固定されていれば、(2)が壊れても被害半径が限定される（ただしフィッシング補助等は残る）。

---

## 境界モデル（入力→ヘッダ生成→送信→受信の流れ）
ユーザ入力（氏名/メール/件名/自由記述/カスタムヘッダ/CSV等）
→ サーバ側でメール生成（テンプレ + ヘッダ組立）
→ 送信（SMTP直送 / メールAPI）
→ 受信側でヘッダ解析（MTA/クライアント）
→ 表示/返信/リンク/本文解釈が決まる

危険点は「サーバ側でヘッダ行を文字列連結している」こと。
- CR（キャリッジリターン）/LF（ラインフィード）が混入すると、1行＝1ヘッダの構造が崩れる。
- その結果、意図しないヘッダが“追加”される、あるいは既存ヘッダが“継続/折り返し”として解釈される。

---

## 入口（source）の棚卸し：どの入力がヘッダに入るか
優先度が高いのは「ユーザ入力がヘッダへ直接入る」か「ヘッダ相当の項目をアプリが提供している」ケース。

### A. 典型：問い合わせフォーム / サポート返信
- ユーザが入力した「件名」「名前」「メール」が、返信メールの Subject/Reply-To/From表示名などに入る

### B. 招待メール / 共有リンク / プロジェクト通知
- 招待先メールアドレスが宛先配列に入る（=エンベロープに直結しやすい）
- 追加宛先ができると情報漏えいが成立しやすい（招待リンクの拡散）

### C. “カスタムヘッダ”機能（X-Headerやタグ付け）
- マーケ/配信で使うタグ・メタ情報を任意入力させていると、ヘッダ注入に直結する

### D. CSV等からの一括送信（インポート→通知）
- 一括送信で、入力値がテンプレ変数だけでなくヘッダ（表示名等）に入ることがある

---

## 破綻パターン（差分＝成立根拠：薄くしない）
> ここでは「悪用の手順」ではなく、診断で“構造破壊が起きた”ことを確定する観測点を示す。

### パターン1：ヘッダ追加（Injected header）
- 条件：ヘッダ値に改行が混入し、次行が新しいヘッダとして解釈される
- 影響の方向：
  - 追加宛先（Cc/Bcc）による情報漏えい
  - Reply-To改変による誤誘導（サポート返信を攻撃者に返させる等）
  - Content-Type改変により本文解釈を変える（HTML化など）
- 成立根拠（観測）：
  - 受信した生メールのヘッダに “想定外ヘッダ行” が現れる（raw source で確認）

### パターン2：ヘッダ折り返し（Header folding / continuation）
- 条件：改行後が空白/タブで始まると「前ヘッダの継続行」として扱われる実装がある
- 影響：
  - 既存ヘッダ値の“延長”として不正文字列が入り、クライアント表示や解析が崩れる
- 成立根拠：
  - ヘッダ行が複数行に連結されて見える／一部クライアントで表示が変わる

### パターン3：エンベロープ宛先に波及（最重要：情報漏えい）
- 条件：実装が「ヘッダTo/Cc/Bcc」から配送先（RCPT）を組み立てている、またはSMTPを生で組み立てている
- 影響：
  - 本来の送信先以外へ配送される（招待・請求・通知の漏えい）
- 成立根拠：
  - 受信者側で “自分が受け取るはずのないメール” を受領（検証は自分管理のメールボックスでのみ実施）

### パターン4：ログ/監査の破壊（運用逸脱）
- 条件：送信ログが “ヘッダ” を基準に記録される
- 影響：
  - 追跡不能（誰に送ったか不正確）、コンプラ事故、インシデント対応不能
- 成立根拠：
  - 送信ログ（管理画面/API/監査）と実際のメールヘッダ/配送結果が不一致

---

## 検証設計（安全第一：攻撃より“根拠固め”）
### 0) 事前条件（必須）
- 受信確認は、必ず自分が管理するメールアドレス（検証用）で行う
- 追加宛先の実害検証（第三者に送る）は行わない（契約・ルール違反になり得る）
- 目的は「ヘッダ構造が壊れる」証拠を取ること（raw header）

### 1) 入口特定：どの入力がヘッダへ入るか
- 対象候補（優先順）
  - Subject（件名）
  - From表示名（name部分）
  - Reply-To
  - CC（UIがある場合）
  - カスタムヘッダ（X-タグ等）

観測方法
- その入力を変えたときにメールのヘッダ値が変わるか（raw headerで確認）

### 2) “改行を拒否しているか”の確認（最小差分）
- 目標：入力に改行相当が含まれるときに
  - サーバ側で拒否（400など）するのか
  - 正規化して除去するのか
  - そのまま通してしまうのか
を確定する。

### 3) 受信した生メールでの証拠化
- メールクライアントの“表示”だけで判断しない
- 必ず「メッセージソース（raw）」を保存して、ヘッダ行の実態を証拠にする

### 4) 分岐：API送信かSMTP直送か（実害の重み）
- メールAPIの場合、プロバイダ側でヘッダ値の改行を拒否することがある（=アプリが脆弱でもブロックされる）
- SMTP直送/自前実装の場合、ブロックがなく実害化しやすい
- したがって、所見では「どの送信方式で、どの層が防いでいる/いない」を明確に書く

---

## “薄い”報告にならないための所見化テンプレ（このまま書ける粒度）
### 1) 脆弱性の定義（境界）
- ユーザ入力がメールヘッダ値として使用され、改行が除去/拒否されないため、ヘッダ構造が破壊される可能性がある。

### 2) 成立根拠（観測）
- 入力項目：◯◯
- 受信した生メール（raw）で、当該入力がヘッダ行に入り、改行の扱いが不適切であることを確認した（証跡：ヘッダ抜粋、Message-ID、日時）

### 3) 影響（条件付きで“業務”に落とす）
- 想定運用：◯◯（CSが問い合わせ返信を処理、監査が日次でエクスポート等）
- 影響例：
  - 宛先増殖が可能な実装の場合：通知・招待リンク・個人情報の第三者送信（重大）
  - Reply-To改変が可能な場合：サポート返信の誤誘導（フィッシング補助）
  - MIME解釈が変わる場合：HTML化/リンク表示改変など（受信者依存）
- 影響の成立条件（本案件で確認できた範囲）：◯◯

### 4) 修正提案（設計要件として）
- ヘッダの組立を文字列連結で行わず、RFC準拠のメール生成ライブラリ/メールAPIでヘッダ値をセットする
- ヘッダ値にCR/LFを含めない（拒否 or 除去）、許可文字のallowlist化
- 宛先（エンベロープ）はサーバ側で決定し、ユーザ入力で追加できない（認可・許可リスト）
- 送信ログにエンベロープ宛先とMessage-IDを残し、追跡性を担保する

---

## 実務での“起きがちな設計ミス”（原因特定の観点）
### ミスA：ヘッダを手組みしている
- `Subject: ` + userInput のような連結
- “表示名 <email>” を自作整形し、エスケープ/エンコードをしていない

### ミスB：ヘッダTo/Ccから配送先を作っている
- UI上のTo/Ccをそのまま使い、サーバ側で宛先拘束がない
- 招待・共有リンクなどで致命化しやすい

### ミスC：テンプレ変数をヘッダにも流用している
- 本文向けの変数（自由入力）を件名/表示名にも使う

### ミスD：バリデーションが“入力時だけ”
- 入力時に弾いても、後段（インポート、API、バッチ、既存データ）から混入する
- 結果として export/送信時に再燃する（データは永続）

---

## 防御（優先順：最短で事故を止める）
### 1) 送信方式を安全化（最優先）
- SMTPコマンドやヘッダを自作せず、実績あるライブラリ/プロバイダAPIを使う
- “ヘッダ値に改行があれば送信拒否” をアプリ層で明示する（プロバイダ任せにしない）

### 2) 入力制約（ヘッダ用フィールドは特別扱い）
- 件名/表示名/返信先などは、本文と同じ自由入力にしない
- 文字種・長さ・改行禁止・制御文字禁止
- 正規化（trim、不可視文字除去）を明示

### 3) 宛先（エンベロープ）の認可拘束
- “誰に送れるか”は認可（ロール/テナント/対象ID）で決める
- ユーザ入力を宛先配列に直結しない（特にCC/BCC）

### 4) 監査・検知
- Message-ID とエンベロープ宛先、テンプレID、request_id を紐付けて記録
- 異常（宛先数の増加、失敗率増、短時間大量送信）をアラート

---

## 次に試すこと（仮説A/B）
### 仮説A：ヘッダ構造破壊が観測できた（高優先度）
- 次の一手
  - その入力が「追加宛先」「Reply-To」「MIME解釈」など“どの分岐点”に影響するかを確定
  - 宛先拘束（エンベロープ固定）があるかを確認し、情報漏えい成立の有無で重大度を決める
  - 同じ入力が他通知（招待/請求/監査）にも流用されていないか棚卸し

### 仮説B：プロバイダが拒否して実害は出ない（設計上の弱さは残る）
- 次の一手
  - アプリ側での拒否/正規化がないなら、将来の送信方式変更や別経路（バッチ/別サービス）で再燃する
  - “プロバイダ依存の安全性”として改善提案を残す（アプリで明示ガード）

---

## 04_labs（理解用：SMTP境界の再現）
- 追加候補Lab（例）
  - `04_labs/02_web/05_input/17_email_header_injection_boundary/`
- Lab設計要件
  - エンベロープ宛先とヘッダTo/Cc/Bccを分けて扱う実装（安全）と、手組み実装（危険）を比較
  - 検証は“raw headerの差分”で止め、第三者への送信や悪用を行わない
  - 証跡：Message-ID、rawヘッダ、送信ログ（request_id）を必ず紐付ける

---

## コマンド/例（例示は最小限：概念のみ）
~~~~
# 目的：生メール（raw）でヘッダ構造が壊れるかを確認する。
# - 入力が Subject/From表示名/Reply-To 等に入ることをまず確認
# - 改行相当の混入が「拒否/除去/通過」どれかを観測
# - 宛先（配送先）がエンベロープ固定か、ヘッダ由来かを切り分ける
~~~~

---

## 深掘りリンク（最大8）
- `05_input_20_crlf_injection_01_response_splitting（header_body）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_06_xss_01_反射_境界モデル.md`
- `05_input_06_xss_02_格納_境界モデル.md`
- `03_authz_01_境界モデル（オブジェクト_ロール_テナント）.md`
- `04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `01_topics/01_asm-osint/19_email_infra（SPF_DKIM_DMARC）と攻撃面.md`
- `04_api_08_file_export_エクスポート境界（CSV_PDF）.md`
