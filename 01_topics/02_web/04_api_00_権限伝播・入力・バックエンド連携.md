<<<BEGIN>>>
# 04_api_権限伝播・入力・バックエンド連携.md

（先頭要約：ガイドライン対応の位置づけ）
- ASVS：APIを“機能”ではなく、認証・認可・入力・出力・設定の境界として扱い、満たす/破れる点を説明できる状態にする
- WSTG：API Testing を、入口観測→権限伝播→入力点→状態確認（再取得）へ落とす
- PTES：Intelligence Gathering の観測を、Vulnerability Analysis（優先度付け）へ接続し、Exploitation へ最短で繋ぐ
- ATT&CK：Discovery/Collection/Exfiltration などの目的に対し、APIが“データ面・権限面の主戦場”になっている構造を説明できる状態にする

## 目的（この技術で到達する状態）
- APIを「エンドポイント列挙」ではなく、**権限がどこから来て、どこで判定され、どこまで伝播するか**（境界）として理解し、検証に使える。
- SPA/モバイル/サーバ間通信など利用形態の違いを踏まえ、**本当に効く入力点**（URL/Body/Header/Token/GraphQL variables 等）を特定できる。
- “成功/失敗”の判定をレスポンスだけに頼らず、**状態確認（再取得/一覧/監査/副作用）**まで含めて再現手順を作れる。

## 前提（対象・範囲・想定）
- 対象：許可された範囲の API（REST/GraphQL/WebSocket/内部API含む）に限定。
- 想定：
  - SPA + API、モバイル + API、マイクロサービス、API Gateway、BFF（Backend for Frontend）
  - 認証：Cookie/Token（Bearer/JWT等）、SSO前提のことがある
  - 外部依存：SaaS/外部API（決済、通知、ストレージ、分析、IdP等）
- 依存（前段の接続）：
  - `01_topics/02_web/02_authn_認証・セッション・トークン.md`
  - `01_topics/02_web/03_authz_認可（IDOR BOLA BFLA）境界モデル化.md`
- 観測基盤（必須）：
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap har log）.md`
- やらないこと：
  - ツールでの大量自動列挙を前提にしない（まず“境界モデル”を確定してから最小限の探索にする）

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
### 1) APIの入口（Entry）を確定する
- どのホスト/パスが API か（例：api. / /api/v1 / /graphql / /ws など）
- 画面操作1つに対して、どのAPIが呼ばれるか（代表機能を1つ選ぶ）
- “入口の種類”を分類する
  - 読む（GET/Query）
  - 書く（POST/Mutation）
  - 消す（DELETE）
  - 実行（アクション系：/execute /approve など）

### 2) 権限伝播（AuthZの“材料”がどこから来るか）
- 伝播の材料（観測で確定）
  - Cookie（セッションID 等）
  - Authorization ヘッダ（Bearer 等）
  - トークン内の claim（tenant/role/scope）
  - リクエストヘッダ（X-Role/X-Tenant 等：あれば）
- “判定がどこで行われるか”を推定する
  - API Gateway / BFF / サービス内 / 下流サービス
  - ヒント：エラー型、レスポンス時間、共通の拒否パターン、ヘッダの有無

### 3) 入力点（どこが境界を変えるか）
- URL/Path/Query：リソースID、フィルタ、ページング、ソート
- Body（JSON/Form）：ownerId、tenantId、role、status 等の“境界に効きそうな値”
- Header：Origin、Content-Type、X-* 系
- GraphQL：query/mutation、variables、node id、fragments
- WebSocket：初回認証、イベント名、payloadの構造

### 4) 出力（レスポンス）の読み方（“状態”で判断する）
- ステータスコードの意味（401/403/404/200等）は入口だが、結論にしない
- 状態確認（必須）
  - 書いたなら：再取得（GET）で本当に反映したか
  - 消したなら：一覧/参照/検索で本当に消えたか
  - 実行系なら：副作用（通知/ログ/履歴/ステータス）が変わったか
- 部分成功/部分失敗の兆候
  - 返却フィールド欠落、件数の変化、サーバ側で正規化される等

### 5) 外部連携（越境点）を見つける
- 外部API/SaaSへの呼び出しが存在するか（フロント/バックから）
- 連携の境界
  - どのデータが外に出るか（個人情報、契約情報、ファイル等）
  - どの権限で呼ばれるか（ユーザ委任/サーバ権限）
- 連携失敗時の挙動（フェイルオープン/リトライ/キュー等）を“状態”として観測する

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定できる）
  - API入口（代表機能）に対し、必要な“鍵”（Cookie/Token/ヘッダ）が何か
  - 境界に効く入力点（ID/tenant/role/owner等）がどこに存在するか
  - 認可がサーバ側で強制されているか（AuthZの強制点の推定）
  - 成否判定が“状態確認”で再現できる
- 推定（追加観測で強くなる）
  - Gateway/BFF/下流サービスのどこで判定されているか
  - 外部連携（SaaS/外部API）の越境点と責任分界
- 言えない（この段階の限界）
  - すべてのAPIの網羅（代表機能から広げる必要がある）
  - 内部実装（ソース/設計）がない状態での断定（観測からの推定に留める）
  - 外部連携の詳細（契約/設定）は観測だけでは見えない場合がある

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
### 優先度の付け方（最短で価値が出る順）
1) 権限が関わる“書く/消す/実行”のAPI（影響が明確）
2) テナント境界が絡むAPI（越境の重大度が高い）
3) オブジェクト境界が絡むAPI（BOLA/IDORの主戦場）
4) 外部連携を含むAPI（越境・責任分界・フェイル挙動が複雑）

### 攻め筋（APIでよく効く判断）
- “鍵”が1つでも欠けるとどうなるか（401/403だけでなく状態がどうなるか）
- “境界値”を変えるとどこで拒否されるか（URL/Body/Header/Tokenのどれが真の境界か）
- “状態確認”ができる観測点を用意しているか（再現性の鍵）

### 次の仮説に繋げる（API → 入力/設定へ）
- API入口と境界が固まったら、次に進む方向を決める
  - 入力→実行境界（テンプレ/デシリアライズ等）：`01_topics/02_web/05_input_入力→実行境界（テンプレ/デシリアライズ等）.md`
  - 設定・運用境界（CORS/ヘッダ/Secrets）：`01_topics/02_web/06_config_設定・運用境界（CORS ヘッダ Secrets）.md`
  - SaaS連携（IdP/共有/監査）：`01_topics/04_saas/01_idp_連携（SAML OIDC OAuth）と信頼境界.md`

## 次に試すこと（仮説A/Bの分岐と検証）
### 共通の最小セット（代表機能1つで始める）
- 代表機能を1つ選び、次の4点を揃える
  - 入口API（読む/書くの最低1つずつ）
  - 必須の鍵（Cookie/Token/ヘッダ）
  - 境界に効く入力点（ID/tenant/role等）
  - 状態確認の方法（再取得/一覧/履歴）
- 証跡は固定
  - HAR、Proxyログ、検証メモ（主体/対象/操作/条件/結果/状態確認）

### 仮説A：APIの認可判定がフロント寄りで、バックエンドが甘い
- 検証（A/B）
  - A：UIから通常操作（正規リクエスト）を観測
  - B：Proxyで“境界に効きそうな入力”だけ変えて再送し、サーバで拒否されるかを確認
- 期待する観測
  - UI制御だけか、サーバで強制されているかが分かる（AuthZの強制点が見える）

### 仮説B：境界値が複数箇所にあり、真の境界が分からない（tenant/owner等）
- 検証（A/B）
  - A：境界値を1箇所だけ変更（例：URLのIDだけ）
  - B：別箇所だけ変更（例：BodyのownerIdだけ）
- 期待する観測
  - どの入力点が“効いている”かが確定し、AuthZ検証が最短距離になる

### 仮説C：外部連携があり、失敗時挙動が境界を崩す可能性がある
- 検証（A/B）
  - A：連携が成功する条件で操作し、状態確認を記録
  - B：連携が失敗する条件（許可範囲で）を作り、状態がどう変わるかを観測
- 期待する観測
  - フェイル挙動（止まる/通る/遅延/再試行）を“状態”として説明できる

### 例示（最小の観測：コマンドは補助）
~~~~
# 例：APIの鍵が何かを観測（401/403/200の差分を見る入口）
curl -i "https://example.com/api/me"

# 例：同一操作で入力点だけ変えて差分観測（概念例）
curl -i -H "Authorization: Bearer <TOKEN>" "https://example.com/api/orders/1001"
curl -i -H "Authorization: Bearer <TOKEN>" "https://example.com/api/orders/1002"
~~~~
- 主役はコマンドではなく「何を固定し、何を変えるか（差分設計）」と「状態確認」

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回）
- ASVS：
  - APIの認証・認可・入力・出力・設定を“境界”として扱い、満たす/破れる点を検証で説明できる状態にする
- WSTG：
  - API Testing の観点を、入口観測→鍵の特定→入力点→状態確認へ落とし込む
  - 該当が薄い場合の接続：APIはWeb機能の実体であり、他の観点（AuthZ/Input/Config）を成立させる前提になる
- PTES：
  - Intelligence Gathering：代表機能のAPIを観測して境界を作る
  - Vulnerability Analysis：境界に効く入力点を特定し、検証優先度を決める
  - Exploitation：成立時は状態確認まで含めた再現手順を作る
- MITRE ATT&CK：
  - 戦術：Discovery（API構造把握）、Collection（データ取得）、Exfiltration（外部送信の可能性）、Privilege Escalation（権限越境）等
  - 技術名の貼り付けではなく「攻撃者の目的に対して、APIがどの境界を担うか」を説明できる状態にする

## 参考（必要最小限）
- `01_topics/02_web/02_authn_認証・セッション・トークン.md`
- `01_topics/02_web/03_authz_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/05_input_入力→実行境界（テンプレ/デシリアライズ等）.md`
- `01_topics/02_web/06_config_設定・運用境界（CORS ヘッダ Secrets）.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap har log）.md`

<<<END>>>
