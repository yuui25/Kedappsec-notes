## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - この技術で満たす/破れる点：エラーハンドリング（例外の露出抑制）、機密情報保護（スタック/内部URL/鍵/トークン/PII）、入力検証の失敗時の一貫性、監査（trace_idと内部詳細の分離）、可用性（例外ループ/リトライ増殖の抑制）
  - 支える前提：エラーは“攻撃の観測点”であり、差分があるだけでオラクルになる。内部実装（フレームワーク、DB、クラウド）を推定できる情報が漏れると、攻撃コストが大幅に下がる。非同期（07）やWebhook（04/05）はエラーがログ/UIに二重に出るため特に危険。
- WSTG：
  - 該当テスト観点：Error Handling（例外/スタック/デバッグ情報）、Information Leakage（内部情報）、API Testing（エラー分類の一貫性、ステータス/ボディ）、Authorization Testing（403/404差分による存在オラクル）、Business Logic（失敗時の状態/再試行）
  - どの観測に対応するか：入力の揺れ（欠落/型違い/境界値/権限違い）でエラー応答を比較し、(1)漏えい（内部情報/機微）、(2)オラクル（存在/権限/状態の推定）、(3)再試行・非同期のエラー増殖、(4)trace/監査設計、を低侵襲で確定する
- PTES：
  - 該当フェーズ：Information Gathering（エラー文言/ヘッダ/traceの収集、非同期のエラーUI）、Vulnerability Analysis（漏えいの種類と攻撃面への接続、オラクルの成立条件）、Exploitation（低侵襲：差分証拠の採取、ログ/trace_idで再現可能に）
  - 前後フェーズとの繋がり（1行）：REST filters（03）・GraphQL（02）・Webhook（04/05）・Idempotency（06）・Async Job（07）・Export（08）の全てで、例外パスは“境界の抜け穴”になり得る。09はそれらの共通防御（error model）を確立し、10のversioningでも互換性崩壊を避けるための基礎となる
- MITRE ATT&CK：
  - 戦術：Discovery / Collection / Defense Evasion
  - 目的：エラー差分から内部構造・存在・権限を推定（Discovery）、ログ/UIに漏れた機微の回収（Collection）、意図的に例外を誘発して検知回避やオラクル化（Defense Evasion）。

## タイトル
error_model_情報漏えい（例外_スタック）

## 目的（この技術で到達する状態）
- API/非同期/管理UIを横断して、エラーを「安全な一貫モデル」として設計・評価できる
  - (1)ユーザ向けエラーは最小情報で一貫、(2)内部詳細はログに限定、(3)trace_idで相関、(4)オラクル（存在/権限/状態推定）を抑制、(5)再試行/非同期で例外が増殖しない
- ペネトレとして、実害を出さずに（大量取得や破壊なしで）“差分証拠”により漏えい/オラクルを確定し、具体的な是正（レスポンス設計、ハンドラ、ログ方針、設定）を提案できる
- 「スタックを隠す」だけでは不十分で、分類・一貫性・権限・状態・相関・運用（監査/サポート）まで含めた現実設計として整理できる

## 前提（対象・範囲・想定）
- 対象：全てのAPI（REST/GraphQL）、Webhook受信/送信、非同期ジョブ、エクスポート、管理UI
- 現実のエラーの出所
  - 入力：バリデーション、型変換、JSONパース、GraphQLバリデーション
  - 認証/認可：トークン失効、権限不足、テナント混線
  - 依存：DB制約、外部API、ストレージ、キュー
  - 実装：例外未捕捉、デバッグ設定、フレームワークの既定
- ペネトレの重要姿勢
  - エラーは“誘発しやすい”が、過剰誘発はDoS/ログ汚染になるため、少数の代表入力で差分を取る
  - “確認（確定）”は、同一経路で入力だけ/権限だけ/存在だけを変えて比較する（オラクルの立証）

## 観測ポイント（何を見ているか：漏えい・オラクル・運用）
### 1) エラー表面（client-facing）：ステータス・コード・メッセージ・構造
- 観測対象
  - HTTP status（400/401/403/404/409/422/429/500/503…）
  - body構造（error_code、message、details、fields、trace_id 等）
  - ヘッダ（Server、X-Powered-By、X-Request-Id、Retry-After 等）
- 目的
  - “一貫モデル”があるか（同じ原因なら同じ分類・同じ構造）
  - 過剰な情報が含まれていないか（内部例外名、SQL、パス、URL）
- 典型の危険シグナル
  - 500にスタックトレース
  - “KeyError: …”“NullPointerException”など言語/ライブラリが露出
  - SQLエラー（テーブル名、列名、WHERE句断片）
  - クラウド/内部URL（metadata、S3 bucket、internal host）

### 2) “詳細”の置き場所：ユーザ向けと内部向けの分離
- 安全な設計（実務）
  - ユーザ向け：短いメッセージ＋安定したerror_code＋trace_id
  - 内部ログ：スタック、入力（マスク済）、依存先エラー、相関キー
- 観測で確定したい点
  - trace_id がユーザにも返されるか（サポート・調査の要）
  - ユーザ向けに内部詳細が漏れていないか

### 3) オラクル（Oracle）：差分が“推定器”になる
エラーの差分は、攻撃者にとって「存在」「権限」「状態」「実装差」を教える。
- 代表オラクル
  - 存在オラクル：存在するID→403、存在しないID→404
  - テナントオラクル：他テナントID→403、同テナントID→200
  - 状態オラクル：draft→409、approved→200 など
  - バリデーションオラクル：フィールド名/ルールが詳細に出る
- 観測で確定したい点
  - 同一endpointで、IDだけ変えた時に差分が出るか
  - 同一IDで、権限だけ変えた時に差分が出るか
  - 同一条件で、状態だけ変えた時に差分が出るか

### 4) 認証/認可エラーの設計：401/403/404の取り扱いが特に重要
- 実務の基本
  - 401：未認証/トークン無効（WWW-Authenticate等）
  - 403：認証済みだが禁止
  - 404：リソースを隠す意図（存在秘匿）として使う場合がある
- 危険
  - 404/403の揺れで存在オラクルが成立
  - 401の文言で“ユーザ存在”を漏らす（ログイン周りと同型）
- 観測で確定したい点
  - 存在秘匿が必要なリソースで、404/403が一貫しているか
  - テナント境界（03）で差分が出ないか

### 5) バリデーション詳細：どこまで返すか（開発効率 vs 攻撃面）
- 実務のトレードオフ
  - フロントUXのためにfield-levelのエラーが必要な場合がある
  - ただし“内部制約や列名”を返すのは不要
- 観測で確定したい点
  - fieldsの列挙が過剰か（内部フィールド名、隠しフラグ）
  - ルール（正規表現、最小/最大）を詳細に返しすぎていないか

### 6) GraphQL特有：errors配列が“情報漏えい”の温床
- 典型の漏えい
  - 例外名、resolverのファイルパス、stack、extensions.exception
  - schemaの型名/フィールド名が露出し、探索が高速化
- 観測で確定したい点
  - errors[].extensions に内部例外が出ていないか
  - introspection禁止でもエラーで型名が漏れていないか（02と接続）

### 7) 非同期/エクスポート特有：エラーがUIや結果物に残る（二次漏えい）
- 実務で起きる
  - ジョブ失敗理由が管理画面にそのまま表示（スタック/内部URL）
  - エクスポート生成失敗の原因がCSV/PDFに書き込まれる（例外の埋め込み）
- 観測で確定したい点
  - ジョブ詳細/ログ画面に内部例外が表示されないか
  - 失敗時に再試行が増殖し、エラーが大量生成されないか（07/06）

### 8) レート/リトライとエラー：安全な停止と429/Retry-After
- 危険
  - 5xxが出るたびにクライアント/ゲートウェイがリトライし増殖
  - キューが無限リトライで枯渇
- 観測で確定したい点
  - 429の使用（レート制限時）とRetry-Afterの整合
  - 権限/バリデーションエラーをリトライしない設計か（DLQ/停止）

### 9) “確認（確定）”の中核：差分観測の設計（最大限詳しく）
エラーモデルの評価は、実装を見ずに“差分”で立証できる。ここを厳密に行う。

#### 9.1 確認の原則（再現性が高い）
- 原則1：1つのendpointを選び、変数を1つだけ変える
  - 例：IDだけ変える、権限だけ変える、状態だけ変える、入力型だけ変える
- 原則2：比較項目を固定する
  - status、error_code、message、body構造、ヘッダ、trace_id有無、レスポンスタイム
- 原則3：3点比較で“偶然”を潰す
  - A：正常系、B：想定エラー、C：攻撃者が狙うエラー（存在/権限/状態の差分）
- 原則4：非同期は入口→詳細→結果参照の3面で比較する
  - enqueueの応答、job詳細の失敗理由、artifact参照の失敗理由

#### 9.2 確認マトリクス（最低限これを回す：少数で強い）
- 入力系（400/422周り）
  - 欠落：必須フィールド無し
  - 型違い：string→object、number→string
  - 境界：最大長超過、巨大配列、深いネスト
  - 文字種：UTF-8不正、制御文字
  - 期待する安全な結果：
    - 一貫したerror_code、内部例外名なし、フィールド名は必要最小限、trace_idあり
- 認証系（401）
  - トークン無し、期限切れ、形式不正、署名不正（観測できる範囲）
  - 期待する安全な結果：
    - “どこが間違いか”を詳細に言い過ぎない（例：ユーザ存在を示さない）
- 認可/存在オラクル（403/404）
  - 同テナントで存在するID（権限不足）
  - 存在しないID
  - 別テナントに存在するID（可能なら）
  - 期待する安全な結果：
    - いずれも同じ返し方（404統一 or 403統一など、設計意図に沿い一貫）
- 状態オラクル（409/422）
  - 状態A（draft）→操作成功
  - 状態B（approved）→操作拒否
  - 期待する安全な結果：
    - 状態名や内部遷移条件を過剰に返さない（ただしUX要件次第）
- 依存障害（503/504）
  - 外部API断（テスト環境想定）やタイムアウト
  - 期待する安全な結果：
    - 内部URL/キー/ヘッダを返さず、リトライ指示は明確（必要なら）

#### 9.3 “漏えい”確認のチェックリスト（見つけたら即メモ）
- スタックトレース断片
- 例外クラス名（NullPointerException等）
- ファイルパス（/usr/src/app/...）
- ライブラリ名/バージョン（Spring/Express/Django等）
- SQL（table/column）
- 内部ホスト名/IP（10.x/192.168/metadata等）
- クラウド識別子（bucket名、account id、region）
- トークン/キー断片（JWT、API key、署名断片）
- PII（メール/電話/氏名）
- “デバッグモード”指標（詳細ページ、interactive console）

#### 9.4 “オラクル”確認の立証方法（報告に強い形）
- 立証は“同じ形式のリクエスト”で、対象IDだけ変えて並べる
  - A：存在するが権限無し → 403
  - B：存在しない → 404
  - これだけで存在オラクルが成立（攻撃者は存在を列挙できる）
- さらに強い立証
  - レスポンスタイム差（存在する方が遅い等）があると列挙が高速化
  - メッセージ差（"not found" vs "forbidden"）はさらに強い証拠
- 非同期のオラクル
  - enqueueは200でも、job詳細で“対象が存在しない/権限不足”が詳細に出る場合がある（遅延オラクル）

#### 9.5 “確認できた”と言うための最低限の証跡セット
- HTTP証跡
  - 正常系1つ（比較基準）
  - オラクル立証（IDだけ変えた2本：403 vs 404）
  - 漏えい立証（同じ400/500で内部情報が含まれるレスポンス）
- エラー構造の証跡
  - error_code/message/trace_idの有無、レスポンスヘッダ
- 非同期/UI証跡（該当する場合）
  - job詳細の失敗理由（画面/JSON）
  - 失敗が再試行で増殖していないか（attempt_count等）

### 10) error_model_leak_oracle_key（正規化キー：後続へ渡す）
- 推奨キー：error_model_leak_oracle_key
  - error_model_leak_oracle_key =
    <error_envelope>(stable_structured|semi|free_text|unknown)
    + <trace_id_exposure>(yes/no/unknown)
    + <internal_detail_exposure>(none|low|medium|high|unknown)
    + <oracle_risk>(none|exists_oracle|tenant_oracle|state_oracle|multi|unknown)
    + <authz_status_consistency>(consistent|inconsistent|unknown)
    + <graphql_error_hardening>(strong|partial|none|na|unknown)
    + <async_error_surface>(hardened|leaky|na|unknown)
    + <retry_safety>(safe_stop|unsafe_retry|unknown)
    + <audit_strength>(strong|partial|weak|unknown)
    + <confidence>
- 記録の最小フィールド（推奨）
  - 対象endpoint/operation
  - 比較した入力セット（A/B/C）
  - status/error_code/message/trace_id
  - 漏えい項目（上のチェックリスト）
  - オラクルの立証（並べた2レスポンス）
  - 非同期/UIでの二次漏えい有無

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 言える（確定できる）：
  - エラー応答が構造化され、一貫した分類で返っているか
  - 内部情報（スタック/SQL/内部URL/クラウド識別子/トークン等）が漏れていないか
  - 403/404/409等の差分で存在/テナント/状態オラクルが成立していないか
  - GraphQL/非同期/UIなど、二次面で漏えいしていないか
  - リトライ/レート周りが安全（増殖しない）か
- 推定（根拠付きで言える）：
  - オラクルがある場合、ID列挙・越境探索（03/02/08）に攻撃が接続しやすい
  - 漏えいがある場合、対象技術（DB/クラウド/フレームワーク）推定が容易になる
- 言えない（この段階では断定しない）：
  - 内部ログの適切性（見えない場合）。ただし trace_id と表面の一貫性から運用成熟度を評価できる。

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- 優先度（P0/P1/P2）
  - P0：
    - 500/400にスタックやSQL、内部URL、トークン断片が含まれる（高漏えい）
    - 403/404差分で存在/テナントオラクルが成立し、ID列挙→IDORに直結
    - GraphQL errors.extensions で例外詳細が露出
  - P1：
    - フィールド/制約の過剰開示（攻撃者の辞書になる）
    - 非同期/UIで内部例外が表示される（二次漏えい）
    - リトライがunsafeでエラー増殖（可用性/費用）
  - P2：
    - 構造化はされているがtrace_idが無い/監査が弱い（運用リスク）
- “成立条件”としての整理（技術者が直すべき対象）
  - 表面は構造化されたerror_envelope＋trace_idのみ（詳細はログへ）
  - 403/404/409の設計意図を定め、一貫させてオラクルを潰す
  - GraphQL/非同期/UIも同じエラーモデルに統一（例外をそのまま出さない）
  - リトライは原因別に制御（権限/入力は停止、依存障害のみbounded retry）
  - ログはマスクし、相関キーを必須化する

## 次に試すこと（仮説A/Bの分岐と検証：低侵襲で確定）
- 仮説A：存在/テナントオラクルがある
  - 検証：
    - IDだけ変えた2リクエストで403/404差分を確認
  - 判断：
    - 差分あり：P0
- 仮説B：内部例外が漏れている
  - 検証：
    - 型違い/境界値で400/500を誘発し、レスポンス本文/ヘッダを確認
  - 判断：
    - スタック/SQL/内部URL：P0
- 仮説C：非同期/UIが漏えい面になっている
  - 検証：
    - ジョブ失敗を1回だけ作り、詳細画面のエラーを確認
  - 判断：
    - 内部例外表示：P1〜P0

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - `04_labs/02_web/04_api/09_error_model_leak_oracle/`
    - 構成案（現実運用の再現）
      - REST + GraphQL + Async Job + Export の4面
      - エラーハンドラ切替：
        - 例外未捕捉（漏えい） vs 統一エンベロープ（安全）
        - 403/404統一/不統一
        - GraphQL extensions.exception の抑制ON/OFF
      - 監査：
        - trace_id（外部返却）＋内部ログ（スタック/依存）分離
      - リトライ：
        - 原因別（4xx停止/5xxbounded） vs 無差別リトライ（増殖）
- 取得する証跡（深掘り向け）
  - HTTP：比較セット（A/B/C）
  - GraphQL：errors配列の中身
  - Async：ジョブ詳細の失敗理由
  - ログ：trace_idで相関できる断片（マスク）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
~~~~
# 存在オラクル検証（擬似）
GET /api/resources/ID_EXISTS   -> 403
GET /api/resources/ID_NOTFOUND -> 404

# バリデーション漏えい検証（擬似）
POST /api/resources
Body: { "count": { "unexpected":"object" } } -> 500 with stack? / 400 structured?

# 非同期漏えい検証（擬似）
POST /api/exports (invalid filter) -> job failed
GET /api/jobs/{job_id} -> error detail leaked?
~~~~
- この例で観測していること：
  - 差分が“推定器（オラクル）”になっていないか、内部詳細が表面に出ていないか
- 出力のどこを見るか（注目点）：
  - internal_detail_exposure、oracle_risk、authz_status_consistency、graphql_error_hardening、async_error_surface、trace_id_exposure
- この例が使えないケース（前提が崩れるケース）：
  - APIが常に200でエラーを返す設計でも、エラー本文の差分でオラクルは成立するため、同様に比較する

## 参考（必要最小限）
- OWASP ASVS（エラーハンドリング、情報漏えい、監査）
- OWASP WSTG（Error Handling / Information Leakage）
- PTES（差分観測で確定）
- MITRE ATT&CK（Discovery/Collection：エラーからの推定）

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/04_api_07_async_job_権限伝播（キュー_ワーカー）.md`
- `01_topics/02_web/04_api_08_file_export_エクスポート境界（CSV_PDF）.md`
- `01_topics/02_web/04_api_02_graphql_境界（schema_introspection_query_cost）.md`

## 次（04_api_10 以降）に進む前に確認したいこと（必要なら回答）
- 04_api_10（versioning）では、v1/v2の併存で“古いエラー形式や緩い認可が残存する現実”を前提に、互換性・デプリケーション・クライアント強制更新・監査/計測（どの版が使われているか）まで最大限詳しく扱う
