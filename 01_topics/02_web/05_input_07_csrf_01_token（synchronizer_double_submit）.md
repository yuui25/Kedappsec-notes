## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS
  - 満たす/破れる点：認証済み機能（状態変更）に対して、攻撃者サイト起点の“第三者起動リクエスト”を成立させない（= 信頼境界の再確立）。実装は「トークンの強度」だけでなく、(1)トークン発行・保存・送信の設計、(2)検証点の網羅（全状態変更）、(3)セッション/ユーザ/要求に対するバインド、(4)例外パス（JSON API / webhook / SSO周辺）の統制まで含む
- WSTG
  - Testing for Cross Site Request Forgery（WSTG-SESS-05）に対応：CSRFの成立条件（被害者が認証済み・自動送信できるリクエスト・防御不備）と、トークンベース防御の検証観点（全状態変更、サーバ検証、トークンの予測不能性、セッション紐付け等）を観測として落とす
- PTES
  - 該当フェーズ：Vulnerability Analysis（状態変更面の棚卸し→防御の種別判定）→ Exploitation（成立根拠の確定：トークン不在/検証不備/バインド不備）→ Reporting（影響：被害者権限で可能な“操作代行”を業務フローに接続）
  - 前後の繋がり：AuthN（Cookie属性/SameSite）・AuthZ（重要操作/権限）・API（CORS/JSON）と同一の“境界”として一貫させる
- MITRE ATT&CK
  - 位置づけ：CSRF自体はATT&CKの単独テクニックというより「Web閲覧・誘導・埋め込みを起点に、被害者権限で操作を走らせる」導線。攻撃者の配布（リンク/埋め込み）はCAPEC-62の説明に一致。クライアント起点のWeb誘導は Drive-by Compromise（T1189）と接続して説明できる
  - 目的：被害者権限での重要操作（設定変更/権限変更/送金/連携追加）を“本人操作に見せて”実行させる

---

## タイトル
CSRF トークン（Synchronizer / Double Submit）境界モデル

## 目的（この技術で到達する状態）
- CSRFを「フォームにhiddenを入れる」ではなく、**信頼境界の再確立**として扱える
  - ブラウザが自動付与する資格情報（Cookie等）だけでは“本人性”にならない、という境界モデルを説明できる
- トークン方式（Synchronizer Token / Double Submit Cookie）を、以下の観点で“実務的に正誤判定”できる
  1) 発行：誰に、いつ、どの粒度（セッション/リクエスト）で出すか  
  2) 送信：どこ（form/body/header）に載せるか、SPA/非ブラウザ呼出しで破綻しないか  
  3) 検証：どのエンドポイントで検証しているか（抜けがないか）、検証の厳密さ（比較方法・バインド）  
  4) 例外：ファイルアップロード、JSON API、SSO周辺、管理UI、Webhook/外部連携などの“抜けやすい面”を構造で塞げているか  
- 攻撃者視点（現実寄り）で、次を即断できる
  - “誘導が必要”という弱点よりも、「管理/運用UI」「重要操作」「自動実行される導線（メール/リンク/埋め込み）」があるかがリスクの本体
  - 成立根拠は「payload工夫」ではなく、**防御の欠落・検証不備・バインド不備**の証拠化で取る

---

## 前提（CSRFの成立条件を境界として固定）
- CSRFとは：被害者が認証済みの状態で、攻撃者が“意図しないリクエスト”を被害者ブラウザに送らせ、サーバが正当な操作として受理してしまう攻撃
- なぜ起きるか（境界の言語化）
  - ブラウザは同一サイト宛のリクエストに資格情報（Cookie等）を自動で付ける
  - したがって「Cookieが付いている＝本人操作」ではない（信頼境界が破れている）
- トークン防御の前提
  - 攻撃者サイトからは“正しいトークン”を作れない／読めない、という非対称性を使う
  - よってトークンには「秘密」「予測不能」「セッション等への紐付け」が必要

---

## 境界モデル（入力→送信→受理）
### 1) 資産境界：守る対象（どこがCSRFの標的か）
- “状態変更”が起きる操作
  - 例：メール変更、パスワード変更、2FA有効化、支払先追加、送金、権限付与、外部連携追加、Webhook設定、APIキー再発行
- 重要：GETでも状態変更する設計は境界として破綻（CSRF以前に設計不備）

### 2) 信頼境界：どこからが第三者か
- 攻撃者サイト（別オリジン）から
  - form送信 / 画像・タグ埋め込み / 自動遷移 / JSによる送信（制約あり）
- ここで問うべきは「攻撃者が送れる形のリクエストで、サーバが受理するか」

### 3) 権限境界：誰の権限で何が起きるか
- 被害者が一般ユーザでも、対象が“アカウント回復・連携追加”なら影響は大きい
- 被害者が運用/管理なら最優先（管理UIはCSRFで壊れると業務フロー全体が破綻する）

---

## トークン方式の整理（Synchronizer と Double Submit の差分＝成立根拠）
### A. Synchronizer Token Pattern（同期トークン）
- 仕組み（境界としての意味）
  - サーバが（セッションに紐づく）トークンを発行し、フォームやレスポンスに埋め込み、次の状態変更要求でサーバが照合する
  - 攻撃者は被害者のトークンを取得できない前提（同一オリジン制約/秘匿）で成立
- 強い点
  - サーバ側で“正解のトークン”を保持できるため、設計次第で厳密（ワンタイム化、画面遷移制約等）にできる
- 弱くなる典型（成立根拠がここに出る）
  - あるエンドポイントだけ検証していない（“抜け”が最頻）
  - トークンがユーザ/セッションに紐づいていない（全ユーザ共通、固定、推測可能）
  - トークン検証が形式的（存在チェックのみ、比較が甘い、失敗時も処理継続）

### B. Double Submit Cookie（ダブルサブミット）
- 仕組み（境界としての意味）
  - トークンをCookieにも持ち、同じ値をリクエスト（body/header等）にも送らせて、サーバが“2箇所一致”を確認する
  - 攻撃者は「Cookieは自動送信されるが、同じ値を別場所に入れられない（読めない）」という非対称性を使う
- 強い点
  - サーバ側に状態を持たず実装できる（スケールしやすい）
- 弱くなる典型（成立根拠がここに出る）
  - Cookieに HttpOnly を付けたまま、フロントが値を読めず “固定値/欠落” 運用に落ちる
  - トークンCookieが別経路で読める（XSS等）と崩れる（※XSSがある時点で致命的だが、防御層としての期待値が誤る）
  - サーバが「CookieがあるならOK」「どちらか片方でOK」等の誤実装（= 2箇所一致になっていない）
- 実務上の注意
  - Double Submit は“設計の理解不足”で誤実装が起きやすい。診断では「一致条件」「バインド」「例外パス」を必ず確認する

---

## 観測ポイント（診断で見るべき“最小差分セット”）
### 1) まず守るべき対象を固定：状態変更の棚卸し
- UIベース：保存、更新、削除、承認、送信、実行、発行、連携、招待、権限変更
- APIベース：PUT/PATCH/POST/DELETE、またはRPC的エンドポイント
- 例外注意：GETで状態変更、JSONでもフォーム互換で受理、multipart（アップロード）で抜ける

### 2) トークンの存在と搬送経路（どこに入っているか）
- form body（hidden）
- JSON body（csrfフィールド）
- header（X-CSRF-Token 等）
- cookie（Double Submit用）
- “最重要”は、**状態変更要求のすべてで**同様に運用されているか（1箇所でも抜けると成立）

### 3) トークンの性質（強度要件の観測）
OWASPはCSRFトークンに「セッション毎に一意」「秘密」「予測不能」を求める
- 一意性：ユーザ間/セッション間で共有されないか
- 予測不能性：十分なランダム性（短い連番や固定文字列は不可）
- 寿命：セッション寿命と整合するか（ログアウト/失効で無効化されるか）
- 使い回し：ワンタイム/リクエスト単位の必要性は要件次第だが、少なくとも“無制限に使える固定値”は危険

### 4) 検証点（サーバ側が何を条件に受理しているか）
- 欠落時：401/403 で拒否できているか（処理が進んでいないか）
- 不一致時：同様に拒否できているか
- “比較”の厳密さ：文字列比較の正規化や空白許容などが過剰に緩くないか
- リダイレクトやエラー時：例外的に通っていないか（エラーハンドリングの境界）

---

## 結果の意味（状態としての判定）
### 状態A：強い（最低限の要件を満たす）
- 全状態変更要求にCSRF防御が適用されている
- トークンがセッション/ユーザに紐づき、予測不能で、欠落/不一致で確実に拒否する
- 例外パス（アップロード、API、管理UI、SSO周辺）も同一ポリシーで守られている

### 状態B：弱い（攻撃者が狙う“成立根拠”がある）
- 一部エンドポイントで検証が抜けている（最頻）
- トークンが固定/再利用可能/ユーザ間共有
- Double Submitなのに一致条件が成立していない（どちらか片方でOK等）
- 欠落/不一致でも処理が継続する（エラー扱いだけで更新される等）

### 状態C：見かけ倒し（実装・運用が破綻）
- フロントがトークンを扱えず、実質無効（常に同じ値、空、ダミー）
- CSRFはあるが、重要操作が別チャネル（API/ジョブ/管理UI）で抜けている

---

## 攻撃者視点での利用（現実寄り：攻撃“経路”の考え方）
※ここでは“作り方”ではなく、診断で優先度を決めるための意思決定を記す（成立根拠の取り方が目的）
- まず狙うのは「重要操作」×「被害者が高権限」×「閲覧/誘導が成立しやすい導線」
  - 管理/運用UI（運用者が日常的に開く）
  - 設定変更（連携追加、権限付与、APIキー、支払設定）
- 次に狙うのは「防御の抜けが出やすい形式」
  - multipart（アップロード/インポート）
  - JSON API（CORSやカスタムヘッダ運用で例外が出る）
  - 古いエンドポイント（v1互換、旧UI）
- 成立根拠の証拠化（報告に耐える形）
  - “トークンなしで通る” “不一致でも通る” “特定エンドポイントだけ検証していない”
  - これを **HTTP差分（ステータス、レスポンス、反映結果）** で示す（外部送信や窃取は不要）

---

## 次に試すこと（仮説A/B：条件が違うと次の手が変わる）
### 仮説A：Synchronizer Token の可能性が高い（フォームにhidden、サーバセッションに紐付く）
- 次の一手
  1) 状態変更エンドポイントを横断し「検証の抜け」を探す（同一機能でも“別URL/別メソッド/別画面”がある）
  2) トークンのバインドを確定（ユーザ/セッション/画面遷移）：別セッションで同じトークンが使えないことを確認
  3) 欠落/不一致の拒否が確実かを確認（エラーでも更新されないか）
- 期待する観測
  - 強い実装：欠落/不一致がすべて拒否、セッション跨ぎ不可
  - 弱い実装：特定エンドポイントだけ素通り、検証が形式的、エラー時に処理継続

### 仮説B：Double Submit の可能性が高い（Cookieとheader/bodyが一致する前提）
- 次の一手
  1) Cookie側とheader/body側の“両方”が必要か（どちらか片方で通らないか）を確認
  2) Cookieの属性と取得経路を確認（HttpOnlyやSameSite運用が設計意図と整合しているか）
  3) トークンCookieがログイン/ログアウト/ローテーションでどう変わるか（固定化は危険）
- 期待する観測
  - 強い実装：2箇所一致必須、欠落/不一致拒否、ユーザ/セッションで一意
  - 弱い実装：片方だけでOK、固定値、実質ダミー運用

### 仮説C：トークンはあるが “適用範囲” が怪しい（例外パス）
- 次の一手
  - multipart / JSON API / 管理UI / 旧API / SSO周辺の状態変更を重点確認
  - “同じビジネス操作”が複数経路で実行できないか（UI→API、旧UI→新UI）を洗う

---

## 手を動かす検証（Labs連動：観測→解釈→利用を再現）
- 追加候補Lab（設計として作る）
  - `04_labs/02_web/05_input/07_csrf_token_boundary/`
- 最小構成（現実寄り）
  - 操作を3種：プロフィール更新（低）／メール変更（中）／権限付与（高）
  - 防御を2種：Synchronizer / Double Submit
  - 例外パスを1つ：multipart か JSON API（“抜け”が起きる典型を再現）
- 取得する証跡
  - HAR（トークン発行→送信→検証失敗時の応答）
  - アプリログ（拒否理由、検証分岐、対象エンドポイントの網羅性）
  - 重要：成功/失敗の差分を「反映結果」で確認（ステータスだけで断定しない）

---

## コマンド/リクエスト例（例示は最小限：観測の形だけ）
~~~~
# 観測目的：状態変更リクエストに CSRF トークンが「どこに」「毎回」入っているかを見る
# 例（概念）：
POST /account/email
Cookie: session=...
Header: X-CSRF-Token: <token>          # または body に csrf フィールド
Body: email=new@example.com

# 検証（概念）：
- token を欠落させる → 401/403 で拒否され、変更が反映されない
- token を改変する → 同様に拒否される
- 別セッションの token を混ぜる → 拒否される（バインド確認）
~~~~

---

## 参考（一次情報に近いもの中心）
- OWASP WSTG：Testing for Cross Site Request Forgery（WSTG-SESS-05）
- OWASP Cheat Sheet：CSRF Prevention（トークン要件：セッション毎に一意、秘密、予測不能）
- OWASP Community：CSRF（ブラウザが資格情報を自動送信する前提の整理）
- CAPEC-62：CSRF（攻撃が“リンク配布/誘導”で成立するモデル）
- CWE-352：CSRF（脆弱性分類としての定義）
- MITRE ATT&CK：Drive-by Compromise（T1189）

---

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`（SameSiteがCSRF条件に影響）
- `01_topics/02_web/06_config_01_CORSと信頼境界（Origin_資格情報_プリフライト）.md`（JSON API/SPAでの例外設計）
- `01_topics/02_web/05_input_06_xss_02_格納_境界モデル.md`（XSSがあるとCSRF対策の前提が崩れる）

---

## 次（作成候補順）
- `01_topics/02_web/05_input_07_csrf_02_samesite（cookie_credential）.md`
